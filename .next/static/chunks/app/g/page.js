/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/g/page"],{

/***/ "(app-client)/./node_modules/@tweenjs/tween.js/dist/tween.esm.js":
/*!**********************************************************!*\
  !*** ./node_modules/@tweenjs/tween.js/dist/tween.esm.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Easing: function() { return /* binding */ Easing; },\n/* harmony export */   Group: function() { return /* binding */ Group; },\n/* harmony export */   Interpolation: function() { return /* binding */ Interpolation; },\n/* harmony export */   Sequence: function() { return /* binding */ Sequence; },\n/* harmony export */   Tween: function() { return /* binding */ Tween; },\n/* harmony export */   VERSION: function() { return /* binding */ VERSION; },\n/* harmony export */   add: function() { return /* binding */ add; },\n/* harmony export */   getAll: function() { return /* binding */ getAll; },\n/* harmony export */   nextId: function() { return /* binding */ nextId; },\n/* harmony export */   now: function() { return /* binding */ now$1; },\n/* harmony export */   remove: function() { return /* binding */ remove; },\n/* harmony export */   removeAll: function() { return /* binding */ removeAll; },\n/* harmony export */   update: function() { return /* binding */ update; }\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-client)/./node_modules/next/dist/build/polyfills/process.js\");\n/**\n * The Ease class provides a collection of easing functions for use with tween.js.\n */\nvar Easing = {\n    Linear: {\n        None: function (amount) {\n            return amount;\n        },\n    },\n    Quadratic: {\n        In: function (amount) {\n            return amount * amount;\n        },\n        Out: function (amount) {\n            return amount * (2 - amount);\n        },\n        InOut: function (amount) {\n            if ((amount *= 2) < 1) {\n                return 0.5 * amount * amount;\n            }\n            return -0.5 * (--amount * (amount - 2) - 1);\n        },\n    },\n    Cubic: {\n        In: function (amount) {\n            return amount * amount * amount;\n        },\n        Out: function (amount) {\n            return --amount * amount * amount + 1;\n        },\n        InOut: function (amount) {\n            if ((amount *= 2) < 1) {\n                return 0.5 * amount * amount * amount;\n            }\n            return 0.5 * ((amount -= 2) * amount * amount + 2);\n        },\n    },\n    Quartic: {\n        In: function (amount) {\n            return amount * amount * amount * amount;\n        },\n        Out: function (amount) {\n            return 1 - --amount * amount * amount * amount;\n        },\n        InOut: function (amount) {\n            if ((amount *= 2) < 1) {\n                return 0.5 * amount * amount * amount * amount;\n            }\n            return -0.5 * ((amount -= 2) * amount * amount * amount - 2);\n        },\n    },\n    Quintic: {\n        In: function (amount) {\n            return amount * amount * amount * amount * amount;\n        },\n        Out: function (amount) {\n            return --amount * amount * amount * amount * amount + 1;\n        },\n        InOut: function (amount) {\n            if ((amount *= 2) < 1) {\n                return 0.5 * amount * amount * amount * amount * amount;\n            }\n            return 0.5 * ((amount -= 2) * amount * amount * amount * amount + 2);\n        },\n    },\n    Sinusoidal: {\n        In: function (amount) {\n            return 1 - Math.cos((amount * Math.PI) / 2);\n        },\n        Out: function (amount) {\n            return Math.sin((amount * Math.PI) / 2);\n        },\n        InOut: function (amount) {\n            return 0.5 * (1 - Math.cos(Math.PI * amount));\n        },\n    },\n    Exponential: {\n        In: function (amount) {\n            return amount === 0 ? 0 : Math.pow(1024, amount - 1);\n        },\n        Out: function (amount) {\n            return amount === 1 ? 1 : 1 - Math.pow(2, -10 * amount);\n        },\n        InOut: function (amount) {\n            if (amount === 0) {\n                return 0;\n            }\n            if (amount === 1) {\n                return 1;\n            }\n            if ((amount *= 2) < 1) {\n                return 0.5 * Math.pow(1024, amount - 1);\n            }\n            return 0.5 * (-Math.pow(2, -10 * (amount - 1)) + 2);\n        },\n    },\n    Circular: {\n        In: function (amount) {\n            return 1 - Math.sqrt(1 - amount * amount);\n        },\n        Out: function (amount) {\n            return Math.sqrt(1 - --amount * amount);\n        },\n        InOut: function (amount) {\n            if ((amount *= 2) < 1) {\n                return -0.5 * (Math.sqrt(1 - amount * amount) - 1);\n            }\n            return 0.5 * (Math.sqrt(1 - (amount -= 2) * amount) + 1);\n        },\n    },\n    Elastic: {\n        In: function (amount) {\n            if (amount === 0) {\n                return 0;\n            }\n            if (amount === 1) {\n                return 1;\n            }\n            return -Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);\n        },\n        Out: function (amount) {\n            if (amount === 0) {\n                return 0;\n            }\n            if (amount === 1) {\n                return 1;\n            }\n            return Math.pow(2, -10 * amount) * Math.sin((amount - 0.1) * 5 * Math.PI) + 1;\n        },\n        InOut: function (amount) {\n            if (amount === 0) {\n                return 0;\n            }\n            if (amount === 1) {\n                return 1;\n            }\n            amount *= 2;\n            if (amount < 1) {\n                return -0.5 * Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);\n            }\n            return 0.5 * Math.pow(2, -10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI) + 1;\n        },\n    },\n    Back: {\n        In: function (amount) {\n            var s = 1.70158;\n            return amount * amount * ((s + 1) * amount - s);\n        },\n        Out: function (amount) {\n            var s = 1.70158;\n            return --amount * amount * ((s + 1) * amount + s) + 1;\n        },\n        InOut: function (amount) {\n            var s = 1.70158 * 1.525;\n            if ((amount *= 2) < 1) {\n                return 0.5 * (amount * amount * ((s + 1) * amount - s));\n            }\n            return 0.5 * ((amount -= 2) * amount * ((s + 1) * amount + s) + 2);\n        },\n    },\n    Bounce: {\n        In: function (amount) {\n            return 1 - Easing.Bounce.Out(1 - amount);\n        },\n        Out: function (amount) {\n            if (amount < 1 / 2.75) {\n                return 7.5625 * amount * amount;\n            }\n            else if (amount < 2 / 2.75) {\n                return 7.5625 * (amount -= 1.5 / 2.75) * amount + 0.75;\n            }\n            else if (amount < 2.5 / 2.75) {\n                return 7.5625 * (amount -= 2.25 / 2.75) * amount + 0.9375;\n            }\n            else {\n                return 7.5625 * (amount -= 2.625 / 2.75) * amount + 0.984375;\n            }\n        },\n        InOut: function (amount) {\n            if (amount < 0.5) {\n                return Easing.Bounce.In(amount * 2) * 0.5;\n            }\n            return Easing.Bounce.Out(amount * 2 - 1) * 0.5 + 0.5;\n        },\n    },\n};\n\nvar now;\n// Include a performance.now polyfill.\n// In node.js, use process.hrtime.\n// eslint-disable-next-line\n// @ts-ignore\nif (typeof self === 'undefined' && typeof process !== 'undefined' && process.hrtime) {\n    now = function () {\n        // eslint-disable-next-line\n        // @ts-ignore\n        var time = process.hrtime();\n        // Convert [seconds, nanoseconds] to milliseconds.\n        return time[0] * 1000 + time[1] / 1000000;\n    };\n}\n// In a browser, use self.performance.now if it is available.\nelse if (typeof self !== 'undefined' && self.performance !== undefined && self.performance.now !== undefined) {\n    // This must be bound, because directly assigning this function\n    // leads to an invocation exception in Chrome.\n    now = self.performance.now.bind(self.performance);\n}\n// Use Date.now if it is available.\nelse if (Date.now !== undefined) {\n    now = Date.now;\n}\n// Otherwise, use 'new Date().getTime()'.\nelse {\n    now = function () {\n        return new Date().getTime();\n    };\n}\nvar now$1 = now;\n\n/**\n * Controlling groups of tweens\n *\n * Using the TWEEN singleton to manage your tweens can cause issues in large apps with many components.\n * In these cases, you may want to create your own smaller groups of tween\n */\nvar Group = /** @class */ (function () {\n    function Group() {\n        this._tweens = {};\n        this._tweensAddedDuringUpdate = {};\n    }\n    Group.prototype.getAll = function () {\n        var _this = this;\n        return Object.keys(this._tweens).map(function (tweenId) {\n            return _this._tweens[tweenId];\n        });\n    };\n    Group.prototype.removeAll = function () {\n        this._tweens = {};\n    };\n    Group.prototype.add = function (tween) {\n        this._tweens[tween.getId()] = tween;\n        this._tweensAddedDuringUpdate[tween.getId()] = tween;\n    };\n    Group.prototype.remove = function (tween) {\n        delete this._tweens[tween.getId()];\n        delete this._tweensAddedDuringUpdate[tween.getId()];\n    };\n    Group.prototype.update = function (time, preserve) {\n        if (time === void 0) { time = now$1(); }\n        if (preserve === void 0) { preserve = false; }\n        var tweenIds = Object.keys(this._tweens);\n        if (tweenIds.length === 0) {\n            return false;\n        }\n        // Tweens are updated in \"batches\". If you add a new tween during an\n        // update, then the new tween will be updated in the next batch.\n        // If you remove a tween during an update, it may or may not be updated.\n        // However, if the removed tween was added during the current batch,\n        // then it will not be updated.\n        while (tweenIds.length > 0) {\n            this._tweensAddedDuringUpdate = {};\n            for (var i = 0; i < tweenIds.length; i++) {\n                var tween = this._tweens[tweenIds[i]];\n                var autoStart = !preserve;\n                if (tween && tween.update(time, autoStart) === false && !preserve) {\n                    delete this._tweens[tweenIds[i]];\n                }\n            }\n            tweenIds = Object.keys(this._tweensAddedDuringUpdate);\n        }\n        return true;\n    };\n    return Group;\n}());\n\n/**\n *\n */\nvar Interpolation = {\n    Linear: function (v, k) {\n        var m = v.length - 1;\n        var f = m * k;\n        var i = Math.floor(f);\n        var fn = Interpolation.Utils.Linear;\n        if (k < 0) {\n            return fn(v[0], v[1], f);\n        }\n        if (k > 1) {\n            return fn(v[m], v[m - 1], m - f);\n        }\n        return fn(v[i], v[i + 1 > m ? m : i + 1], f - i);\n    },\n    Bezier: function (v, k) {\n        var b = 0;\n        var n = v.length - 1;\n        var pw = Math.pow;\n        var bn = Interpolation.Utils.Bernstein;\n        for (var i = 0; i <= n; i++) {\n            b += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i);\n        }\n        return b;\n    },\n    CatmullRom: function (v, k) {\n        var m = v.length - 1;\n        var f = m * k;\n        var i = Math.floor(f);\n        var fn = Interpolation.Utils.CatmullRom;\n        if (v[0] === v[m]) {\n            if (k < 0) {\n                i = Math.floor((f = m * (1 + k)));\n            }\n            return fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);\n        }\n        else {\n            if (k < 0) {\n                return v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]);\n            }\n            if (k > 1) {\n                return v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);\n            }\n            return fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);\n        }\n    },\n    Utils: {\n        Linear: function (p0, p1, t) {\n            return (p1 - p0) * t + p0;\n        },\n        Bernstein: function (n, i) {\n            var fc = Interpolation.Utils.Factorial;\n            return fc(n) / fc(i) / fc(n - i);\n        },\n        Factorial: (function () {\n            var a = [1];\n            return function (n) {\n                var s = 1;\n                if (a[n]) {\n                    return a[n];\n                }\n                for (var i = n; i > 1; i--) {\n                    s *= i;\n                }\n                a[n] = s;\n                return s;\n            };\n        })(),\n        CatmullRom: function (p0, p1, p2, p3, t) {\n            var v0 = (p2 - p0) * 0.5;\n            var v1 = (p3 - p1) * 0.5;\n            var t2 = t * t;\n            var t3 = t * t2;\n            return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;\n        },\n    },\n};\n\n/**\n * Utils\n */\nvar Sequence = /** @class */ (function () {\n    function Sequence() {\n    }\n    Sequence.nextId = function () {\n        return Sequence._nextId++;\n    };\n    Sequence._nextId = 0;\n    return Sequence;\n}());\n\nvar mainGroup = new Group();\n\n/**\n * Tween.js - Licensed under the MIT license\n * https://github.com/tweenjs/tween.js\n * ----------------------------------------------\n *\n * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.\n * Thank you all, you're awesome!\n */\nvar Tween = /** @class */ (function () {\n    function Tween(_object, _group) {\n        if (_group === void 0) { _group = mainGroup; }\n        this._object = _object;\n        this._group = _group;\n        this._isPaused = false;\n        this._pauseStart = 0;\n        this._valuesStart = {};\n        this._valuesEnd = {};\n        this._valuesStartRepeat = {};\n        this._duration = 1000;\n        this._initialRepeat = 0;\n        this._repeat = 0;\n        this._yoyo = false;\n        this._isPlaying = false;\n        this._reversed = false;\n        this._delayTime = 0;\n        this._startTime = 0;\n        this._easingFunction = Easing.Linear.None;\n        this._interpolationFunction = Interpolation.Linear;\n        this._chainedTweens = [];\n        this._onStartCallbackFired = false;\n        this._id = Sequence.nextId();\n        this._isChainStopped = false;\n        this._goToEnd = false;\n    }\n    Tween.prototype.getId = function () {\n        return this._id;\n    };\n    Tween.prototype.isPlaying = function () {\n        return this._isPlaying;\n    };\n    Tween.prototype.isPaused = function () {\n        return this._isPaused;\n    };\n    Tween.prototype.to = function (properties, duration) {\n        // TODO? restore this, then update the 07_dynamic_to example to set fox\n        // tween's to on each update. That way the behavior is opt-in (there's\n        // currently no opt-out).\n        // for (const prop in properties) this._valuesEnd[prop] = properties[prop]\n        this._valuesEnd = Object.create(properties);\n        if (duration !== undefined) {\n            this._duration = duration;\n        }\n        return this;\n    };\n    Tween.prototype.duration = function (d) {\n        this._duration = d;\n        return this;\n    };\n    Tween.prototype.start = function (time) {\n        if (this._isPlaying) {\n            return this;\n        }\n        // eslint-disable-next-line\n        this._group && this._group.add(this);\n        this._repeat = this._initialRepeat;\n        if (this._reversed) {\n            // If we were reversed (f.e. using the yoyo feature) then we need to\n            // flip the tween direction back to forward.\n            this._reversed = false;\n            for (var property in this._valuesStartRepeat) {\n                this._swapEndStartRepeatValues(property);\n                this._valuesStart[property] = this._valuesStartRepeat[property];\n            }\n        }\n        this._isPlaying = true;\n        this._isPaused = false;\n        this._onStartCallbackFired = false;\n        this._isChainStopped = false;\n        this._startTime = time !== undefined ? (typeof time === 'string' ? now$1() + parseFloat(time) : time) : now$1();\n        this._startTime += this._delayTime;\n        this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat);\n        return this;\n    };\n    Tween.prototype._setupProperties = function (_object, _valuesStart, _valuesEnd, _valuesStartRepeat) {\n        for (var property in _valuesEnd) {\n            var startValue = _object[property];\n            var startValueIsArray = Array.isArray(startValue);\n            var propType = startValueIsArray ? 'array' : typeof startValue;\n            var isInterpolationList = !startValueIsArray && Array.isArray(_valuesEnd[property]);\n            // If `to()` specifies a property that doesn't exist in the source object,\n            // we should not set that property in the object\n            if (propType === 'undefined' || propType === 'function') {\n                continue;\n            }\n            // Check if an Array was provided as property value\n            if (isInterpolationList) {\n                var endValues = _valuesEnd[property];\n                if (endValues.length === 0) {\n                    continue;\n                }\n                // handle an array of relative values\n                endValues = endValues.map(this._handleRelativeValue.bind(this, startValue));\n                // Create a local copy of the Array with the start value at the front\n                _valuesEnd[property] = [startValue].concat(endValues);\n            }\n            // handle the deepness of the values\n            if ((propType === 'object' || startValueIsArray) && startValue && !isInterpolationList) {\n                _valuesStart[property] = startValueIsArray ? [] : {};\n                // eslint-disable-next-line\n                for (var prop in startValue) {\n                    // eslint-disable-next-line\n                    // @ts-ignore FIXME?\n                    _valuesStart[property][prop] = startValue[prop];\n                }\n                _valuesStartRepeat[property] = startValueIsArray ? [] : {}; // TODO? repeat nested values? And yoyo? And array values?\n                // eslint-disable-next-line\n                // @ts-ignore FIXME?\n                this._setupProperties(startValue, _valuesStart[property], _valuesEnd[property], _valuesStartRepeat[property]);\n            }\n            else {\n                // Save the starting value, but only once.\n                if (typeof _valuesStart[property] === 'undefined') {\n                    _valuesStart[property] = startValue;\n                }\n                if (!startValueIsArray) {\n                    // eslint-disable-next-line\n                    // @ts-ignore FIXME?\n                    _valuesStart[property] *= 1.0; // Ensures we're using numbers, not strings\n                }\n                if (isInterpolationList) {\n                    // eslint-disable-next-line\n                    // @ts-ignore FIXME?\n                    _valuesStartRepeat[property] = _valuesEnd[property].slice().reverse();\n                }\n                else {\n                    _valuesStartRepeat[property] = _valuesStart[property] || 0;\n                }\n            }\n        }\n    };\n    Tween.prototype.stop = function () {\n        if (!this._isChainStopped) {\n            this._isChainStopped = true;\n            this.stopChainedTweens();\n        }\n        if (!this._isPlaying) {\n            return this;\n        }\n        // eslint-disable-next-line\n        this._group && this._group.remove(this);\n        this._isPlaying = false;\n        this._isPaused = false;\n        if (this._onStopCallback) {\n            this._onStopCallback(this._object);\n        }\n        return this;\n    };\n    Tween.prototype.end = function () {\n        this._goToEnd = true;\n        this.update(Infinity);\n        return this;\n    };\n    Tween.prototype.pause = function (time) {\n        if (time === void 0) { time = now$1(); }\n        if (this._isPaused || !this._isPlaying) {\n            return this;\n        }\n        this._isPaused = true;\n        this._pauseStart = time;\n        // eslint-disable-next-line\n        this._group && this._group.remove(this);\n        return this;\n    };\n    Tween.prototype.resume = function (time) {\n        if (time === void 0) { time = now$1(); }\n        if (!this._isPaused || !this._isPlaying) {\n            return this;\n        }\n        this._isPaused = false;\n        this._startTime += time - this._pauseStart;\n        this._pauseStart = 0;\n        // eslint-disable-next-line\n        this._group && this._group.add(this);\n        return this;\n    };\n    Tween.prototype.stopChainedTweens = function () {\n        for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {\n            this._chainedTweens[i].stop();\n        }\n        return this;\n    };\n    Tween.prototype.group = function (group) {\n        this._group = group;\n        return this;\n    };\n    Tween.prototype.delay = function (amount) {\n        this._delayTime = amount;\n        return this;\n    };\n    Tween.prototype.repeat = function (times) {\n        this._initialRepeat = times;\n        this._repeat = times;\n        return this;\n    };\n    Tween.prototype.repeatDelay = function (amount) {\n        this._repeatDelayTime = amount;\n        return this;\n    };\n    Tween.prototype.yoyo = function (yoyo) {\n        this._yoyo = yoyo;\n        return this;\n    };\n    Tween.prototype.easing = function (easingFunction) {\n        this._easingFunction = easingFunction;\n        return this;\n    };\n    Tween.prototype.interpolation = function (interpolationFunction) {\n        this._interpolationFunction = interpolationFunction;\n        return this;\n    };\n    Tween.prototype.chain = function () {\n        var tweens = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            tweens[_i] = arguments[_i];\n        }\n        this._chainedTweens = tweens;\n        return this;\n    };\n    Tween.prototype.onStart = function (callback) {\n        this._onStartCallback = callback;\n        return this;\n    };\n    Tween.prototype.onUpdate = function (callback) {\n        this._onUpdateCallback = callback;\n        return this;\n    };\n    Tween.prototype.onRepeat = function (callback) {\n        this._onRepeatCallback = callback;\n        return this;\n    };\n    Tween.prototype.onComplete = function (callback) {\n        this._onCompleteCallback = callback;\n        return this;\n    };\n    Tween.prototype.onStop = function (callback) {\n        this._onStopCallback = callback;\n        return this;\n    };\n    /**\n     * @returns true if the tween is still playing after the update, false\n     * otherwise (calling update on a paused tween still returns true because\n     * it is still playing, just paused).\n     */\n    Tween.prototype.update = function (time, autoStart) {\n        if (time === void 0) { time = now$1(); }\n        if (autoStart === void 0) { autoStart = true; }\n        if (this._isPaused)\n            return true;\n        var property;\n        var elapsed;\n        var endTime = this._startTime + this._duration;\n        if (!this._goToEnd && !this._isPlaying) {\n            if (time > endTime)\n                return false;\n            if (autoStart)\n                this.start(time);\n        }\n        this._goToEnd = false;\n        if (time < this._startTime) {\n            return true;\n        }\n        if (this._onStartCallbackFired === false) {\n            if (this._onStartCallback) {\n                this._onStartCallback(this._object);\n            }\n            this._onStartCallbackFired = true;\n        }\n        elapsed = (time - this._startTime) / this._duration;\n        elapsed = this._duration === 0 || elapsed > 1 ? 1 : elapsed;\n        var value = this._easingFunction(elapsed);\n        // properties transformations\n        this._updateProperties(this._object, this._valuesStart, this._valuesEnd, value);\n        if (this._onUpdateCallback) {\n            this._onUpdateCallback(this._object, elapsed);\n        }\n        if (elapsed === 1) {\n            if (this._repeat > 0) {\n                if (isFinite(this._repeat)) {\n                    this._repeat--;\n                }\n                // Reassign starting values, restart by making startTime = now\n                for (property in this._valuesStartRepeat) {\n                    if (!this._yoyo && typeof this._valuesEnd[property] === 'string') {\n                        this._valuesStartRepeat[property] =\n                            // eslint-disable-next-line\n                            // @ts-ignore FIXME?\n                            this._valuesStartRepeat[property] + parseFloat(this._valuesEnd[property]);\n                    }\n                    if (this._yoyo) {\n                        this._swapEndStartRepeatValues(property);\n                    }\n                    this._valuesStart[property] = this._valuesStartRepeat[property];\n                }\n                if (this._yoyo) {\n                    this._reversed = !this._reversed;\n                }\n                if (this._repeatDelayTime !== undefined) {\n                    this._startTime = time + this._repeatDelayTime;\n                }\n                else {\n                    this._startTime = time + this._delayTime;\n                }\n                if (this._onRepeatCallback) {\n                    this._onRepeatCallback(this._object);\n                }\n                return true;\n            }\n            else {\n                if (this._onCompleteCallback) {\n                    this._onCompleteCallback(this._object);\n                }\n                for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {\n                    // Make the chained tweens start exactly at the time they should,\n                    // even if the `update()` method was called way past the duration of the tween\n                    this._chainedTweens[i].start(this._startTime + this._duration);\n                }\n                this._isPlaying = false;\n                return false;\n            }\n        }\n        return true;\n    };\n    Tween.prototype._updateProperties = function (_object, _valuesStart, _valuesEnd, value) {\n        for (var property in _valuesEnd) {\n            // Don't update properties that do not exist in the source object\n            if (_valuesStart[property] === undefined) {\n                continue;\n            }\n            var start = _valuesStart[property] || 0;\n            var end = _valuesEnd[property];\n            var startIsArray = Array.isArray(_object[property]);\n            var endIsArray = Array.isArray(end);\n            var isInterpolationList = !startIsArray && endIsArray;\n            if (isInterpolationList) {\n                _object[property] = this._interpolationFunction(end, value);\n            }\n            else if (typeof end === 'object' && end) {\n                // eslint-disable-next-line\n                // @ts-ignore FIXME?\n                this._updateProperties(_object[property], start, end, value);\n            }\n            else {\n                // Parses relative end values with start as base (e.g.: +10, -3)\n                end = this._handleRelativeValue(start, end);\n                // Protect against non numeric properties.\n                if (typeof end === 'number') {\n                    // eslint-disable-next-line\n                    // @ts-ignore FIXME?\n                    _object[property] = start + (end - start) * value;\n                }\n            }\n        }\n    };\n    Tween.prototype._handleRelativeValue = function (start, end) {\n        if (typeof end !== 'string') {\n            return end;\n        }\n        if (end.charAt(0) === '+' || end.charAt(0) === '-') {\n            return start + parseFloat(end);\n        }\n        else {\n            return parseFloat(end);\n        }\n    };\n    Tween.prototype._swapEndStartRepeatValues = function (property) {\n        var tmp = this._valuesStartRepeat[property];\n        var endValue = this._valuesEnd[property];\n        if (typeof endValue === 'string') {\n            this._valuesStartRepeat[property] = this._valuesStartRepeat[property] + parseFloat(endValue);\n        }\n        else {\n            this._valuesStartRepeat[property] = this._valuesEnd[property];\n        }\n        this._valuesEnd[property] = tmp;\n    };\n    return Tween;\n}());\n\nvar VERSION = '18.6.4';\n\n/**\n * Tween.js - Licensed under the MIT license\n * https://github.com/tweenjs/tween.js\n * ----------------------------------------------\n *\n * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.\n * Thank you all, you're awesome!\n */\nvar nextId = Sequence.nextId;\n/**\n * Controlling groups of tweens\n *\n * Using the TWEEN singleton to manage your tweens can cause issues in large apps with many components.\n * In these cases, you may want to create your own smaller groups of tweens.\n */\nvar TWEEN = mainGroup;\n// This is the best way to export things in a way that's compatible with both ES\n// Modules and CommonJS, without build hacks, and so as not to break the\n// existing API.\n// https://github.com/rollup/rollup/issues/1961#issuecomment-423037881\nvar getAll = TWEEN.getAll.bind(TWEEN);\nvar removeAll = TWEEN.removeAll.bind(TWEEN);\nvar add = TWEEN.add.bind(TWEEN);\nvar remove = TWEEN.remove.bind(TWEEN);\nvar update = TWEEN.update.bind(TWEEN);\nvar exports = {\n    Easing: Easing,\n    Group: Group,\n    Interpolation: Interpolation,\n    now: now$1,\n    Sequence: Sequence,\n    nextId: nextId,\n    Tween: Tween,\n    VERSION: VERSION,\n    getAll: getAll,\n    removeAll: removeAll,\n    add: add,\n    remove: remove,\n    update: update,\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (exports);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL0B0d2VlbmpzL3R3ZWVuLmpzL2Rpc3QvdHdlZW4uZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTyxvQkFBb0IsT0FBTztBQUM1RTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLHNCQUFzQjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQixvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxzQkFBc0I7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtEQUFlLE9BQU8sRUFBQztBQUN5RyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHR3ZWVuanMvdHdlZW4uanMvZGlzdC90d2Vlbi5lc20uanM/YzgxNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRoZSBFYXNlIGNsYXNzIHByb3ZpZGVzIGEgY29sbGVjdGlvbiBvZiBlYXNpbmcgZnVuY3Rpb25zIGZvciB1c2Ugd2l0aCB0d2Vlbi5qcy5cbiAqL1xudmFyIEVhc2luZyA9IHtcbiAgICBMaW5lYXI6IHtcbiAgICAgICAgTm9uZTogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIGFtb3VudDtcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIFF1YWRyYXRpYzoge1xuICAgICAgICBJbjogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIGFtb3VudCAqIGFtb3VudDtcbiAgICAgICAgfSxcbiAgICAgICAgT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gYW1vdW50ICogKDIgLSBhbW91bnQpO1xuICAgICAgICB9LFxuICAgICAgICBJbk91dDogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgaWYgKChhbW91bnQgKj0gMikgPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDAuNSAqIGFtb3VudCAqIGFtb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAtMC41ICogKC0tYW1vdW50ICogKGFtb3VudCAtIDIpIC0gMSk7XG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBDdWJpYzoge1xuICAgICAgICBJbjogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIGFtb3VudCAqIGFtb3VudCAqIGFtb3VudDtcbiAgICAgICAgfSxcbiAgICAgICAgT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gLS1hbW91bnQgKiBhbW91bnQgKiBhbW91bnQgKyAxO1xuICAgICAgICB9LFxuICAgICAgICBJbk91dDogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgaWYgKChhbW91bnQgKj0gMikgPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDAuNSAqIGFtb3VudCAqIGFtb3VudCAqIGFtb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwLjUgKiAoKGFtb3VudCAtPSAyKSAqIGFtb3VudCAqIGFtb3VudCArIDIpO1xuICAgICAgICB9LFxuICAgIH0sXG4gICAgUXVhcnRpYzoge1xuICAgICAgICBJbjogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIGFtb3VudCAqIGFtb3VudCAqIGFtb3VudCAqIGFtb3VudDtcbiAgICAgICAgfSxcbiAgICAgICAgT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gMSAtIC0tYW1vdW50ICogYW1vdW50ICogYW1vdW50ICogYW1vdW50O1xuICAgICAgICB9LFxuICAgICAgICBJbk91dDogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgaWYgKChhbW91bnQgKj0gMikgPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDAuNSAqIGFtb3VudCAqIGFtb3VudCAqIGFtb3VudCAqIGFtb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAtMC41ICogKChhbW91bnQgLT0gMikgKiBhbW91bnQgKiBhbW91bnQgKiBhbW91bnQgLSAyKTtcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIFF1aW50aWM6IHtcbiAgICAgICAgSW46IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIHJldHVybiBhbW91bnQgKiBhbW91bnQgKiBhbW91bnQgKiBhbW91bnQgKiBhbW91bnQ7XG4gICAgICAgIH0sXG4gICAgICAgIE91dDogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIC0tYW1vdW50ICogYW1vdW50ICogYW1vdW50ICogYW1vdW50ICogYW1vdW50ICsgMTtcbiAgICAgICAgfSxcbiAgICAgICAgSW5PdXQ6IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIGlmICgoYW1vdW50ICo9IDIpIDwgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwLjUgKiBhbW91bnQgKiBhbW91bnQgKiBhbW91bnQgKiBhbW91bnQgKiBhbW91bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMC41ICogKChhbW91bnQgLT0gMikgKiBhbW91bnQgKiBhbW91bnQgKiBhbW91bnQgKiBhbW91bnQgKyAyKTtcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIFNpbnVzb2lkYWw6IHtcbiAgICAgICAgSW46IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIHJldHVybiAxIC0gTWF0aC5jb3MoKGFtb3VudCAqIE1hdGguUEkpIC8gMik7XG4gICAgICAgIH0sXG4gICAgICAgIE91dDogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguc2luKChhbW91bnQgKiBNYXRoLlBJKSAvIDIpO1xuICAgICAgICB9LFxuICAgICAgICBJbk91dDogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIDAuNSAqICgxIC0gTWF0aC5jb3MoTWF0aC5QSSAqIGFtb3VudCkpO1xuICAgICAgICB9LFxuICAgIH0sXG4gICAgRXhwb25lbnRpYWw6IHtcbiAgICAgICAgSW46IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIHJldHVybiBhbW91bnQgPT09IDAgPyAwIDogTWF0aC5wb3coMTAyNCwgYW1vdW50IC0gMSk7XG4gICAgICAgIH0sXG4gICAgICAgIE91dDogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIGFtb3VudCA9PT0gMSA/IDEgOiAxIC0gTWF0aC5wb3coMiwgLTEwICogYW1vdW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgSW5PdXQ6IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIGlmIChhbW91bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbW91bnQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoYW1vdW50ICo9IDIpIDwgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwLjUgKiBNYXRoLnBvdygxMDI0LCBhbW91bnQgLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwLjUgKiAoLU1hdGgucG93KDIsIC0xMCAqIChhbW91bnQgLSAxKSkgKyAyKTtcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIENpcmN1bGFyOiB7XG4gICAgICAgIEluOiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gMSAtIE1hdGguc3FydCgxIC0gYW1vdW50ICogYW1vdW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KDEgLSAtLWFtb3VudCAqIGFtb3VudCk7XG4gICAgICAgIH0sXG4gICAgICAgIEluT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICBpZiAoKGFtb3VudCAqPSAyKSA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTAuNSAqIChNYXRoLnNxcnQoMSAtIGFtb3VudCAqIGFtb3VudCkgLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwLjUgKiAoTWF0aC5zcXJ0KDEgLSAoYW1vdW50IC09IDIpICogYW1vdW50KSArIDEpO1xuICAgICAgICB9LFxuICAgIH0sXG4gICAgRWxhc3RpYzoge1xuICAgICAgICBJbjogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgaWYgKGFtb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFtb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC1NYXRoLnBvdygyLCAxMCAqIChhbW91bnQgLSAxKSkgKiBNYXRoLnNpbigoYW1vdW50IC0gMS4xKSAqIDUgKiBNYXRoLlBJKTtcbiAgICAgICAgfSxcbiAgICAgICAgT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICBpZiAoYW1vdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYW1vdW50ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5wb3coMiwgLTEwICogYW1vdW50KSAqIE1hdGguc2luKChhbW91bnQgLSAwLjEpICogNSAqIE1hdGguUEkpICsgMTtcbiAgICAgICAgfSxcbiAgICAgICAgSW5PdXQ6IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIGlmIChhbW91bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbW91bnQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFtb3VudCAqPSAyO1xuICAgICAgICAgICAgaWYgKGFtb3VudCA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTAuNSAqIE1hdGgucG93KDIsIDEwICogKGFtb3VudCAtIDEpKSAqIE1hdGguc2luKChhbW91bnQgLSAxLjEpICogNSAqIE1hdGguUEkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDAuNSAqIE1hdGgucG93KDIsIC0xMCAqIChhbW91bnQgLSAxKSkgKiBNYXRoLnNpbigoYW1vdW50IC0gMS4xKSAqIDUgKiBNYXRoLlBJKSArIDE7XG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBCYWNrOiB7XG4gICAgICAgIEluOiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICB2YXIgcyA9IDEuNzAxNTg7XG4gICAgICAgICAgICByZXR1cm4gYW1vdW50ICogYW1vdW50ICogKChzICsgMSkgKiBhbW91bnQgLSBzKTtcbiAgICAgICAgfSxcbiAgICAgICAgT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICB2YXIgcyA9IDEuNzAxNTg7XG4gICAgICAgICAgICByZXR1cm4gLS1hbW91bnQgKiBhbW91bnQgKiAoKHMgKyAxKSAqIGFtb3VudCArIHMpICsgMTtcbiAgICAgICAgfSxcbiAgICAgICAgSW5PdXQ6IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIHZhciBzID0gMS43MDE1OCAqIDEuNTI1O1xuICAgICAgICAgICAgaWYgKChhbW91bnQgKj0gMikgPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDAuNSAqIChhbW91bnQgKiBhbW91bnQgKiAoKHMgKyAxKSAqIGFtb3VudCAtIHMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwLjUgKiAoKGFtb3VudCAtPSAyKSAqIGFtb3VudCAqICgocyArIDEpICogYW1vdW50ICsgcykgKyAyKTtcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIEJvdW5jZToge1xuICAgICAgICBJbjogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIDEgLSBFYXNpbmcuQm91bmNlLk91dCgxIC0gYW1vdW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICBpZiAoYW1vdW50IDwgMSAvIDIuNzUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gNy41NjI1ICogYW1vdW50ICogYW1vdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYW1vdW50IDwgMiAvIDIuNzUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gNy41NjI1ICogKGFtb3VudCAtPSAxLjUgLyAyLjc1KSAqIGFtb3VudCArIDAuNzU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhbW91bnQgPCAyLjUgLyAyLjc1KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDcuNTYyNSAqIChhbW91bnQgLT0gMi4yNSAvIDIuNzUpICogYW1vdW50ICsgMC45Mzc1O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDcuNTYyNSAqIChhbW91bnQgLT0gMi42MjUgLyAyLjc1KSAqIGFtb3VudCArIDAuOTg0Mzc1O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBJbk91dDogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgaWYgKGFtb3VudCA8IDAuNSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBFYXNpbmcuQm91bmNlLkluKGFtb3VudCAqIDIpICogMC41O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEVhc2luZy5Cb3VuY2UuT3V0KGFtb3VudCAqIDIgLSAxKSAqIDAuNSArIDAuNTtcbiAgICAgICAgfSxcbiAgICB9LFxufTtcblxudmFyIG5vdztcbi8vIEluY2x1ZGUgYSBwZXJmb3JtYW5jZS5ub3cgcG9seWZpbGwuXG4vLyBJbiBub2RlLmpzLCB1c2UgcHJvY2Vzcy5ocnRpbWUuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbi8vIEB0cy1pZ25vcmVcbmlmICh0eXBlb2Ygc2VsZiA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuaHJ0aW1lKSB7XG4gICAgbm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB2YXIgdGltZSA9IHByb2Nlc3MuaHJ0aW1lKCk7XG4gICAgICAgIC8vIENvbnZlcnQgW3NlY29uZHMsIG5hbm9zZWNvbmRzXSB0byBtaWxsaXNlY29uZHMuXG4gICAgICAgIHJldHVybiB0aW1lWzBdICogMTAwMCArIHRpbWVbMV0gLyAxMDAwMDAwO1xuICAgIH07XG59XG4vLyBJbiBhIGJyb3dzZXIsIHVzZSBzZWxmLnBlcmZvcm1hbmNlLm5vdyBpZiBpdCBpcyBhdmFpbGFibGUuXG5lbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5wZXJmb3JtYW5jZSAhPT0gdW5kZWZpbmVkICYmIHNlbGYucGVyZm9ybWFuY2Uubm93ICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBUaGlzIG11c3QgYmUgYm91bmQsIGJlY2F1c2UgZGlyZWN0bHkgYXNzaWduaW5nIHRoaXMgZnVuY3Rpb25cbiAgICAvLyBsZWFkcyB0byBhbiBpbnZvY2F0aW9uIGV4Y2VwdGlvbiBpbiBDaHJvbWUuXG4gICAgbm93ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3cuYmluZChzZWxmLnBlcmZvcm1hbmNlKTtcbn1cbi8vIFVzZSBEYXRlLm5vdyBpZiBpdCBpcyBhdmFpbGFibGUuXG5lbHNlIGlmIChEYXRlLm5vdyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgbm93ID0gRGF0ZS5ub3c7XG59XG4vLyBPdGhlcndpc2UsIHVzZSAnbmV3IERhdGUoKS5nZXRUaW1lKCknLlxuZWxzZSB7XG4gICAgbm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgfTtcbn1cbnZhciBub3ckMSA9IG5vdztcblxuLyoqXG4gKiBDb250cm9sbGluZyBncm91cHMgb2YgdHdlZW5zXG4gKlxuICogVXNpbmcgdGhlIFRXRUVOIHNpbmdsZXRvbiB0byBtYW5hZ2UgeW91ciB0d2VlbnMgY2FuIGNhdXNlIGlzc3VlcyBpbiBsYXJnZSBhcHBzIHdpdGggbWFueSBjb21wb25lbnRzLlxuICogSW4gdGhlc2UgY2FzZXMsIHlvdSBtYXkgd2FudCB0byBjcmVhdGUgeW91ciBvd24gc21hbGxlciBncm91cHMgb2YgdHdlZW5cbiAqL1xudmFyIEdyb3VwID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEdyb3VwKCkge1xuICAgICAgICB0aGlzLl90d2VlbnMgPSB7fTtcbiAgICAgICAgdGhpcy5fdHdlZW5zQWRkZWREdXJpbmdVcGRhdGUgPSB7fTtcbiAgICB9XG4gICAgR3JvdXAucHJvdG90eXBlLmdldEFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX3R3ZWVucykubWFwKGZ1bmN0aW9uICh0d2VlbklkKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX3R3ZWVuc1t0d2VlbklkXTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBHcm91cC5wcm90b3R5cGUucmVtb3ZlQWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl90d2VlbnMgPSB7fTtcbiAgICB9O1xuICAgIEdyb3VwLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodHdlZW4pIHtcbiAgICAgICAgdGhpcy5fdHdlZW5zW3R3ZWVuLmdldElkKCldID0gdHdlZW47XG4gICAgICAgIHRoaXMuX3R3ZWVuc0FkZGVkRHVyaW5nVXBkYXRlW3R3ZWVuLmdldElkKCldID0gdHdlZW47XG4gICAgfTtcbiAgICBHcm91cC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKHR3ZWVuKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl90d2VlbnNbdHdlZW4uZ2V0SWQoKV07XG4gICAgICAgIGRlbGV0ZSB0aGlzLl90d2VlbnNBZGRlZER1cmluZ1VwZGF0ZVt0d2Vlbi5nZXRJZCgpXTtcbiAgICB9O1xuICAgIEdyb3VwLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAodGltZSwgcHJlc2VydmUpIHtcbiAgICAgICAgaWYgKHRpbWUgPT09IHZvaWQgMCkgeyB0aW1lID0gbm93JDEoKTsgfVxuICAgICAgICBpZiAocHJlc2VydmUgPT09IHZvaWQgMCkgeyBwcmVzZXJ2ZSA9IGZhbHNlOyB9XG4gICAgICAgIHZhciB0d2VlbklkcyA9IE9iamVjdC5rZXlzKHRoaXMuX3R3ZWVucyk7XG4gICAgICAgIGlmICh0d2Vlbklkcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUd2VlbnMgYXJlIHVwZGF0ZWQgaW4gXCJiYXRjaGVzXCIuIElmIHlvdSBhZGQgYSBuZXcgdHdlZW4gZHVyaW5nIGFuXG4gICAgICAgIC8vIHVwZGF0ZSwgdGhlbiB0aGUgbmV3IHR3ZWVuIHdpbGwgYmUgdXBkYXRlZCBpbiB0aGUgbmV4dCBiYXRjaC5cbiAgICAgICAgLy8gSWYgeW91IHJlbW92ZSBhIHR3ZWVuIGR1cmluZyBhbiB1cGRhdGUsIGl0IG1heSBvciBtYXkgbm90IGJlIHVwZGF0ZWQuXG4gICAgICAgIC8vIEhvd2V2ZXIsIGlmIHRoZSByZW1vdmVkIHR3ZWVuIHdhcyBhZGRlZCBkdXJpbmcgdGhlIGN1cnJlbnQgYmF0Y2gsXG4gICAgICAgIC8vIHRoZW4gaXQgd2lsbCBub3QgYmUgdXBkYXRlZC5cbiAgICAgICAgd2hpbGUgKHR3ZWVuSWRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3R3ZWVuc0FkZGVkRHVyaW5nVXBkYXRlID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR3ZWVuSWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHR3ZWVuID0gdGhpcy5fdHdlZW5zW3R3ZWVuSWRzW2ldXTtcbiAgICAgICAgICAgICAgICB2YXIgYXV0b1N0YXJ0ID0gIXByZXNlcnZlO1xuICAgICAgICAgICAgICAgIGlmICh0d2VlbiAmJiB0d2Vlbi51cGRhdGUodGltZSwgYXV0b1N0YXJ0KSA9PT0gZmFsc2UgJiYgIXByZXNlcnZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl90d2VlbnNbdHdlZW5JZHNbaV1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHR3ZWVuSWRzID0gT2JqZWN0LmtleXModGhpcy5fdHdlZW5zQWRkZWREdXJpbmdVcGRhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgcmV0dXJuIEdyb3VwO1xufSgpKTtcblxuLyoqXG4gKlxuICovXG52YXIgSW50ZXJwb2xhdGlvbiA9IHtcbiAgICBMaW5lYXI6IGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICAgIHZhciBtID0gdi5sZW5ndGggLSAxO1xuICAgICAgICB2YXIgZiA9IG0gKiBrO1xuICAgICAgICB2YXIgaSA9IE1hdGguZmxvb3IoZik7XG4gICAgICAgIHZhciBmbiA9IEludGVycG9sYXRpb24uVXRpbHMuTGluZWFyO1xuICAgICAgICBpZiAoayA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmbih2WzBdLCB2WzFdLCBmKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoayA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBmbih2W21dLCB2W20gLSAxXSwgbSAtIGYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbih2W2ldLCB2W2kgKyAxID4gbSA/IG0gOiBpICsgMV0sIGYgLSBpKTtcbiAgICB9LFxuICAgIEJlemllcjogZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgICAgdmFyIGIgPSAwO1xuICAgICAgICB2YXIgbiA9IHYubGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIHB3ID0gTWF0aC5wb3c7XG4gICAgICAgIHZhciBibiA9IEludGVycG9sYXRpb24uVXRpbHMuQmVybnN0ZWluO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBuOyBpKyspIHtcbiAgICAgICAgICAgIGIgKz0gcHcoMSAtIGssIG4gLSBpKSAqIHB3KGssIGkpICogdltpXSAqIGJuKG4sIGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiO1xuICAgIH0sXG4gICAgQ2F0bXVsbFJvbTogZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgICAgdmFyIG0gPSB2Lmxlbmd0aCAtIDE7XG4gICAgICAgIHZhciBmID0gbSAqIGs7XG4gICAgICAgIHZhciBpID0gTWF0aC5mbG9vcihmKTtcbiAgICAgICAgdmFyIGZuID0gSW50ZXJwb2xhdGlvbi5VdGlscy5DYXRtdWxsUm9tO1xuICAgICAgICBpZiAodlswXSA9PT0gdlttXSkge1xuICAgICAgICAgICAgaWYgKGsgPCAwKSB7XG4gICAgICAgICAgICAgICAgaSA9IE1hdGguZmxvb3IoKGYgPSBtICogKDEgKyBrKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZuKHZbKGkgLSAxICsgbSkgJSBtXSwgdltpXSwgdlsoaSArIDEpICUgbV0sIHZbKGkgKyAyKSAlIG1dLCBmIC0gaSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoayA8IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdlswXSAtIChmbih2WzBdLCB2WzBdLCB2WzFdLCB2WzFdLCAtZikgLSB2WzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrID4gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2W21dIC0gKGZuKHZbbV0sIHZbbV0sIHZbbSAtIDFdLCB2W20gLSAxXSwgZiAtIG0pIC0gdlttXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZm4odltpID8gaSAtIDEgOiAwXSwgdltpXSwgdlttIDwgaSArIDEgPyBtIDogaSArIDFdLCB2W20gPCBpICsgMiA/IG0gOiBpICsgMl0sIGYgLSBpKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgVXRpbHM6IHtcbiAgICAgICAgTGluZWFyOiBmdW5jdGlvbiAocDAsIHAxLCB0KSB7XG4gICAgICAgICAgICByZXR1cm4gKHAxIC0gcDApICogdCArIHAwO1xuICAgICAgICB9LFxuICAgICAgICBCZXJuc3RlaW46IGZ1bmN0aW9uIChuLCBpKSB7XG4gICAgICAgICAgICB2YXIgZmMgPSBJbnRlcnBvbGF0aW9uLlV0aWxzLkZhY3RvcmlhbDtcbiAgICAgICAgICAgIHJldHVybiBmYyhuKSAvIGZjKGkpIC8gZmMobiAtIGkpO1xuICAgICAgICB9LFxuICAgICAgICBGYWN0b3JpYWw6IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYSA9IFsxXTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAobikge1xuICAgICAgICAgICAgICAgIHZhciBzID0gMTtcbiAgICAgICAgICAgICAgICBpZiAoYVtuXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYVtuXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IG47IGkgPiAxOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgcyAqPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhW25dID0gcztcbiAgICAgICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKCksXG4gICAgICAgIENhdG11bGxSb206IGZ1bmN0aW9uIChwMCwgcDEsIHAyLCBwMywgdCkge1xuICAgICAgICAgICAgdmFyIHYwID0gKHAyIC0gcDApICogMC41O1xuICAgICAgICAgICAgdmFyIHYxID0gKHAzIC0gcDEpICogMC41O1xuICAgICAgICAgICAgdmFyIHQyID0gdCAqIHQ7XG4gICAgICAgICAgICB2YXIgdDMgPSB0ICogdDI7XG4gICAgICAgICAgICByZXR1cm4gKDIgKiBwMSAtIDIgKiBwMiArIHYwICsgdjEpICogdDMgKyAoLTMgKiBwMSArIDMgKiBwMiAtIDIgKiB2MCAtIHYxKSAqIHQyICsgdjAgKiB0ICsgcDE7XG4gICAgICAgIH0sXG4gICAgfSxcbn07XG5cbi8qKlxuICogVXRpbHNcbiAqL1xudmFyIFNlcXVlbmNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlcXVlbmNlKCkge1xuICAgIH1cbiAgICBTZXF1ZW5jZS5uZXh0SWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBTZXF1ZW5jZS5fbmV4dElkKys7XG4gICAgfTtcbiAgICBTZXF1ZW5jZS5fbmV4dElkID0gMDtcbiAgICByZXR1cm4gU2VxdWVuY2U7XG59KCkpO1xuXG52YXIgbWFpbkdyb3VwID0gbmV3IEdyb3VwKCk7XG5cbi8qKlxuICogVHdlZW4uanMgLSBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS90d2VlbmpzL3R3ZWVuLmpzXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90d2VlbmpzL3R3ZWVuLmpzL2dyYXBocy9jb250cmlidXRvcnMgZm9yIHRoZSBmdWxsIGxpc3Qgb2YgY29udHJpYnV0b3JzLlxuICogVGhhbmsgeW91IGFsbCwgeW91J3JlIGF3ZXNvbWUhXG4gKi9cbnZhciBUd2VlbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUd2Vlbihfb2JqZWN0LCBfZ3JvdXApIHtcbiAgICAgICAgaWYgKF9ncm91cCA9PT0gdm9pZCAwKSB7IF9ncm91cCA9IG1haW5Hcm91cDsgfVxuICAgICAgICB0aGlzLl9vYmplY3QgPSBfb2JqZWN0O1xuICAgICAgICB0aGlzLl9ncm91cCA9IF9ncm91cDtcbiAgICAgICAgdGhpcy5faXNQYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcGF1c2VTdGFydCA9IDA7XG4gICAgICAgIHRoaXMuX3ZhbHVlc1N0YXJ0ID0ge307XG4gICAgICAgIHRoaXMuX3ZhbHVlc0VuZCA9IHt9O1xuICAgICAgICB0aGlzLl92YWx1ZXNTdGFydFJlcGVhdCA9IHt9O1xuICAgICAgICB0aGlzLl9kdXJhdGlvbiA9IDEwMDA7XG4gICAgICAgIHRoaXMuX2luaXRpYWxSZXBlYXQgPSAwO1xuICAgICAgICB0aGlzLl9yZXBlYXQgPSAwO1xuICAgICAgICB0aGlzLl95b3lvID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzUGxheWluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9yZXZlcnNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9kZWxheVRpbWUgPSAwO1xuICAgICAgICB0aGlzLl9zdGFydFRpbWUgPSAwO1xuICAgICAgICB0aGlzLl9lYXNpbmdGdW5jdGlvbiA9IEVhc2luZy5MaW5lYXIuTm9uZTtcbiAgICAgICAgdGhpcy5faW50ZXJwb2xhdGlvbkZ1bmN0aW9uID0gSW50ZXJwb2xhdGlvbi5MaW5lYXI7XG4gICAgICAgIHRoaXMuX2NoYWluZWRUd2VlbnMgPSBbXTtcbiAgICAgICAgdGhpcy5fb25TdGFydENhbGxiYWNrRmlyZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faWQgPSBTZXF1ZW5jZS5uZXh0SWQoKTtcbiAgICAgICAgdGhpcy5faXNDaGFpblN0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZ29Ub0VuZCA9IGZhbHNlO1xuICAgIH1cbiAgICBUd2Vlbi5wcm90b3R5cGUuZ2V0SWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pZDtcbiAgICB9O1xuICAgIFR3ZWVuLnByb3RvdHlwZS5pc1BsYXlpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1BsYXlpbmc7XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1BhdXNlZDtcbiAgICB9O1xuICAgIFR3ZWVuLnByb3RvdHlwZS50byA9IGZ1bmN0aW9uIChwcm9wZXJ0aWVzLCBkdXJhdGlvbikge1xuICAgICAgICAvLyBUT0RPPyByZXN0b3JlIHRoaXMsIHRoZW4gdXBkYXRlIHRoZSAwN19keW5hbWljX3RvIGV4YW1wbGUgdG8gc2V0IGZveFxuICAgICAgICAvLyB0d2VlbidzIHRvIG9uIGVhY2ggdXBkYXRlLiBUaGF0IHdheSB0aGUgYmVoYXZpb3IgaXMgb3B0LWluICh0aGVyZSdzXG4gICAgICAgIC8vIGN1cnJlbnRseSBubyBvcHQtb3V0KS5cbiAgICAgICAgLy8gZm9yIChjb25zdCBwcm9wIGluIHByb3BlcnRpZXMpIHRoaXMuX3ZhbHVlc0VuZFtwcm9wXSA9IHByb3BlcnRpZXNbcHJvcF1cbiAgICAgICAgdGhpcy5fdmFsdWVzRW5kID0gT2JqZWN0LmNyZWF0ZShwcm9wZXJ0aWVzKTtcbiAgICAgICAgaWYgKGR1cmF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2R1cmF0aW9uID0gZHVyYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUuZHVyYXRpb24gPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICB0aGlzLl9kdXJhdGlvbiA9IGQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzUGxheWluZykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIHRoaXMuX2dyb3VwICYmIHRoaXMuX2dyb3VwLmFkZCh0aGlzKTtcbiAgICAgICAgdGhpcy5fcmVwZWF0ID0gdGhpcy5faW5pdGlhbFJlcGVhdDtcbiAgICAgICAgaWYgKHRoaXMuX3JldmVyc2VkKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSB3ZXJlIHJldmVyc2VkIChmLmUuIHVzaW5nIHRoZSB5b3lvIGZlYXR1cmUpIHRoZW4gd2UgbmVlZCB0b1xuICAgICAgICAgICAgLy8gZmxpcCB0aGUgdHdlZW4gZGlyZWN0aW9uIGJhY2sgdG8gZm9yd2FyZC5cbiAgICAgICAgICAgIHRoaXMuX3JldmVyc2VkID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiB0aGlzLl92YWx1ZXNTdGFydFJlcGVhdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N3YXBFbmRTdGFydFJlcGVhdFZhbHVlcyhwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzU3RhcnRbcHJvcGVydHldID0gdGhpcy5fdmFsdWVzU3RhcnRSZXBlYXRbcHJvcGVydHldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lzUGxheWluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuX2lzUGF1c2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX29uU3RhcnRDYWxsYmFja0ZpcmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzQ2hhaW5TdG9wcGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3N0YXJ0VGltZSA9IHRpbWUgIT09IHVuZGVmaW5lZCA/ICh0eXBlb2YgdGltZSA9PT0gJ3N0cmluZycgPyBub3ckMSgpICsgcGFyc2VGbG9hdCh0aW1lKSA6IHRpbWUpIDogbm93JDEoKTtcbiAgICAgICAgdGhpcy5fc3RhcnRUaW1lICs9IHRoaXMuX2RlbGF5VGltZTtcbiAgICAgICAgdGhpcy5fc2V0dXBQcm9wZXJ0aWVzKHRoaXMuX29iamVjdCwgdGhpcy5fdmFsdWVzU3RhcnQsIHRoaXMuX3ZhbHVlc0VuZCwgdGhpcy5fdmFsdWVzU3RhcnRSZXBlYXQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFR3ZWVuLnByb3RvdHlwZS5fc2V0dXBQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKF9vYmplY3QsIF92YWx1ZXNTdGFydCwgX3ZhbHVlc0VuZCwgX3ZhbHVlc1N0YXJ0UmVwZWF0KSB7XG4gICAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIF92YWx1ZXNFbmQpIHtcbiAgICAgICAgICAgIHZhciBzdGFydFZhbHVlID0gX29iamVjdFtwcm9wZXJ0eV07XG4gICAgICAgICAgICB2YXIgc3RhcnRWYWx1ZUlzQXJyYXkgPSBBcnJheS5pc0FycmF5KHN0YXJ0VmFsdWUpO1xuICAgICAgICAgICAgdmFyIHByb3BUeXBlID0gc3RhcnRWYWx1ZUlzQXJyYXkgPyAnYXJyYXknIDogdHlwZW9mIHN0YXJ0VmFsdWU7XG4gICAgICAgICAgICB2YXIgaXNJbnRlcnBvbGF0aW9uTGlzdCA9ICFzdGFydFZhbHVlSXNBcnJheSAmJiBBcnJheS5pc0FycmF5KF92YWx1ZXNFbmRbcHJvcGVydHldKTtcbiAgICAgICAgICAgIC8vIElmIGB0bygpYCBzcGVjaWZpZXMgYSBwcm9wZXJ0eSB0aGF0IGRvZXNuJ3QgZXhpc3QgaW4gdGhlIHNvdXJjZSBvYmplY3QsXG4gICAgICAgICAgICAvLyB3ZSBzaG91bGQgbm90IHNldCB0aGF0IHByb3BlcnR5IGluIHRoZSBvYmplY3RcbiAgICAgICAgICAgIGlmIChwcm9wVHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvcFR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGFuIEFycmF5IHdhcyBwcm92aWRlZCBhcyBwcm9wZXJ0eSB2YWx1ZVxuICAgICAgICAgICAgaWYgKGlzSW50ZXJwb2xhdGlvbkxpc3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgZW5kVmFsdWVzID0gX3ZhbHVlc0VuZFtwcm9wZXJ0eV07XG4gICAgICAgICAgICAgICAgaWYgKGVuZFZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBhbiBhcnJheSBvZiByZWxhdGl2ZSB2YWx1ZXNcbiAgICAgICAgICAgICAgICBlbmRWYWx1ZXMgPSBlbmRWYWx1ZXMubWFwKHRoaXMuX2hhbmRsZVJlbGF0aXZlVmFsdWUuYmluZCh0aGlzLCBzdGFydFZhbHVlKSk7XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgbG9jYWwgY29weSBvZiB0aGUgQXJyYXkgd2l0aCB0aGUgc3RhcnQgdmFsdWUgYXQgdGhlIGZyb250XG4gICAgICAgICAgICAgICAgX3ZhbHVlc0VuZFtwcm9wZXJ0eV0gPSBbc3RhcnRWYWx1ZV0uY29uY2F0KGVuZFZhbHVlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBoYW5kbGUgdGhlIGRlZXBuZXNzIG9mIHRoZSB2YWx1ZXNcbiAgICAgICAgICAgIGlmICgocHJvcFR5cGUgPT09ICdvYmplY3QnIHx8IHN0YXJ0VmFsdWVJc0FycmF5KSAmJiBzdGFydFZhbHVlICYmICFpc0ludGVycG9sYXRpb25MaXN0KSB7XG4gICAgICAgICAgICAgICAgX3ZhbHVlc1N0YXJ0W3Byb3BlcnR5XSA9IHN0YXJ0VmFsdWVJc0FycmF5ID8gW10gOiB7fTtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIHN0YXJ0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgRklYTUU/XG4gICAgICAgICAgICAgICAgICAgIF92YWx1ZXNTdGFydFtwcm9wZXJ0eV1bcHJvcF0gPSBzdGFydFZhbHVlW3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdmFsdWVzU3RhcnRSZXBlYXRbcHJvcGVydHldID0gc3RhcnRWYWx1ZUlzQXJyYXkgPyBbXSA6IHt9OyAvLyBUT0RPPyByZXBlYXQgbmVzdGVkIHZhbHVlcz8gQW5kIHlveW8/IEFuZCBhcnJheSB2YWx1ZXM/XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBGSVhNRT9cbiAgICAgICAgICAgICAgICB0aGlzLl9zZXR1cFByb3BlcnRpZXMoc3RhcnRWYWx1ZSwgX3ZhbHVlc1N0YXJ0W3Byb3BlcnR5XSwgX3ZhbHVlc0VuZFtwcm9wZXJ0eV0sIF92YWx1ZXNTdGFydFJlcGVhdFtwcm9wZXJ0eV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gU2F2ZSB0aGUgc3RhcnRpbmcgdmFsdWUsIGJ1dCBvbmx5IG9uY2UuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBfdmFsdWVzU3RhcnRbcHJvcGVydHldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBfdmFsdWVzU3RhcnRbcHJvcGVydHldID0gc3RhcnRWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFzdGFydFZhbHVlSXNBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBGSVhNRT9cbiAgICAgICAgICAgICAgICAgICAgX3ZhbHVlc1N0YXJ0W3Byb3BlcnR5XSAqPSAxLjA7IC8vIEVuc3VyZXMgd2UncmUgdXNpbmcgbnVtYmVycywgbm90IHN0cmluZ3NcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzSW50ZXJwb2xhdGlvbkxpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgRklYTUU/XG4gICAgICAgICAgICAgICAgICAgIF92YWx1ZXNTdGFydFJlcGVhdFtwcm9wZXJ0eV0gPSBfdmFsdWVzRW5kW3Byb3BlcnR5XS5zbGljZSgpLnJldmVyc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF92YWx1ZXNTdGFydFJlcGVhdFtwcm9wZXJ0eV0gPSBfdmFsdWVzU3RhcnRbcHJvcGVydHldIHx8IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pc0NoYWluU3RvcHBlZCkge1xuICAgICAgICAgICAgdGhpcy5faXNDaGFpblN0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zdG9wQ2hhaW5lZFR3ZWVucygpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5faXNQbGF5aW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgdGhpcy5fZ3JvdXAgJiYgdGhpcy5fZ3JvdXAucmVtb3ZlKHRoaXMpO1xuICAgICAgICB0aGlzLl9pc1BsYXlpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNQYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuX29uU3RvcENhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLl9vblN0b3BDYWxsYmFjayh0aGlzLl9vYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZ29Ub0VuZCA9IHRydWU7XG4gICAgICAgIHRoaXMudXBkYXRlKEluZmluaXR5KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAodGltZSkge1xuICAgICAgICBpZiAodGltZSA9PT0gdm9pZCAwKSB7IHRpbWUgPSBub3ckMSgpOyB9XG4gICAgICAgIGlmICh0aGlzLl9pc1BhdXNlZCB8fCAhdGhpcy5faXNQbGF5aW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3BhdXNlU3RhcnQgPSB0aW1lO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgdGhpcy5fZ3JvdXAgJiYgdGhpcy5fZ3JvdXAucmVtb3ZlKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFR3ZWVuLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAodGltZSkge1xuICAgICAgICBpZiAodGltZSA9PT0gdm9pZCAwKSB7IHRpbWUgPSBub3ckMSgpOyB9XG4gICAgICAgIGlmICghdGhpcy5faXNQYXVzZWQgfHwgIXRoaXMuX2lzUGxheWluZykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faXNQYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc3RhcnRUaW1lICs9IHRpbWUgLSB0aGlzLl9wYXVzZVN0YXJ0O1xuICAgICAgICB0aGlzLl9wYXVzZVN0YXJ0ID0gMDtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIHRoaXMuX2dyb3VwICYmIHRoaXMuX2dyb3VwLmFkZCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUuc3RvcENoYWluZWRUd2VlbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBudW1DaGFpbmVkVHdlZW5zID0gdGhpcy5fY2hhaW5lZFR3ZWVucy5sZW5ndGg7IGkgPCBudW1DaGFpbmVkVHdlZW5zOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuX2NoYWluZWRUd2VlbnNbaV0uc3RvcCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLmdyb3VwID0gZnVuY3Rpb24gKGdyb3VwKSB7XG4gICAgICAgIHRoaXMuX2dyb3VwID0gZ3JvdXA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLmRlbGF5ID0gZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICB0aGlzLl9kZWxheVRpbWUgPSBhbW91bnQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLnJlcGVhdCA9IGZ1bmN0aW9uICh0aW1lcykge1xuICAgICAgICB0aGlzLl9pbml0aWFsUmVwZWF0ID0gdGltZXM7XG4gICAgICAgIHRoaXMuX3JlcGVhdCA9IHRpbWVzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFR3ZWVuLnByb3RvdHlwZS5yZXBlYXREZWxheSA9IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgdGhpcy5fcmVwZWF0RGVsYXlUaW1lID0gYW1vdW50O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFR3ZWVuLnByb3RvdHlwZS55b3lvID0gZnVuY3Rpb24gKHlveW8pIHtcbiAgICAgICAgdGhpcy5feW95byA9IHlveW87XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLmVhc2luZyA9IGZ1bmN0aW9uIChlYXNpbmdGdW5jdGlvbikge1xuICAgICAgICB0aGlzLl9lYXNpbmdGdW5jdGlvbiA9IGVhc2luZ0Z1bmN0aW9uO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFR3ZWVuLnByb3RvdHlwZS5pbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24gKGludGVycG9sYXRpb25GdW5jdGlvbikge1xuICAgICAgICB0aGlzLl9pbnRlcnBvbGF0aW9uRnVuY3Rpb24gPSBpbnRlcnBvbGF0aW9uRnVuY3Rpb247XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLmNoYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHdlZW5zID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB0d2VlbnNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jaGFpbmVkVHdlZW5zID0gdHdlZW5zO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFR3ZWVuLnByb3RvdHlwZS5vblN0YXJ0ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX29uU3RhcnRDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFR3ZWVuLnByb3RvdHlwZS5vblVwZGF0ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9vblVwZGF0ZUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLm9uUmVwZWF0ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX29uUmVwZWF0Q2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUub25Db21wbGV0ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9vbkNvbXBsZXRlQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUub25TdG9wID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX29uU3RvcENhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgdHdlZW4gaXMgc3RpbGwgcGxheWluZyBhZnRlciB0aGUgdXBkYXRlLCBmYWxzZVxuICAgICAqIG90aGVyd2lzZSAoY2FsbGluZyB1cGRhdGUgb24gYSBwYXVzZWQgdHdlZW4gc3RpbGwgcmV0dXJucyB0cnVlIGJlY2F1c2VcbiAgICAgKiBpdCBpcyBzdGlsbCBwbGF5aW5nLCBqdXN0IHBhdXNlZCkuXG4gICAgICovXG4gICAgVHdlZW4ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICh0aW1lLCBhdXRvU3RhcnQpIHtcbiAgICAgICAgaWYgKHRpbWUgPT09IHZvaWQgMCkgeyB0aW1lID0gbm93JDEoKTsgfVxuICAgICAgICBpZiAoYXV0b1N0YXJ0ID09PSB2b2lkIDApIHsgYXV0b1N0YXJ0ID0gdHJ1ZTsgfVxuICAgICAgICBpZiAodGhpcy5faXNQYXVzZWQpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgdmFyIHByb3BlcnR5O1xuICAgICAgICB2YXIgZWxhcHNlZDtcbiAgICAgICAgdmFyIGVuZFRpbWUgPSB0aGlzLl9zdGFydFRpbWUgKyB0aGlzLl9kdXJhdGlvbjtcbiAgICAgICAgaWYgKCF0aGlzLl9nb1RvRW5kICYmICF0aGlzLl9pc1BsYXlpbmcpIHtcbiAgICAgICAgICAgIGlmICh0aW1lID4gZW5kVGltZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoYXV0b1N0YXJ0KVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnQodGltZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZ29Ub0VuZCA9IGZhbHNlO1xuICAgICAgICBpZiAodGltZSA8IHRoaXMuX3N0YXJ0VGltZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX29uU3RhcnRDYWxsYmFja0ZpcmVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX29uU3RhcnRDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHRoaXMuX29uU3RhcnRDYWxsYmFjayh0aGlzLl9vYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fb25TdGFydENhbGxiYWNrRmlyZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsYXBzZWQgPSAodGltZSAtIHRoaXMuX3N0YXJ0VGltZSkgLyB0aGlzLl9kdXJhdGlvbjtcbiAgICAgICAgZWxhcHNlZCA9IHRoaXMuX2R1cmF0aW9uID09PSAwIHx8IGVsYXBzZWQgPiAxID8gMSA6IGVsYXBzZWQ7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX2Vhc2luZ0Z1bmN0aW9uKGVsYXBzZWQpO1xuICAgICAgICAvLyBwcm9wZXJ0aWVzIHRyYW5zZm9ybWF0aW9uc1xuICAgICAgICB0aGlzLl91cGRhdGVQcm9wZXJ0aWVzKHRoaXMuX29iamVjdCwgdGhpcy5fdmFsdWVzU3RhcnQsIHRoaXMuX3ZhbHVlc0VuZCwgdmFsdWUpO1xuICAgICAgICBpZiAodGhpcy5fb25VcGRhdGVDYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5fb25VcGRhdGVDYWxsYmFjayh0aGlzLl9vYmplY3QsIGVsYXBzZWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbGFwc2VkID09PSAxKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcmVwZWF0ID4gMCkge1xuICAgICAgICAgICAgICAgIGlmIChpc0Zpbml0ZSh0aGlzLl9yZXBlYXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlcGVhdC0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBSZWFzc2lnbiBzdGFydGluZyB2YWx1ZXMsIHJlc3RhcnQgYnkgbWFraW5nIHN0YXJ0VGltZSA9IG5vd1xuICAgICAgICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gdGhpcy5fdmFsdWVzU3RhcnRSZXBlYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl95b3lvICYmIHR5cGVvZiB0aGlzLl92YWx1ZXNFbmRbcHJvcGVydHldID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzU3RhcnRSZXBlYXRbcHJvcGVydHldID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIEZJWE1FP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlc1N0YXJ0UmVwZWF0W3Byb3BlcnR5XSArIHBhcnNlRmxvYXQodGhpcy5fdmFsdWVzRW5kW3Byb3BlcnR5XSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3lveW8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N3YXBFbmRTdGFydFJlcGVhdFZhbHVlcyhwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzU3RhcnRbcHJvcGVydHldID0gdGhpcy5fdmFsdWVzU3RhcnRSZXBlYXRbcHJvcGVydHldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5feW95bykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXZlcnNlZCA9ICF0aGlzLl9yZXZlcnNlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3JlcGVhdERlbGF5VGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0VGltZSA9IHRpbWUgKyB0aGlzLl9yZXBlYXREZWxheVRpbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydFRpbWUgPSB0aW1lICsgdGhpcy5fZGVsYXlUaW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fb25SZXBlYXRDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vblJlcGVhdENhbGxiYWNrKHRoaXMuX29iamVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX29uQ29tcGxldGVDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vbkNvbXBsZXRlQ2FsbGJhY2sodGhpcy5fb2JqZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG51bUNoYWluZWRUd2VlbnMgPSB0aGlzLl9jaGFpbmVkVHdlZW5zLmxlbmd0aDsgaSA8IG51bUNoYWluZWRUd2VlbnM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHRoZSBjaGFpbmVkIHR3ZWVucyBzdGFydCBleGFjdGx5IGF0IHRoZSB0aW1lIHRoZXkgc2hvdWxkLFxuICAgICAgICAgICAgICAgICAgICAvLyBldmVuIGlmIHRoZSBgdXBkYXRlKClgIG1ldGhvZCB3YXMgY2FsbGVkIHdheSBwYXN0IHRoZSBkdXJhdGlvbiBvZiB0aGUgdHdlZW5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhaW5lZFR3ZWVuc1tpXS5zdGFydCh0aGlzLl9zdGFydFRpbWUgKyB0aGlzLl9kdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2lzUGxheWluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIFR3ZWVuLnByb3RvdHlwZS5fdXBkYXRlUHJvcGVydGllcyA9IGZ1bmN0aW9uIChfb2JqZWN0LCBfdmFsdWVzU3RhcnQsIF92YWx1ZXNFbmQsIHZhbHVlKSB7XG4gICAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIF92YWx1ZXNFbmQpIHtcbiAgICAgICAgICAgIC8vIERvbid0IHVwZGF0ZSBwcm9wZXJ0aWVzIHRoYXQgZG8gbm90IGV4aXN0IGluIHRoZSBzb3VyY2Ugb2JqZWN0XG4gICAgICAgICAgICBpZiAoX3ZhbHVlc1N0YXJ0W3Byb3BlcnR5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBfdmFsdWVzU3RhcnRbcHJvcGVydHldIHx8IDA7XG4gICAgICAgICAgICB2YXIgZW5kID0gX3ZhbHVlc0VuZFtwcm9wZXJ0eV07XG4gICAgICAgICAgICB2YXIgc3RhcnRJc0FycmF5ID0gQXJyYXkuaXNBcnJheShfb2JqZWN0W3Byb3BlcnR5XSk7XG4gICAgICAgICAgICB2YXIgZW5kSXNBcnJheSA9IEFycmF5LmlzQXJyYXkoZW5kKTtcbiAgICAgICAgICAgIHZhciBpc0ludGVycG9sYXRpb25MaXN0ID0gIXN0YXJ0SXNBcnJheSAmJiBlbmRJc0FycmF5O1xuICAgICAgICAgICAgaWYgKGlzSW50ZXJwb2xhdGlvbkxpc3QpIHtcbiAgICAgICAgICAgICAgICBfb2JqZWN0W3Byb3BlcnR5XSA9IHRoaXMuX2ludGVycG9sYXRpb25GdW5jdGlvbihlbmQsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdvYmplY3QnICYmIGVuZCkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgRklYTUU/XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlUHJvcGVydGllcyhfb2JqZWN0W3Byb3BlcnR5XSwgc3RhcnQsIGVuZCwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gUGFyc2VzIHJlbGF0aXZlIGVuZCB2YWx1ZXMgd2l0aCBzdGFydCBhcyBiYXNlIChlLmcuOiArMTAsIC0zKVxuICAgICAgICAgICAgICAgIGVuZCA9IHRoaXMuX2hhbmRsZVJlbGF0aXZlVmFsdWUoc3RhcnQsIGVuZCk7XG4gICAgICAgICAgICAgICAgLy8gUHJvdGVjdCBhZ2FpbnN0IG5vbiBudW1lcmljIHByb3BlcnRpZXMuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlbmQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIEZJWE1FP1xuICAgICAgICAgICAgICAgICAgICBfb2JqZWN0W3Byb3BlcnR5XSA9IHN0YXJ0ICsgKGVuZCAtIHN0YXJ0KSAqIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLl9oYW5kbGVSZWxhdGl2ZVZhbHVlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbmQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gZW5kO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmQuY2hhckF0KDApID09PSAnKycgfHwgZW5kLmNoYXJBdCgwKSA9PT0gJy0nKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhcnQgKyBwYXJzZUZsb2F0KGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChlbmQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUuX3N3YXBFbmRTdGFydFJlcGVhdFZhbHVlcyA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICB2YXIgdG1wID0gdGhpcy5fdmFsdWVzU3RhcnRSZXBlYXRbcHJvcGVydHldO1xuICAgICAgICB2YXIgZW5kVmFsdWUgPSB0aGlzLl92YWx1ZXNFbmRbcHJvcGVydHldO1xuICAgICAgICBpZiAodHlwZW9mIGVuZFZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy5fdmFsdWVzU3RhcnRSZXBlYXRbcHJvcGVydHldID0gdGhpcy5fdmFsdWVzU3RhcnRSZXBlYXRbcHJvcGVydHldICsgcGFyc2VGbG9hdChlbmRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZXNTdGFydFJlcGVhdFtwcm9wZXJ0eV0gPSB0aGlzLl92YWx1ZXNFbmRbcHJvcGVydHldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ZhbHVlc0VuZFtwcm9wZXJ0eV0gPSB0bXA7XG4gICAgfTtcbiAgICByZXR1cm4gVHdlZW47XG59KCkpO1xuXG52YXIgVkVSU0lPTiA9ICcxOC42LjQnO1xuXG4vKipcbiAqIFR3ZWVuLmpzIC0gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vdHdlZW5qcy90d2Vlbi5qc1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdHdlZW5qcy90d2Vlbi5qcy9ncmFwaHMvY29udHJpYnV0b3JzIGZvciB0aGUgZnVsbCBsaXN0IG9mIGNvbnRyaWJ1dG9ycy5cbiAqIFRoYW5rIHlvdSBhbGwsIHlvdSdyZSBhd2Vzb21lIVxuICovXG52YXIgbmV4dElkID0gU2VxdWVuY2UubmV4dElkO1xuLyoqXG4gKiBDb250cm9sbGluZyBncm91cHMgb2YgdHdlZW5zXG4gKlxuICogVXNpbmcgdGhlIFRXRUVOIHNpbmdsZXRvbiB0byBtYW5hZ2UgeW91ciB0d2VlbnMgY2FuIGNhdXNlIGlzc3VlcyBpbiBsYXJnZSBhcHBzIHdpdGggbWFueSBjb21wb25lbnRzLlxuICogSW4gdGhlc2UgY2FzZXMsIHlvdSBtYXkgd2FudCB0byBjcmVhdGUgeW91ciBvd24gc21hbGxlciBncm91cHMgb2YgdHdlZW5zLlxuICovXG52YXIgVFdFRU4gPSBtYWluR3JvdXA7XG4vLyBUaGlzIGlzIHRoZSBiZXN0IHdheSB0byBleHBvcnQgdGhpbmdzIGluIGEgd2F5IHRoYXQncyBjb21wYXRpYmxlIHdpdGggYm90aCBFU1xuLy8gTW9kdWxlcyBhbmQgQ29tbW9uSlMsIHdpdGhvdXQgYnVpbGQgaGFja3MsIGFuZCBzbyBhcyBub3QgdG8gYnJlYWsgdGhlXG4vLyBleGlzdGluZyBBUEkuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vcm9sbHVwL3JvbGx1cC9pc3N1ZXMvMTk2MSNpc3N1ZWNvbW1lbnQtNDIzMDM3ODgxXG52YXIgZ2V0QWxsID0gVFdFRU4uZ2V0QWxsLmJpbmQoVFdFRU4pO1xudmFyIHJlbW92ZUFsbCA9IFRXRUVOLnJlbW92ZUFsbC5iaW5kKFRXRUVOKTtcbnZhciBhZGQgPSBUV0VFTi5hZGQuYmluZChUV0VFTik7XG52YXIgcmVtb3ZlID0gVFdFRU4ucmVtb3ZlLmJpbmQoVFdFRU4pO1xudmFyIHVwZGF0ZSA9IFRXRUVOLnVwZGF0ZS5iaW5kKFRXRUVOKTtcbnZhciBleHBvcnRzID0ge1xuICAgIEVhc2luZzogRWFzaW5nLFxuICAgIEdyb3VwOiBHcm91cCxcbiAgICBJbnRlcnBvbGF0aW9uOiBJbnRlcnBvbGF0aW9uLFxuICAgIG5vdzogbm93JDEsXG4gICAgU2VxdWVuY2U6IFNlcXVlbmNlLFxuICAgIG5leHRJZDogbmV4dElkLFxuICAgIFR3ZWVuOiBUd2VlbixcbiAgICBWRVJTSU9OOiBWRVJTSU9OLFxuICAgIGdldEFsbDogZ2V0QWxsLFxuICAgIHJlbW92ZUFsbDogcmVtb3ZlQWxsLFxuICAgIGFkZDogYWRkLFxuICAgIHJlbW92ZTogcmVtb3ZlLFxuICAgIHVwZGF0ZTogdXBkYXRlLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgZXhwb3J0cztcbmV4cG9ydCB7IEVhc2luZywgR3JvdXAsIEludGVycG9sYXRpb24sIFNlcXVlbmNlLCBUd2VlbiwgVkVSU0lPTiwgYWRkLCBnZXRBbGwsIG5leHRJZCwgbm93JDEgYXMgbm93LCByZW1vdmUsIHJlbW92ZUFsbCwgdXBkYXRlIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/@tweenjs/tween.js/dist/tween.esm.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/colyseus.js/dist/colyseus.js":
/*!***************************************************!*\
  !*** ./node_modules/colyseus.js/dist/colyseus.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("// colyseus.js@0.15.11 (@colyseus/schema 2.0.9)\n(function (global, factory) {\n     true ? factory(exports) :\n    0;\n})(this, (function (exports) { 'use strict';\n\n    function _mergeNamespaces(n, m) {\n        m.forEach(function (e) {\n            e && typeof e !== 'string' && !Array.isArray(e) && Object.keys(e).forEach(function (k) {\n                if (k !== 'default' && !(k in n)) {\n                    var d = Object.getOwnPropertyDescriptor(e, k);\n                    Object.defineProperty(n, k, d.get ? d : {\n                        enumerable: true,\n                        get: function () { return e[k]; }\n                    });\n                }\n            });\n        });\n        return Object.freeze(n);\n    }\n\n    //\n    // Polyfills for legacy environments\n    //\n    /*\n     * Support Android 4.4.x\n     */\n    if (!ArrayBuffer.isView) {\n        ArrayBuffer.isView = function (a) {\n            return a !== null && typeof (a) === 'object' && a.buffer instanceof ArrayBuffer;\n        };\n    }\n    // Define globalThis if not available.\n    // https://github.com/colyseus/colyseus.js/issues/86\n    if (typeof (globalThis) === \"undefined\" &&\n        typeof (window) !== \"undefined\") {\n        // @ts-ignore\n        window['globalThis'] = window;\n    }\n\n    /******************************************************************************\r\n    Copyright (c) Microsoft Corporation.\r\n\r\n    Permission to use, copy, modify, and/or distribute this software for any\r\n    purpose with or without fee is hereby granted.\r\n\r\n    THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\n    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\n    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\n    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\n    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\n    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\n    PERFORMANCE OF THIS SOFTWARE.\r\n    ***************************************************************************** */\r\n    /* global Reflect, Promise */\r\n\r\n    var extendStatics = function(d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n\r\n    function __extends(d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    }\r\n\r\n    function __awaiter(thisArg, _arguments, P, generator) {\r\n        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n        return new (P || (P = Promise))(function (resolve, reject) {\r\n            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n            function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n            step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n        });\r\n    }\r\n\r\n    function __generator(thisArg, body) {\r\n        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n        return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n        function verb(n) { return function (v) { return step([n, v]); }; }\r\n        function step(op) {\r\n            if (f) throw new TypeError(\"Generator is already executing.\");\r\n            while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n                if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n                if (y = 0, t) op = [op[0] & 2, t.value];\r\n                switch (op[0]) {\r\n                    case 0: case 1: t = op; break;\r\n                    case 4: _.label++; return { value: op[1], done: false };\r\n                    case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                    case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                    default:\r\n                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                        if (t[2]) _.ops.pop();\r\n                        _.trys.pop(); continue;\r\n                }\r\n                op = body.call(thisArg, _);\r\n            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n        }\r\n    }\n\n    function apply(src, tar) {\n    \ttar.statusMessage = src.statusText;\n    \ttar.statusCode = src.status;\n    \ttar.data = src.body;\n    }\n\n    function send(method, uri, opts) {\n    \topts = opts || {};\n    \tvar timer, ctrl, tmp=opts.body;\n\n    \topts.method = method;\n    \topts.headers = opts.headers || {};\n\n    \tif (tmp instanceof FormData) ; else if (tmp && typeof tmp == 'object') {\n    \t\topts.headers['content-type'] = 'application/json';\n    \t\topts.body = JSON.stringify(tmp);\n    \t}\n\n    \tif (opts.withCredentials) {\n    \t\topts.credentials = 'include';\n    \t}\n\n    \tif (opts.timeout) {\n    \t\tctrl = new AbortController;\n    \t\topts.signal = ctrl.signal;\n    \t\ttimer = setTimeout(ctrl.abort, opts.timeout);\n    \t}\n\n    \treturn new Promise((res, rej) => {\n    \t\tfetch(uri, opts).then((rr, reply) => {\n    \t\t\tclearTimeout(timer);\n\n    \t\t\tapply(rr, rr); //=> rr.headers\n    \t\t\treply = rr.status >= 400 ? rej : res;\n\n    \t\t\ttmp = rr.headers.get('content-type');\n    \t\t\tif (!tmp || !~tmp.indexOf('application/json')) {\n    \t\t\t\treply(rr);\n    \t\t\t} else {\n    \t\t\t\trr.text().then(str => {\n    \t\t\t\t\ttry {\n    \t\t\t\t\t\trr.data = JSON.parse(str, opts.reviver);\n    \t\t\t\t\t\treply(rr);\n    \t\t\t\t\t} catch (err) {\n    \t\t\t\t\t\terr.headers = rr.headers;\n    \t\t\t\t\t\tapply(rr, err);\n    \t\t\t\t\t\trej(err);\n    \t\t\t\t\t}\n    \t\t\t\t});\n    \t\t\t}\n    \t\t}).catch(err => {\n    \t\t\terr.timeout = ctrl && ctrl.signal.aborted;\n    \t\t\trej(err);\n    \t\t});\n    \t});\n    }\n\n    var get = /*#__PURE__*/ send.bind(send, 'GET');\n    var post = /*#__PURE__*/ send.bind(send, 'POST');\n    var patch = /*#__PURE__*/ send.bind(send, 'PATCH');\n    var del = /*#__PURE__*/ send.bind(send, 'DELETE');\n    var put = /*#__PURE__*/ send.bind(send, 'PUT');\n\n    var del_1 = del;\n    var get_1 = get;\n    var patch_1 = patch;\n    var post_1 = post;\n    var put_1 = put;\n    var send_1 = send;\n\n    var fetch_1 = {\n    \tdel: del_1,\n    \tget: get_1,\n    \tpatch: patch_1,\n    \tpost: post_1,\n    \tput: put_1,\n    \tsend: send_1\n    };\n\n    var http = /*#__PURE__*/_mergeNamespaces({\n        __proto__: null,\n        'default': fetch_1,\n        del: del_1,\n        get: get_1,\n        patch: patch_1,\n        post: post_1,\n        put: put_1,\n        send: send_1\n    }, [fetch_1]);\n\n    var CloseCode;\n    (function (CloseCode) {\n        CloseCode[CloseCode[\"CONSENTED\"] = 4000] = \"CONSENTED\";\n        CloseCode[CloseCode[\"DEVMODE_RESTART\"] = 4010] = \"DEVMODE_RESTART\";\n    })(CloseCode || (CloseCode = {}));\n    var ServerError = /** @class */ (function (_super) {\n        __extends(ServerError, _super);\n        function ServerError(code, message) {\n            var _this = _super.call(this, message) || this;\n            _this.name = \"ServerError\";\n            _this.code = code;\n            return _this;\n        }\n        return ServerError;\n    }(Error));\n\n    /**\n     * Copyright (c) 2014 Ion Drive Software Ltd.\n     * https://github.com/darrachequesne/notepack/\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    /**\n     * Patch for Colyseus:\n     * -------------------\n     * notepack.io@3.0.1\n     *\n     * added `offset` on Decoder constructor, for messages arriving with a code\n     * before actual msgpack data\n     */\n    //\n    // DECODER\n    //\n    function Decoder(buffer, offset) {\n        this._offset = offset;\n        if (buffer instanceof ArrayBuffer) {\n            this._buffer = buffer;\n            this._view = new DataView(this._buffer);\n        }\n        else if (ArrayBuffer.isView(buffer)) {\n            this._buffer = buffer.buffer;\n            this._view = new DataView(this._buffer, buffer.byteOffset, buffer.byteLength);\n        }\n        else {\n            throw new Error('Invalid argument');\n        }\n    }\n    function utf8Read$1(view, offset, length) {\n        var string = '', chr = 0;\n        for (var i = offset, end = offset + length; i < end; i++) {\n            var byte = view.getUint8(i);\n            if ((byte & 0x80) === 0x00) {\n                string += String.fromCharCode(byte);\n                continue;\n            }\n            if ((byte & 0xe0) === 0xc0) {\n                string += String.fromCharCode(((byte & 0x1f) << 6) |\n                    (view.getUint8(++i) & 0x3f));\n                continue;\n            }\n            if ((byte & 0xf0) === 0xe0) {\n                string += String.fromCharCode(((byte & 0x0f) << 12) |\n                    ((view.getUint8(++i) & 0x3f) << 6) |\n                    ((view.getUint8(++i) & 0x3f) << 0));\n                continue;\n            }\n            if ((byte & 0xf8) === 0xf0) {\n                chr = ((byte & 0x07) << 18) |\n                    ((view.getUint8(++i) & 0x3f) << 12) |\n                    ((view.getUint8(++i) & 0x3f) << 6) |\n                    ((view.getUint8(++i) & 0x3f) << 0);\n                if (chr >= 0x010000) { // surrogate pair\n                    chr -= 0x010000;\n                    string += String.fromCharCode((chr >>> 10) + 0xD800, (chr & 0x3FF) + 0xDC00);\n                }\n                else {\n                    string += String.fromCharCode(chr);\n                }\n                continue;\n            }\n            throw new Error('Invalid byte ' + byte.toString(16));\n        }\n        return string;\n    }\n    Decoder.prototype._array = function (length) {\n        var value = new Array(length);\n        for (var i = 0; i < length; i++) {\n            value[i] = this._parse();\n        }\n        return value;\n    };\n    Decoder.prototype._map = function (length) {\n        var key = '', value = {};\n        for (var i = 0; i < length; i++) {\n            key = this._parse();\n            value[key] = this._parse();\n        }\n        return value;\n    };\n    Decoder.prototype._str = function (length) {\n        var value = utf8Read$1(this._view, this._offset, length);\n        this._offset += length;\n        return value;\n    };\n    Decoder.prototype._bin = function (length) {\n        var value = this._buffer.slice(this._offset, this._offset + length);\n        this._offset += length;\n        return value;\n    };\n    Decoder.prototype._parse = function () {\n        var prefix = this._view.getUint8(this._offset++);\n        var value, length = 0, type = 0, hi = 0, lo = 0;\n        if (prefix < 0xc0) {\n            // positive fixint\n            if (prefix < 0x80) {\n                return prefix;\n            }\n            // fixmap\n            if (prefix < 0x90) {\n                return this._map(prefix & 0x0f);\n            }\n            // fixarray\n            if (prefix < 0xa0) {\n                return this._array(prefix & 0x0f);\n            }\n            // fixstr\n            return this._str(prefix & 0x1f);\n        }\n        // negative fixint\n        if (prefix > 0xdf) {\n            return (0xff - prefix + 1) * -1;\n        }\n        switch (prefix) {\n            // nil\n            case 0xc0:\n                return null;\n            // false\n            case 0xc2:\n                return false;\n            // true\n            case 0xc3:\n                return true;\n            // bin\n            case 0xc4:\n                length = this._view.getUint8(this._offset);\n                this._offset += 1;\n                return this._bin(length);\n            case 0xc5:\n                length = this._view.getUint16(this._offset);\n                this._offset += 2;\n                return this._bin(length);\n            case 0xc6:\n                length = this._view.getUint32(this._offset);\n                this._offset += 4;\n                return this._bin(length);\n            // ext\n            case 0xc7:\n                length = this._view.getUint8(this._offset);\n                type = this._view.getInt8(this._offset + 1);\n                this._offset += 2;\n                if (type === -1) {\n                    // timestamp 96\n                    var ns = this._view.getUint32(this._offset);\n                    hi = this._view.getInt32(this._offset + 4);\n                    lo = this._view.getUint32(this._offset + 8);\n                    this._offset += 12;\n                    return new Date((hi * 0x100000000 + lo) * 1e3 + ns / 1e6);\n                }\n                return [type, this._bin(length)];\n            case 0xc8:\n                length = this._view.getUint16(this._offset);\n                type = this._view.getInt8(this._offset + 2);\n                this._offset += 3;\n                return [type, this._bin(length)];\n            case 0xc9:\n                length = this._view.getUint32(this._offset);\n                type = this._view.getInt8(this._offset + 4);\n                this._offset += 5;\n                return [type, this._bin(length)];\n            // float\n            case 0xca:\n                value = this._view.getFloat32(this._offset);\n                this._offset += 4;\n                return value;\n            case 0xcb:\n                value = this._view.getFloat64(this._offset);\n                this._offset += 8;\n                return value;\n            // uint\n            case 0xcc:\n                value = this._view.getUint8(this._offset);\n                this._offset += 1;\n                return value;\n            case 0xcd:\n                value = this._view.getUint16(this._offset);\n                this._offset += 2;\n                return value;\n            case 0xce:\n                value = this._view.getUint32(this._offset);\n                this._offset += 4;\n                return value;\n            case 0xcf:\n                hi = this._view.getUint32(this._offset) * Math.pow(2, 32);\n                lo = this._view.getUint32(this._offset + 4);\n                this._offset += 8;\n                return hi + lo;\n            // int\n            case 0xd0:\n                value = this._view.getInt8(this._offset);\n                this._offset += 1;\n                return value;\n            case 0xd1:\n                value = this._view.getInt16(this._offset);\n                this._offset += 2;\n                return value;\n            case 0xd2:\n                value = this._view.getInt32(this._offset);\n                this._offset += 4;\n                return value;\n            case 0xd3:\n                hi = this._view.getInt32(this._offset) * Math.pow(2, 32);\n                lo = this._view.getUint32(this._offset + 4);\n                this._offset += 8;\n                return hi + lo;\n            // fixext\n            case 0xd4:\n                type = this._view.getInt8(this._offset);\n                this._offset += 1;\n                if (type === 0x00) {\n                    // custom encoding for 'undefined' (kept for backward-compatibility)\n                    this._offset += 1;\n                    return void 0;\n                }\n                return [type, this._bin(1)];\n            case 0xd5:\n                type = this._view.getInt8(this._offset);\n                this._offset += 1;\n                return [type, this._bin(2)];\n            case 0xd6:\n                type = this._view.getInt8(this._offset);\n                this._offset += 1;\n                if (type === -1) {\n                    // timestamp 32\n                    value = this._view.getUint32(this._offset);\n                    this._offset += 4;\n                    return new Date(value * 1e3);\n                }\n                return [type, this._bin(4)];\n            case 0xd7:\n                type = this._view.getInt8(this._offset);\n                this._offset += 1;\n                if (type === 0x00) {\n                    // custom date encoding (kept for backward-compatibility)\n                    hi = this._view.getInt32(this._offset) * Math.pow(2, 32);\n                    lo = this._view.getUint32(this._offset + 4);\n                    this._offset += 8;\n                    return new Date(hi + lo);\n                }\n                if (type === -1) {\n                    // timestamp 64\n                    hi = this._view.getUint32(this._offset);\n                    lo = this._view.getUint32(this._offset + 4);\n                    this._offset += 8;\n                    var s = (hi & 0x3) * 0x100000000 + lo;\n                    return new Date(s * 1e3 + (hi >>> 2) / 1e6);\n                }\n                return [type, this._bin(8)];\n            case 0xd8:\n                type = this._view.getInt8(this._offset);\n                this._offset += 1;\n                return [type, this._bin(16)];\n            // str\n            case 0xd9:\n                length = this._view.getUint8(this._offset);\n                this._offset += 1;\n                return this._str(length);\n            case 0xda:\n                length = this._view.getUint16(this._offset);\n                this._offset += 2;\n                return this._str(length);\n            case 0xdb:\n                length = this._view.getUint32(this._offset);\n                this._offset += 4;\n                return this._str(length);\n            // array\n            case 0xdc:\n                length = this._view.getUint16(this._offset);\n                this._offset += 2;\n                return this._array(length);\n            case 0xdd:\n                length = this._view.getUint32(this._offset);\n                this._offset += 4;\n                return this._array(length);\n            // map\n            case 0xde:\n                length = this._view.getUint16(this._offset);\n                this._offset += 2;\n                return this._map(length);\n            case 0xdf:\n                length = this._view.getUint32(this._offset);\n                this._offset += 4;\n                return this._map(length);\n        }\n        throw new Error('Could not parse');\n    };\n    function decode(buffer, offset) {\n        if (offset === void 0) { offset = 0; }\n        var decoder = new Decoder(buffer, offset);\n        var value = decoder._parse();\n        if (decoder._offset !== buffer.byteLength) {\n            throw new Error((buffer.byteLength - decoder._offset) + ' trailing bytes');\n        }\n        return value;\n    }\n    //\n    // ENCODER\n    //\n    var TIMESTAMP32_MAX_SEC = 0x100000000 - 1; // 32-bit unsigned int\n    var TIMESTAMP64_MAX_SEC = 0x400000000 - 1; // 34-bit unsigned int\n    function utf8Write(view, offset, str) {\n        var c = 0;\n        for (var i = 0, l = str.length; i < l; i++) {\n            c = str.charCodeAt(i);\n            if (c < 0x80) {\n                view.setUint8(offset++, c);\n            }\n            else if (c < 0x800) {\n                view.setUint8(offset++, 0xc0 | (c >> 6));\n                view.setUint8(offset++, 0x80 | (c & 0x3f));\n            }\n            else if (c < 0xd800 || c >= 0xe000) {\n                view.setUint8(offset++, 0xe0 | (c >> 12));\n                view.setUint8(offset++, 0x80 | (c >> 6) & 0x3f);\n                view.setUint8(offset++, 0x80 | (c & 0x3f));\n            }\n            else {\n                i++;\n                c = 0x10000 + (((c & 0x3ff) << 10) | (str.charCodeAt(i) & 0x3ff));\n                view.setUint8(offset++, 0xf0 | (c >> 18));\n                view.setUint8(offset++, 0x80 | (c >> 12) & 0x3f);\n                view.setUint8(offset++, 0x80 | (c >> 6) & 0x3f);\n                view.setUint8(offset++, 0x80 | (c & 0x3f));\n            }\n        }\n    }\n    function utf8Length$1(str) {\n        var c = 0, length = 0;\n        for (var i = 0, l = str.length; i < l; i++) {\n            c = str.charCodeAt(i);\n            if (c < 0x80) {\n                length += 1;\n            }\n            else if (c < 0x800) {\n                length += 2;\n            }\n            else if (c < 0xd800 || c >= 0xe000) {\n                length += 3;\n            }\n            else {\n                i++;\n                length += 4;\n            }\n        }\n        return length;\n    }\n    function _encode(bytes, defers, value) {\n        var type = typeof value, i = 0, l = 0, hi = 0, lo = 0, length = 0, size = 0;\n        if (type === 'string') {\n            length = utf8Length$1(value);\n            // fixstr\n            if (length < 0x20) {\n                bytes.push(length | 0xa0);\n                size = 1;\n            }\n            // str 8\n            else if (length < 0x100) {\n                bytes.push(0xd9, length);\n                size = 2;\n            }\n            // str 16\n            else if (length < 0x10000) {\n                bytes.push(0xda, length >> 8, length);\n                size = 3;\n            }\n            // str 32\n            else if (length < 0x100000000) {\n                bytes.push(0xdb, length >> 24, length >> 16, length >> 8, length);\n                size = 5;\n            }\n            else {\n                throw new Error('String too long');\n            }\n            defers.push({ _str: value, _length: length, _offset: bytes.length });\n            return size + length;\n        }\n        if (type === 'number') {\n            // TODO: encode to float 32?\n            // float 64\n            if (Math.floor(value) !== value || !isFinite(value)) {\n                bytes.push(0xcb);\n                defers.push({ _float: value, _length: 8, _offset: bytes.length });\n                return 9;\n            }\n            if (value >= 0) {\n                // positive fixnum\n                if (value < 0x80) {\n                    bytes.push(value);\n                    return 1;\n                }\n                // uint 8\n                if (value < 0x100) {\n                    bytes.push(0xcc, value);\n                    return 2;\n                }\n                // uint 16\n                if (value < 0x10000) {\n                    bytes.push(0xcd, value >> 8, value);\n                    return 3;\n                }\n                // uint 32\n                if (value < 0x100000000) {\n                    bytes.push(0xce, value >> 24, value >> 16, value >> 8, value);\n                    return 5;\n                }\n                // uint 64\n                hi = (value / Math.pow(2, 32)) >> 0;\n                lo = value >>> 0;\n                bytes.push(0xcf, hi >> 24, hi >> 16, hi >> 8, hi, lo >> 24, lo >> 16, lo >> 8, lo);\n                return 9;\n            }\n            else {\n                // negative fixnum\n                if (value >= -0x20) {\n                    bytes.push(value);\n                    return 1;\n                }\n                // int 8\n                if (value >= -0x80) {\n                    bytes.push(0xd0, value);\n                    return 2;\n                }\n                // int 16\n                if (value >= -0x8000) {\n                    bytes.push(0xd1, value >> 8, value);\n                    return 3;\n                }\n                // int 32\n                if (value >= -0x80000000) {\n                    bytes.push(0xd2, value >> 24, value >> 16, value >> 8, value);\n                    return 5;\n                }\n                // int 64\n                hi = Math.floor(value / Math.pow(2, 32));\n                lo = value >>> 0;\n                bytes.push(0xd3, hi >> 24, hi >> 16, hi >> 8, hi, lo >> 24, lo >> 16, lo >> 8, lo);\n                return 9;\n            }\n        }\n        if (type === 'object') {\n            // nil\n            if (value === null) {\n                bytes.push(0xc0);\n                return 1;\n            }\n            if (Array.isArray(value)) {\n                length = value.length;\n                // fixarray\n                if (length < 0x10) {\n                    bytes.push(length | 0x90);\n                    size = 1;\n                }\n                // array 16\n                else if (length < 0x10000) {\n                    bytes.push(0xdc, length >> 8, length);\n                    size = 3;\n                }\n                // array 32\n                else if (length < 0x100000000) {\n                    bytes.push(0xdd, length >> 24, length >> 16, length >> 8, length);\n                    size = 5;\n                }\n                else {\n                    throw new Error('Array too large');\n                }\n                for (i = 0; i < length; i++) {\n                    size += _encode(bytes, defers, value[i]);\n                }\n                return size;\n            }\n            if (value instanceof Date) {\n                var ms = value.getTime();\n                var s = Math.floor(ms / 1e3);\n                var ns = (ms - s * 1e3) * 1e6;\n                if (s >= 0 && ns >= 0 && s <= TIMESTAMP64_MAX_SEC) {\n                    if (ns === 0 && s <= TIMESTAMP32_MAX_SEC) {\n                        // timestamp 32\n                        bytes.push(0xd6, 0xff, s >> 24, s >> 16, s >> 8, s);\n                        return 6;\n                    }\n                    else {\n                        // timestamp 64\n                        hi = s / 0x100000000;\n                        lo = s & 0xffffffff;\n                        bytes.push(0xd7, 0xff, ns >> 22, ns >> 14, ns >> 6, hi, lo >> 24, lo >> 16, lo >> 8, lo);\n                        return 10;\n                    }\n                }\n                else {\n                    // timestamp 96\n                    hi = Math.floor(s / 0x100000000);\n                    lo = s >>> 0;\n                    bytes.push(0xc7, 0x0c, 0xff, ns >> 24, ns >> 16, ns >> 8, ns, hi >> 24, hi >> 16, hi >> 8, hi, lo >> 24, lo >> 16, lo >> 8, lo);\n                    return 15;\n                }\n            }\n            if (value instanceof ArrayBuffer) {\n                length = value.byteLength;\n                // bin 8\n                if (length < 0x100) {\n                    bytes.push(0xc4, length);\n                    size = 2;\n                }\n                else \n                // bin 16\n                if (length < 0x10000) {\n                    bytes.push(0xc5, length >> 8, length);\n                    size = 3;\n                }\n                else \n                // bin 32\n                if (length < 0x100000000) {\n                    bytes.push(0xc6, length >> 24, length >> 16, length >> 8, length);\n                    size = 5;\n                }\n                else {\n                    throw new Error('Buffer too large');\n                }\n                defers.push({ _bin: value, _length: length, _offset: bytes.length });\n                return size + length;\n            }\n            if (typeof value.toJSON === 'function') {\n                return _encode(bytes, defers, value.toJSON());\n            }\n            var keys = [], key = '';\n            var allKeys = Object.keys(value);\n            for (i = 0, l = allKeys.length; i < l; i++) {\n                key = allKeys[i];\n                if (value[key] !== undefined && typeof value[key] !== 'function') {\n                    keys.push(key);\n                }\n            }\n            length = keys.length;\n            // fixmap\n            if (length < 0x10) {\n                bytes.push(length | 0x80);\n                size = 1;\n            }\n            // map 16\n            else if (length < 0x10000) {\n                bytes.push(0xde, length >> 8, length);\n                size = 3;\n            }\n            // map 32\n            else if (length < 0x100000000) {\n                bytes.push(0xdf, length >> 24, length >> 16, length >> 8, length);\n                size = 5;\n            }\n            else {\n                throw new Error('Object too large');\n            }\n            for (i = 0; i < length; i++) {\n                key = keys[i];\n                size += _encode(bytes, defers, key);\n                size += _encode(bytes, defers, value[key]);\n            }\n            return size;\n        }\n        // false/true\n        if (type === 'boolean') {\n            bytes.push(value ? 0xc3 : 0xc2);\n            return 1;\n        }\n        if (type === 'undefined') {\n            bytes.push(0xc0);\n            return 1;\n        }\n        // custom types like BigInt (typeof value === 'bigint')\n        if (typeof value.toJSON === 'function') {\n            return _encode(bytes, defers, value.toJSON());\n        }\n        throw new Error('Could not encode');\n    }\n    function encode(value) {\n        var bytes = [];\n        var defers = [];\n        var size = _encode(bytes, defers, value);\n        var buf = new ArrayBuffer(size);\n        var view = new DataView(buf);\n        var deferIndex = 0;\n        var deferWritten = 0;\n        var nextOffset = -1;\n        if (defers.length > 0) {\n            nextOffset = defers[0]._offset;\n        }\n        var defer, deferLength = 0, offset = 0;\n        for (var i = 0, l = bytes.length; i < l; i++) {\n            view.setUint8(deferWritten + i, bytes[i]);\n            if (i + 1 !== nextOffset) {\n                continue;\n            }\n            defer = defers[deferIndex];\n            deferLength = defer._length;\n            offset = deferWritten + nextOffset;\n            if (defer._bin) {\n                var bin = new Uint8Array(defer._bin);\n                for (var j = 0; j < deferLength; j++) {\n                    view.setUint8(offset + j, bin[j]);\n                }\n            }\n            else if (defer._str) {\n                utf8Write(view, offset, defer._str);\n            }\n            else if (defer._float !== undefined) {\n                view.setFloat64(offset, defer._float);\n            }\n            deferIndex++;\n            deferWritten += deferLength;\n            if (defers[deferIndex]) {\n                nextOffset = defers[deferIndex]._offset;\n            }\n        }\n        return buf;\n    }\n\n    var browser = function () {\n      throw new Error(\n        'ws does not work in the browser. Browser clients must use the native ' +\n          'WebSocket object'\n      );\n    };\n\n    var WebSocket = globalThis.WebSocket || browser;\n    var WebSocketTransport = /** @class */ (function () {\n        function WebSocketTransport(events) {\n            this.events = events;\n        }\n        WebSocketTransport.prototype.send = function (data) {\n            if (data instanceof ArrayBuffer) {\n                this.ws.send(data);\n            }\n            else if (Array.isArray(data)) {\n                this.ws.send((new Uint8Array(data)).buffer);\n            }\n        };\n        WebSocketTransport.prototype.connect = function (url) {\n            this.ws = new WebSocket(url, this.protocols);\n            this.ws.binaryType = 'arraybuffer';\n            this.ws.onopen = this.events.onopen;\n            this.ws.onmessage = this.events.onmessage;\n            this.ws.onclose = this.events.onclose;\n            this.ws.onerror = this.events.onerror;\n        };\n        WebSocketTransport.prototype.close = function (code, reason) {\n            this.ws.close(code, reason);\n        };\n        Object.defineProperty(WebSocketTransport.prototype, \"isOpen\", {\n            get: function () {\n                return this.ws.readyState === WebSocket.OPEN;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        return WebSocketTransport;\n    }());\n\n    var Connection = /** @class */ (function () {\n        function Connection() {\n            this.events = {};\n            this.transport = new WebSocketTransport(this.events);\n        }\n        Connection.prototype.send = function (data) {\n            this.transport.send(data);\n        };\n        Connection.prototype.connect = function (url) {\n            this.transport.connect(url);\n        };\n        Connection.prototype.close = function (code, reason) {\n            this.transport.close(code, reason);\n        };\n        Object.defineProperty(Connection.prototype, \"isOpen\", {\n            get: function () {\n                return this.transport.isOpen;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        return Connection;\n    }());\n\n    // Use codes between 0~127 for lesser throughput (1 byte)\n    exports.Protocol = void 0;\n    (function (Protocol) {\n        // Room-related (10~19)\n        Protocol[Protocol[\"HANDSHAKE\"] = 9] = \"HANDSHAKE\";\n        Protocol[Protocol[\"JOIN_ROOM\"] = 10] = \"JOIN_ROOM\";\n        Protocol[Protocol[\"ERROR\"] = 11] = \"ERROR\";\n        Protocol[Protocol[\"LEAVE_ROOM\"] = 12] = \"LEAVE_ROOM\";\n        Protocol[Protocol[\"ROOM_DATA\"] = 13] = \"ROOM_DATA\";\n        Protocol[Protocol[\"ROOM_STATE\"] = 14] = \"ROOM_STATE\";\n        Protocol[Protocol[\"ROOM_STATE_PATCH\"] = 15] = \"ROOM_STATE_PATCH\";\n        Protocol[Protocol[\"ROOM_DATA_SCHEMA\"] = 16] = \"ROOM_DATA_SCHEMA\";\n        Protocol[Protocol[\"ROOM_DATA_BYTES\"] = 17] = \"ROOM_DATA_BYTES\";\n    })(exports.Protocol || (exports.Protocol = {}));\n    exports.ErrorCode = void 0;\n    (function (ErrorCode) {\n        ErrorCode[ErrorCode[\"MATCHMAKE_NO_HANDLER\"] = 4210] = \"MATCHMAKE_NO_HANDLER\";\n        ErrorCode[ErrorCode[\"MATCHMAKE_INVALID_CRITERIA\"] = 4211] = \"MATCHMAKE_INVALID_CRITERIA\";\n        ErrorCode[ErrorCode[\"MATCHMAKE_INVALID_ROOM_ID\"] = 4212] = \"MATCHMAKE_INVALID_ROOM_ID\";\n        ErrorCode[ErrorCode[\"MATCHMAKE_UNHANDLED\"] = 4213] = \"MATCHMAKE_UNHANDLED\";\n        ErrorCode[ErrorCode[\"MATCHMAKE_EXPIRED\"] = 4214] = \"MATCHMAKE_EXPIRED\";\n        ErrorCode[ErrorCode[\"AUTH_FAILED\"] = 4215] = \"AUTH_FAILED\";\n        ErrorCode[ErrorCode[\"APPLICATION_ERROR\"] = 4216] = \"APPLICATION_ERROR\";\n    })(exports.ErrorCode || (exports.ErrorCode = {}));\n    function utf8Read(view, offset) {\n        var length = view[offset++];\n        var string = '', chr = 0;\n        for (var i = offset, end = offset + length; i < end; i++) {\n            var byte = view[i];\n            if ((byte & 0x80) === 0x00) {\n                string += String.fromCharCode(byte);\n                continue;\n            }\n            if ((byte & 0xe0) === 0xc0) {\n                string += String.fromCharCode(((byte & 0x1f) << 6) |\n                    (view[++i] & 0x3f));\n                continue;\n            }\n            if ((byte & 0xf0) === 0xe0) {\n                string += String.fromCharCode(((byte & 0x0f) << 12) |\n                    ((view[++i] & 0x3f) << 6) |\n                    ((view[++i] & 0x3f) << 0));\n                continue;\n            }\n            if ((byte & 0xf8) === 0xf0) {\n                chr = ((byte & 0x07) << 18) |\n                    ((view[++i] & 0x3f) << 12) |\n                    ((view[++i] & 0x3f) << 6) |\n                    ((view[++i] & 0x3f) << 0);\n                if (chr >= 0x010000) { // surrogate pair\n                    chr -= 0x010000;\n                    string += String.fromCharCode((chr >>> 10) + 0xD800, (chr & 0x3FF) + 0xDC00);\n                }\n                else {\n                    string += String.fromCharCode(chr);\n                }\n                continue;\n            }\n            throw new Error('Invalid byte ' + byte.toString(16));\n        }\n        return string;\n    }\n    // Faster for short strings than Buffer.byteLength\n    function utf8Length(str) {\n        if (str === void 0) { str = ''; }\n        var c = 0;\n        var length = 0;\n        for (var i = 0, l = str.length; i < l; i++) {\n            c = str.charCodeAt(i);\n            if (c < 0x80) {\n                length += 1;\n            }\n            else if (c < 0x800) {\n                length += 2;\n            }\n            else if (c < 0xd800 || c >= 0xe000) {\n                length += 3;\n            }\n            else {\n                i++;\n                length += 4;\n            }\n        }\n        return length + 1;\n    }\n\n    var serializers = {};\n    function registerSerializer(id, serializer) {\n        serializers[id] = serializer;\n    }\n    function getSerializer(id) {\n        var serializer = serializers[id];\n        if (!serializer) {\n            throw new Error(\"missing serializer: \" + id);\n        }\n        return serializer;\n    }\n\n    let createNanoEvents = () => ({\n      events: {},\n      emit(event, ...args) {\n    (this.events[event] || []).forEach(i => i(...args));\n      },\n      on(event, cb) {\n    (this.events[event] = this.events[event] || []).push(cb);\n        return () =>\n          (this.events[event] = (this.events[event] || []).filter(i => i !== cb))\n      }\n    });\n\n    var EventEmitter = /** @class */ (function () {\n        function EventEmitter() {\n            this.handlers = [];\n        }\n        EventEmitter.prototype.register = function (cb, once) {\n            this.handlers.push(cb);\n            return this;\n        };\n        EventEmitter.prototype.invoke = function () {\n            var _this = this;\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            this.handlers.forEach(function (handler) { return handler.apply(_this, args); });\n        };\n        EventEmitter.prototype.invokeAsync = function () {\n            var _this = this;\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            return Promise.all(this.handlers.map(function (handler) { return handler.apply(_this, args); }));\n        };\n        EventEmitter.prototype.remove = function (cb) {\n            var index = this.handlers.indexOf(cb);\n            this.handlers[index] = this.handlers[this.handlers.length - 1];\n            this.handlers.pop();\n        };\n        EventEmitter.prototype.clear = function () {\n            this.handlers = [];\n        };\n        return EventEmitter;\n    }());\n    function createSignal() {\n        var emitter = new EventEmitter();\n        function register(cb) {\n            return emitter.register(cb, this === null);\n        }\n        register.once = function (cb) {\n            var callback = function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                cb.apply(this, args);\n                emitter.remove(callback);\n            };\n            emitter.register(callback);\n        };\n        register.remove = function (cb) { return emitter.remove(cb); };\n        register.invoke = function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            return emitter.invoke.apply(emitter, args);\n        };\n        register.invokeAsync = function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            return emitter.invokeAsync.apply(emitter, args);\n        };\n        register.clear = function () { return emitter.clear(); };\n        return register;\n    }\n\n    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : typeof self !== 'undefined' ? self : {};\n\n    function createCommonjsModule(fn) {\n      var module = { exports: {} };\n    \treturn fn(module, module.exports), module.exports;\n    }\n\n    var umd = createCommonjsModule(function (module, exports) {\n    (function (global, factory) {\n        factory(exports) ;\n    })(commonjsGlobal, (function (exports) {\n        /******************************************************************************\r\n        Copyright (c) Microsoft Corporation.\r\n\r\n        Permission to use, copy, modify, and/or distribute this software for any\r\n        purpose with or without fee is hereby granted.\r\n\r\n        THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\n        REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\n        AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\n        INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\n        LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\n        OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\n        PERFORMANCE OF THIS SOFTWARE.\r\n        ***************************************************************************** */\r\n        /* global Reflect, Promise */\r\n\r\n        var extendStatics = function(d, b) {\r\n            extendStatics = Object.setPrototypeOf ||\r\n                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n            return extendStatics(d, b);\r\n        };\r\n\r\n        function __extends(d, b) {\r\n            if (typeof b !== \"function\" && b !== null)\r\n                throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n            extendStatics(d, b);\r\n            function __() { this.constructor = d; }\r\n            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n        }\r\n\r\n        function __decorate(decorators, target, key, desc) {\r\n            var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n            if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n            else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n            return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n        }\r\n\r\n        function __spreadArray(to, from, pack) {\r\n            if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n                if (ar || !(i in from)) {\r\n                    if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n                    ar[i] = from[i];\r\n                }\r\n            }\r\n            return to.concat(ar || Array.prototype.slice.call(from));\r\n        }\n\n        // export const SWITCH_TO_STRUCTURE = 193; (easily collides with DELETE_AND_ADD + fieldIndex = 2)\n        var SWITCH_TO_STRUCTURE = 255; // (decoding collides with DELETE_AND_ADD + fieldIndex = 63)\n        var TYPE_ID = 213;\n        /**\n         * Encoding Schema field operations.\n         */\n        exports.OPERATION = void 0;\n        (function (OPERATION) {\n            // add new structure/primitive\n            OPERATION[OPERATION[\"ADD\"] = 128] = \"ADD\";\n            // replace structure/primitive\n            OPERATION[OPERATION[\"REPLACE\"] = 0] = \"REPLACE\";\n            // delete field\n            OPERATION[OPERATION[\"DELETE\"] = 64] = \"DELETE\";\n            // DELETE field, followed by an ADD\n            OPERATION[OPERATION[\"DELETE_AND_ADD\"] = 192] = \"DELETE_AND_ADD\";\n            // TOUCH is used to determine hierarchy of nested Schema structures during serialization.\n            // touches are NOT encoded.\n            OPERATION[OPERATION[\"TOUCH\"] = 1] = \"TOUCH\";\n            // MapSchema Operations\n            OPERATION[OPERATION[\"CLEAR\"] = 10] = \"CLEAR\";\n        })(exports.OPERATION || (exports.OPERATION = {}));\n        // export enum OPERATION {\n        //     // add new structure/primitive\n        //     // (128)\n        //     ADD = 128, // 10000000,\n        //     // replace structure/primitive\n        //     REPLACE = 1,// 00000001\n        //     // delete field\n        //     DELETE = 192, // 11000000\n        //     // DELETE field, followed by an ADD\n        //     DELETE_AND_ADD = 224, // 11100000\n        //     // TOUCH is used to determine hierarchy of nested Schema structures during serialization.\n        //     // touches are NOT encoded.\n        //     TOUCH = 0, // 00000000\n        //     // MapSchema Operations\n        //     CLEAR = 10,\n        // }\n\n        var ChangeTree = /** @class */ (function () {\n            function ChangeTree(ref, parent, root) {\n                this.changed = false;\n                this.changes = new Map();\n                this.allChanges = new Set();\n                // cached indexes for filtering\n                this.caches = {};\n                this.currentCustomOperation = 0;\n                this.ref = ref;\n                this.setParent(parent, root);\n            }\n            ChangeTree.prototype.setParent = function (parent, root, parentIndex) {\n                var _this = this;\n                if (!this.indexes) {\n                    this.indexes = (this.ref instanceof Schema)\n                        ? this.ref['_definition'].indexes\n                        : {};\n                }\n                this.parent = parent;\n                this.parentIndex = parentIndex;\n                // avoid setting parents with empty `root`\n                if (!root) {\n                    return;\n                }\n                this.root = root;\n                //\n                // assign same parent on child structures\n                //\n                if (this.ref instanceof Schema) {\n                    var definition = this.ref['_definition'];\n                    for (var field in definition.schema) {\n                        var value = this.ref[field];\n                        if (value && value['$changes']) {\n                            var parentIndex_1 = definition.indexes[field];\n                            value['$changes'].setParent(this.ref, root, parentIndex_1);\n                        }\n                    }\n                }\n                else if (typeof (this.ref) === \"object\") {\n                    this.ref.forEach(function (value, key) {\n                        if (value instanceof Schema) {\n                            var changeTreee = value['$changes'];\n                            var parentIndex_2 = _this.ref['$changes'].indexes[key];\n                            changeTreee.setParent(_this.ref, _this.root, parentIndex_2);\n                        }\n                    });\n                }\n            };\n            ChangeTree.prototype.operation = function (op) {\n                this.changes.set(--this.currentCustomOperation, op);\n            };\n            ChangeTree.prototype.change = function (fieldName, operation) {\n                if (operation === void 0) { operation = exports.OPERATION.ADD; }\n                var index = (typeof (fieldName) === \"number\")\n                    ? fieldName\n                    : this.indexes[fieldName];\n                this.assertValidIndex(index, fieldName);\n                var previousChange = this.changes.get(index);\n                if (!previousChange ||\n                    previousChange.op === exports.OPERATION.DELETE ||\n                    previousChange.op === exports.OPERATION.TOUCH // (mazmorra.io's BattleAction issue)\n                ) {\n                    this.changes.set(index, {\n                        op: (!previousChange)\n                            ? operation\n                            : (previousChange.op === exports.OPERATION.DELETE)\n                                ? exports.OPERATION.DELETE_AND_ADD\n                                : operation,\n                        // : OPERATION.REPLACE,\n                        index: index\n                    });\n                }\n                this.allChanges.add(index);\n                this.changed = true;\n                this.touchParents();\n            };\n            ChangeTree.prototype.touch = function (fieldName) {\n                var index = (typeof (fieldName) === \"number\")\n                    ? fieldName\n                    : this.indexes[fieldName];\n                this.assertValidIndex(index, fieldName);\n                if (!this.changes.has(index)) {\n                    this.changes.set(index, { op: exports.OPERATION.TOUCH, index: index });\n                }\n                this.allChanges.add(index);\n                // ensure touch is placed until the $root is found.\n                this.touchParents();\n            };\n            ChangeTree.prototype.touchParents = function () {\n                if (this.parent) {\n                    this.parent['$changes'].touch(this.parentIndex);\n                }\n            };\n            ChangeTree.prototype.getType = function (index) {\n                if (this.ref['_definition']) {\n                    var definition = this.ref['_definition'];\n                    return definition.schema[definition.fieldsByIndex[index]];\n                }\n                else {\n                    var definition = this.parent['_definition'];\n                    var parentType = definition.schema[definition.fieldsByIndex[this.parentIndex]];\n                    //\n                    // Get the child type from parent structure.\n                    // - [\"string\"] => \"string\"\n                    // - { map: \"string\" } => \"string\"\n                    // - { set: \"string\" } => \"string\"\n                    //\n                    return Object.values(parentType)[0];\n                }\n            };\n            ChangeTree.prototype.getChildrenFilter = function () {\n                var childFilters = this.parent['_definition'].childFilters;\n                return childFilters && childFilters[this.parentIndex];\n            };\n            //\n            // used during `.encode()`\n            //\n            ChangeTree.prototype.getValue = function (index) {\n                return this.ref['getByIndex'](index);\n            };\n            ChangeTree.prototype.delete = function (fieldName) {\n                var index = (typeof (fieldName) === \"number\")\n                    ? fieldName\n                    : this.indexes[fieldName];\n                if (index === undefined) {\n                    console.warn(\"@colyseus/schema \".concat(this.ref.constructor.name, \": trying to delete non-existing index: \").concat(fieldName, \" (\").concat(index, \")\"));\n                    return;\n                }\n                var previousValue = this.getValue(index);\n                // console.log(\"$changes.delete =>\", { fieldName, index, previousValue });\n                this.changes.set(index, { op: exports.OPERATION.DELETE, index: index });\n                this.allChanges.delete(index);\n                // delete cache\n                delete this.caches[index];\n                // remove `root` reference\n                if (previousValue && previousValue['$changes']) {\n                    previousValue['$changes'].parent = undefined;\n                }\n                this.changed = true;\n                this.touchParents();\n            };\n            ChangeTree.prototype.discard = function (changed, discardAll) {\n                var _this = this;\n                if (changed === void 0) { changed = false; }\n                if (discardAll === void 0) { discardAll = false; }\n                //\n                // Map, Array, etc:\n                // Remove cached key to ensure ADD operations is unsed instead of\n                // REPLACE in case same key is used on next patches.\n                //\n                // TODO: refactor this. this is not relevant for Collection and Set.\n                //\n                if (!(this.ref instanceof Schema)) {\n                    this.changes.forEach(function (change) {\n                        if (change.op === exports.OPERATION.DELETE) {\n                            var index = _this.ref['getIndex'](change.index);\n                            delete _this.indexes[index];\n                        }\n                    });\n                }\n                this.changes.clear();\n                this.changed = changed;\n                if (discardAll) {\n                    this.allChanges.clear();\n                }\n                // re-set `currentCustomOperation`\n                this.currentCustomOperation = 0;\n            };\n            /**\n             * Recursively discard all changes from this, and child structures.\n             */\n            ChangeTree.prototype.discardAll = function () {\n                var _this = this;\n                this.changes.forEach(function (change) {\n                    var value = _this.getValue(change.index);\n                    if (value && value['$changes']) {\n                        value['$changes'].discardAll();\n                    }\n                });\n                this.discard();\n            };\n            // cache(field: number, beginIndex: number, endIndex: number) {\n            ChangeTree.prototype.cache = function (field, cachedBytes) {\n                this.caches[field] = cachedBytes;\n            };\n            ChangeTree.prototype.clone = function () {\n                return new ChangeTree(this.ref, this.parent, this.root);\n            };\n            ChangeTree.prototype.ensureRefId = function () {\n                // skip if refId is already set.\n                if (this.refId !== undefined) {\n                    return;\n                }\n                this.refId = this.root.getNextUniqueId();\n            };\n            ChangeTree.prototype.assertValidIndex = function (index, fieldName) {\n                if (index === undefined) {\n                    throw new Error(\"ChangeTree: missing index for field \\\"\".concat(fieldName, \"\\\"\"));\n                }\n            };\n            return ChangeTree;\n        }());\n\n        function addCallback($callbacks, op, callback, existing) {\n            // initialize list of callbacks\n            if (!$callbacks[op]) {\n                $callbacks[op] = [];\n            }\n            $callbacks[op].push(callback);\n            //\n            // Trigger callback for existing elements\n            // - OPERATION.ADD\n            // - OPERATION.REPLACE\n            //\n            existing === null || existing === void 0 ? void 0 : existing.forEach(function (item, key) { return callback(item, key); });\n            return function () { return spliceOne($callbacks[op], $callbacks[op].indexOf(callback)); };\n        }\n        function removeChildRefs(changes) {\n            var _this = this;\n            var needRemoveRef = (typeof (this.$changes.getType()) !== \"string\");\n            this.$items.forEach(function (item, key) {\n                changes.push({\n                    refId: _this.$changes.refId,\n                    op: exports.OPERATION.DELETE,\n                    field: key,\n                    value: undefined,\n                    previousValue: item\n                });\n                if (needRemoveRef) {\n                    _this.$changes.root.removeRef(item['$changes'].refId);\n                }\n            });\n        }\n        function spliceOne(arr, index) {\n            // manually splice an array\n            if (index === -1 || index >= arr.length) {\n                return false;\n            }\n            var len = arr.length - 1;\n            for (var i = index; i < len; i++) {\n                arr[i] = arr[i + 1];\n            }\n            arr.length = len;\n            return true;\n        }\n\n        var DEFAULT_SORT = function (a, b) {\n            var A = a.toString();\n            var B = b.toString();\n            if (A < B)\n                return -1;\n            else if (A > B)\n                return 1;\n            else\n                return 0;\n        };\n        function getArrayProxy(value) {\n            value['$proxy'] = true;\n            //\n            // compatibility with @colyseus/schema 0.5.x\n            // - allow `map[\"key\"]`\n            // - allow `map[\"key\"] = \"xxx\"`\n            // - allow `delete map[\"key\"]`\n            //\n            value = new Proxy(value, {\n                get: function (obj, prop) {\n                    if (typeof (prop) !== \"symbol\" &&\n                        !isNaN(prop) // https://stackoverflow.com/a/175787/892698\n                    ) {\n                        return obj.at(prop);\n                    }\n                    else {\n                        return obj[prop];\n                    }\n                },\n                set: function (obj, prop, setValue) {\n                    if (typeof (prop) !== \"symbol\" &&\n                        !isNaN(prop)) {\n                        var indexes = Array.from(obj['$items'].keys());\n                        var key = parseInt(indexes[prop] || prop);\n                        if (setValue === undefined || setValue === null) {\n                            obj.deleteAt(key);\n                        }\n                        else {\n                            obj.setAt(key, setValue);\n                        }\n                    }\n                    else {\n                        obj[prop] = setValue;\n                    }\n                    return true;\n                },\n                deleteProperty: function (obj, prop) {\n                    if (typeof (prop) === \"number\") {\n                        obj.deleteAt(prop);\n                    }\n                    else {\n                        delete obj[prop];\n                    }\n                    return true;\n                },\n            });\n            return value;\n        }\n        var ArraySchema = /** @class */ (function () {\n            function ArraySchema() {\n                var items = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    items[_i] = arguments[_i];\n                }\n                this.$changes = new ChangeTree(this);\n                this.$items = new Map();\n                this.$indexes = new Map();\n                this.$refId = 0;\n                this.push.apply(this, items);\n            }\n            ArraySchema.prototype.onAdd = function (callback, triggerAll) {\n                if (triggerAll === void 0) { triggerAll = true; }\n                return addCallback((this.$callbacks || (this.$callbacks = [])), exports.OPERATION.ADD, callback, (triggerAll)\n                    ? this.$items\n                    : undefined);\n            };\n            ArraySchema.prototype.onRemove = function (callback) { return addCallback(this.$callbacks || (this.$callbacks = []), exports.OPERATION.DELETE, callback); };\n            ArraySchema.prototype.onChange = function (callback) { return addCallback(this.$callbacks || (this.$callbacks = []), exports.OPERATION.REPLACE, callback); };\n            ArraySchema.is = function (type) {\n                return (\n                // type format: [\"string\"]\n                Array.isArray(type) ||\n                    // type format: { array: \"string\" }\n                    (type['array'] !== undefined));\n            };\n            Object.defineProperty(ArraySchema.prototype, \"length\", {\n                get: function () {\n                    return this.$items.size;\n                },\n                set: function (value) {\n                    if (value === 0) {\n                        this.clear();\n                    }\n                    else {\n                        this.splice(value, this.length - value);\n                    }\n                },\n                enumerable: false,\n                configurable: true\n            });\n            ArraySchema.prototype.push = function () {\n                var _this = this;\n                var values = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    values[_i] = arguments[_i];\n                }\n                var lastIndex;\n                values.forEach(function (value) {\n                    // set \"index\" for reference.\n                    lastIndex = _this.$refId++;\n                    _this.setAt(lastIndex, value);\n                });\n                return lastIndex;\n            };\n            /**\n             * Removes the last element from an array and returns it.\n             */\n            ArraySchema.prototype.pop = function () {\n                var key = Array.from(this.$indexes.values()).pop();\n                if (key === undefined) {\n                    return undefined;\n                }\n                this.$changes.delete(key);\n                this.$indexes.delete(key);\n                var value = this.$items.get(key);\n                this.$items.delete(key);\n                return value;\n            };\n            ArraySchema.prototype.at = function (index) {\n                //\n                // FIXME: this should be O(1)\n                //\n                var key = Array.from(this.$items.keys())[index];\n                return this.$items.get(key);\n            };\n            ArraySchema.prototype.setAt = function (index, value) {\n                var _a, _b;\n                if (value['$changes'] !== undefined) {\n                    value['$changes'].setParent(this, this.$changes.root, index);\n                }\n                var operation = (_b = (_a = this.$changes.indexes[index]) === null || _a === void 0 ? void 0 : _a.op) !== null && _b !== void 0 ? _b : exports.OPERATION.ADD;\n                this.$changes.indexes[index] = index;\n                this.$indexes.set(index, index);\n                this.$items.set(index, value);\n                this.$changes.change(index, operation);\n            };\n            ArraySchema.prototype.deleteAt = function (index) {\n                var key = Array.from(this.$items.keys())[index];\n                if (key === undefined) {\n                    return false;\n                }\n                return this.$deleteAt(key);\n            };\n            ArraySchema.prototype.$deleteAt = function (index) {\n                // delete at internal index\n                this.$changes.delete(index);\n                this.$indexes.delete(index);\n                return this.$items.delete(index);\n            };\n            ArraySchema.prototype.clear = function (changes) {\n                // discard previous operations.\n                this.$changes.discard(true, true);\n                this.$changes.indexes = {};\n                // clear previous indexes\n                this.$indexes.clear();\n                //\n                // When decoding:\n                // - enqueue items for DELETE callback.\n                // - flag child items for garbage collection.\n                //\n                if (changes) {\n                    removeChildRefs.call(this, changes);\n                }\n                // clear items\n                this.$items.clear();\n                this.$changes.operation({ index: 0, op: exports.OPERATION.CLEAR });\n                // touch all structures until reach root\n                this.$changes.touchParents();\n            };\n            /**\n             * Combines two or more arrays.\n             * @param items Additional items to add to the end of array1.\n             */\n            // @ts-ignore\n            ArraySchema.prototype.concat = function () {\n                var _a;\n                var items = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    items[_i] = arguments[_i];\n                }\n                return new (ArraySchema.bind.apply(ArraySchema, __spreadArray([void 0], (_a = Array.from(this.$items.values())).concat.apply(_a, items), false)))();\n            };\n            /**\n             * Adds all the elements of an array separated by the specified separator string.\n             * @param separator A string used to separate one element of an array from the next in the resulting String. If omitted, the array elements are separated with a comma.\n             */\n            ArraySchema.prototype.join = function (separator) {\n                return Array.from(this.$items.values()).join(separator);\n            };\n            /**\n             * Reverses the elements in an Array.\n             */\n            // @ts-ignore\n            ArraySchema.prototype.reverse = function () {\n                var _this = this;\n                var indexes = Array.from(this.$items.keys());\n                var reversedItems = Array.from(this.$items.values()).reverse();\n                reversedItems.forEach(function (item, i) {\n                    _this.setAt(indexes[i], item);\n                });\n                return this;\n            };\n            /**\n             * Removes the first element from an array and returns it.\n             */\n            ArraySchema.prototype.shift = function () {\n                var indexes = Array.from(this.$items.keys());\n                var shiftAt = indexes.shift();\n                if (shiftAt === undefined) {\n                    return undefined;\n                }\n                var value = this.$items.get(shiftAt);\n                this.$deleteAt(shiftAt);\n                return value;\n            };\n            /**\n             * Returns a section of an array.\n             * @param start The beginning of the specified portion of the array.\n             * @param end The end of the specified portion of the array. This is exclusive of the element at the index 'end'.\n             */\n            ArraySchema.prototype.slice = function (start, end) {\n                var sliced = new ArraySchema();\n                sliced.push.apply(sliced, Array.from(this.$items.values()).slice(start, end));\n                return sliced;\n            };\n            /**\n             * Sorts an array.\n             * @param compareFn Function used to determine the order of the elements. It is expected to return\n             * a negative value if first argument is less than second argument, zero if they're equal and a positive\n             * value otherwise. If omitted, the elements are sorted in ascending, ASCII character order.\n             * ```ts\n             * [11,2,22,1].sort((a, b) => a - b)\n             * ```\n             */\n            ArraySchema.prototype.sort = function (compareFn) {\n                var _this = this;\n                if (compareFn === void 0) { compareFn = DEFAULT_SORT; }\n                var indexes = Array.from(this.$items.keys());\n                var sortedItems = Array.from(this.$items.values()).sort(compareFn);\n                sortedItems.forEach(function (item, i) {\n                    _this.setAt(indexes[i], item);\n                });\n                return this;\n            };\n            /**\n             * Removes elements from an array and, if necessary, inserts new elements in their place, returning the deleted elements.\n             * @param start The zero-based location in the array from which to start removing elements.\n             * @param deleteCount The number of elements to remove.\n             * @param items Elements to insert into the array in place of the deleted elements.\n             */\n            ArraySchema.prototype.splice = function (start, deleteCount) {\n                if (deleteCount === void 0) { deleteCount = this.length - start; }\n                var indexes = Array.from(this.$items.keys());\n                var removedItems = [];\n                for (var i = start; i < start + deleteCount; i++) {\n                    removedItems.push(this.$items.get(indexes[i]));\n                    this.$deleteAt(indexes[i]);\n                }\n                return removedItems;\n            };\n            /**\n             * Inserts new elements at the start of an array.\n             * @param items  Elements to insert at the start of the Array.\n             */\n            ArraySchema.prototype.unshift = function () {\n                var _this = this;\n                var items = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    items[_i] = arguments[_i];\n                }\n                var length = this.length;\n                var addedLength = items.length;\n                // const indexes = Array.from(this.$items.keys());\n                var previousValues = Array.from(this.$items.values());\n                items.forEach(function (item, i) {\n                    _this.setAt(i, item);\n                });\n                previousValues.forEach(function (previousValue, i) {\n                    _this.setAt(addedLength + i, previousValue);\n                });\n                return length + addedLength;\n            };\n            /**\n             * Returns the index of the first occurrence of a value in an array.\n             * @param searchElement The value to locate in the array.\n             * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0.\n             */\n            ArraySchema.prototype.indexOf = function (searchElement, fromIndex) {\n                return Array.from(this.$items.values()).indexOf(searchElement, fromIndex);\n            };\n            /**\n             * Returns the index of the last occurrence of a specified value in an array.\n             * @param searchElement The value to locate in the array.\n             * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at the last index in the array.\n             */\n            ArraySchema.prototype.lastIndexOf = function (searchElement, fromIndex) {\n                if (fromIndex === void 0) { fromIndex = this.length - 1; }\n                return Array.from(this.$items.values()).lastIndexOf(searchElement, fromIndex);\n            };\n            /**\n             * Determines whether all the members of an array satisfy the specified test.\n             * @param callbackfn A function that accepts up to three arguments. The every method calls\n             * the callbackfn function for each element in the array until the callbackfn returns a value\n             * which is coercible to the Boolean value false, or until the end of the array.\n             * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n             * If thisArg is omitted, undefined is used as the this value.\n             */\n            ArraySchema.prototype.every = function (callbackfn, thisArg) {\n                return Array.from(this.$items.values()).every(callbackfn, thisArg);\n            };\n            /**\n             * Determines whether the specified callback function returns true for any element of an array.\n             * @param callbackfn A function that accepts up to three arguments. The some method calls\n             * the callbackfn function for each element in the array until the callbackfn returns a value\n             * which is coercible to the Boolean value true, or until the end of the array.\n             * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n             * If thisArg is omitted, undefined is used as the this value.\n             */\n            ArraySchema.prototype.some = function (callbackfn, thisArg) {\n                return Array.from(this.$items.values()).some(callbackfn, thisArg);\n            };\n            /**\n             * Performs the specified action for each element in an array.\n             * @param callbackfn  A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.\n             * @param thisArg  An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n             */\n            ArraySchema.prototype.forEach = function (callbackfn, thisArg) {\n                Array.from(this.$items.values()).forEach(callbackfn, thisArg);\n            };\n            /**\n             * Calls a defined callback function on each element of an array, and returns an array that contains the results.\n             * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.\n             * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n             */\n            ArraySchema.prototype.map = function (callbackfn, thisArg) {\n                return Array.from(this.$items.values()).map(callbackfn, thisArg);\n            };\n            ArraySchema.prototype.filter = function (callbackfn, thisArg) {\n                return Array.from(this.$items.values()).filter(callbackfn, thisArg);\n            };\n            /**\n             * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\n             * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.\n             * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\n             */\n            ArraySchema.prototype.reduce = function (callbackfn, initialValue) {\n                return Array.prototype.reduce.apply(Array.from(this.$items.values()), arguments);\n            };\n            /**\n             * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\n             * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.\n             * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\n             */\n            ArraySchema.prototype.reduceRight = function (callbackfn, initialValue) {\n                return Array.prototype.reduceRight.apply(Array.from(this.$items.values()), arguments);\n            };\n            /**\n             * Returns the value of the first element in the array where predicate is true, and undefined\n             * otherwise.\n             * @param predicate find calls predicate once for each element of the array, in ascending\n             * order, until it finds one where predicate returns true. If such an element is found, find\n             * immediately returns that element value. Otherwise, find returns undefined.\n             * @param thisArg If provided, it will be used as the this value for each invocation of\n             * predicate. If it is not provided, undefined is used instead.\n             */\n            ArraySchema.prototype.find = function (predicate, thisArg) {\n                return Array.from(this.$items.values()).find(predicate, thisArg);\n            };\n            /**\n             * Returns the index of the first element in the array where predicate is true, and -1\n             * otherwise.\n             * @param predicate find calls predicate once for each element of the array, in ascending\n             * order, until it finds one where predicate returns true. If such an element is found,\n             * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\n             * @param thisArg If provided, it will be used as the this value for each invocation of\n             * predicate. If it is not provided, undefined is used instead.\n             */\n            ArraySchema.prototype.findIndex = function (predicate, thisArg) {\n                return Array.from(this.$items.values()).findIndex(predicate, thisArg);\n            };\n            /**\n             * Returns the this object after filling the section identified by start and end with value\n             * @param value value to fill array section with\n             * @param start index to start filling the array at. If start is negative, it is treated as\n             * length+start where length is the length of the array.\n             * @param end index to stop filling the array at. If end is negative, it is treated as\n             * length+end.\n             */\n            ArraySchema.prototype.fill = function (value, start, end) {\n                //\n                // TODO\n                //\n                throw new Error(\"ArraySchema#fill() not implemented\");\n            };\n            /**\n             * Returns the this object after copying a section of the array identified by start and end\n             * to the same array starting at position target\n             * @param target If target is negative, it is treated as length+target where length is the\n             * length of the array.\n             * @param start If start is negative, it is treated as length+start. If end is negative, it\n             * is treated as length+end.\n             * @param end If not specified, length of the this object is used as its default value.\n             */\n            ArraySchema.prototype.copyWithin = function (target, start, end) {\n                //\n                // TODO\n                //\n                throw new Error(\"ArraySchema#copyWithin() not implemented\");\n            };\n            /**\n             * Returns a string representation of an array.\n             */\n            ArraySchema.prototype.toString = function () { return this.$items.toString(); };\n            /**\n             * Returns a string representation of an array. The elements are converted to string using their toLocalString methods.\n             */\n            ArraySchema.prototype.toLocaleString = function () { return this.$items.toLocaleString(); };\n            /** Iterator */\n            ArraySchema.prototype[Symbol.iterator] = function () {\n                return Array.from(this.$items.values())[Symbol.iterator]();\n            };\n            /**\n             * Returns an iterable of key, value pairs for every entry in the array\n             */\n            ArraySchema.prototype.entries = function () { return this.$items.entries(); };\n            /**\n             * Returns an iterable of keys in the array\n             */\n            ArraySchema.prototype.keys = function () { return this.$items.keys(); };\n            /**\n             * Returns an iterable of values in the array\n             */\n            ArraySchema.prototype.values = function () { return this.$items.values(); };\n            /**\n             * Determines whether an array includes a certain element, returning true or false as appropriate.\n             * @param searchElement The element to search for.\n             * @param fromIndex The position in this array at which to begin searching for searchElement.\n             */\n            ArraySchema.prototype.includes = function (searchElement, fromIndex) {\n                return Array.from(this.$items.values()).includes(searchElement, fromIndex);\n            };\n            /**\n             * Calls a defined callback function on each element of an array. Then, flattens the result into\n             * a new array.\n             * This is identical to a map followed by flat with depth 1.\n             *\n             * @param callback A function that accepts up to three arguments. The flatMap method calls the\n             * callback function one time for each element in the array.\n             * @param thisArg An object to which the this keyword can refer in the callback function. If\n             * thisArg is omitted, undefined is used as the this value.\n             */\n            // @ts-ignore\n            ArraySchema.prototype.flatMap = function (callback, thisArg) {\n                // @ts-ignore\n                throw new Error(\"ArraySchema#flatMap() is not supported.\");\n            };\n            /**\n             * Returns a new array with all sub-array elements concatenated into it recursively up to the\n             * specified depth.\n             *\n             * @param depth The maximum recursion depth\n             */\n            // @ts-ignore\n            ArraySchema.prototype.flat = function (depth) {\n                throw new Error(\"ArraySchema#flat() is not supported.\");\n            };\n            ArraySchema.prototype.findLast = function () {\n                var arr = Array.from(this.$items.values());\n                // @ts-ignore\n                return arr.findLast.apply(arr, arguments);\n            };\n            ArraySchema.prototype.findLastIndex = function () {\n                var arr = Array.from(this.$items.values());\n                // @ts-ignore\n                return arr.findLastIndex.apply(arr, arguments);\n            };\n            // get size () {\n            //     return this.$items.size;\n            // }\n            ArraySchema.prototype.setIndex = function (index, key) {\n                this.$indexes.set(index, key);\n            };\n            ArraySchema.prototype.getIndex = function (index) {\n                return this.$indexes.get(index);\n            };\n            ArraySchema.prototype.getByIndex = function (index) {\n                return this.$items.get(this.$indexes.get(index));\n            };\n            ArraySchema.prototype.deleteByIndex = function (index) {\n                var key = this.$indexes.get(index);\n                this.$items.delete(key);\n                this.$indexes.delete(index);\n            };\n            ArraySchema.prototype.toArray = function () {\n                return Array.from(this.$items.values());\n            };\n            ArraySchema.prototype.toJSON = function () {\n                return this.toArray().map(function (value) {\n                    return (typeof (value['toJSON']) === \"function\")\n                        ? value['toJSON']()\n                        : value;\n                });\n            };\n            //\n            // Decoding utilities\n            //\n            ArraySchema.prototype.clone = function (isDecoding) {\n                var cloned;\n                if (isDecoding) {\n                    cloned = new (ArraySchema.bind.apply(ArraySchema, __spreadArray([void 0], Array.from(this.$items.values()), false)))();\n                }\n                else {\n                    cloned = new (ArraySchema.bind.apply(ArraySchema, __spreadArray([void 0], this.map(function (item) { return ((item['$changes'])\n                        ? item.clone()\n                        : item); }), false)))();\n                }\n                return cloned;\n            };\n            return ArraySchema;\n        }());\n\n        function getMapProxy(value) {\n            value['$proxy'] = true;\n            value = new Proxy(value, {\n                get: function (obj, prop) {\n                    if (typeof (prop) !== \"symbol\" && // accessing properties\n                        typeof (obj[prop]) === \"undefined\") {\n                        return obj.get(prop);\n                    }\n                    else {\n                        return obj[prop];\n                    }\n                },\n                set: function (obj, prop, setValue) {\n                    if (typeof (prop) !== \"symbol\" &&\n                        (prop.indexOf(\"$\") === -1 &&\n                            prop !== \"onAdd\" &&\n                            prop !== \"onRemove\" &&\n                            prop !== \"onChange\")) {\n                        obj.set(prop, setValue);\n                    }\n                    else {\n                        obj[prop] = setValue;\n                    }\n                    return true;\n                },\n                deleteProperty: function (obj, prop) {\n                    obj.delete(prop);\n                    return true;\n                },\n            });\n            return value;\n        }\n        var MapSchema = /** @class */ (function () {\n            function MapSchema(initialValues) {\n                var _this = this;\n                this.$changes = new ChangeTree(this);\n                this.$items = new Map();\n                this.$indexes = new Map();\n                this.$refId = 0;\n                if (initialValues) {\n                    if (initialValues instanceof Map ||\n                        initialValues instanceof MapSchema) {\n                        initialValues.forEach(function (v, k) { return _this.set(k, v); });\n                    }\n                    else {\n                        for (var k in initialValues) {\n                            this.set(k, initialValues[k]);\n                        }\n                    }\n                }\n            }\n            MapSchema.prototype.onAdd = function (callback, triggerAll) {\n                if (triggerAll === void 0) { triggerAll = true; }\n                return addCallback((this.$callbacks || (this.$callbacks = [])), exports.OPERATION.ADD, callback, (triggerAll)\n                    ? this.$items\n                    : undefined);\n            };\n            MapSchema.prototype.onRemove = function (callback) { return addCallback(this.$callbacks || (this.$callbacks = []), exports.OPERATION.DELETE, callback); };\n            MapSchema.prototype.onChange = function (callback) { return addCallback(this.$callbacks || (this.$callbacks = []), exports.OPERATION.REPLACE, callback); };\n            MapSchema.is = function (type) {\n                return type['map'] !== undefined;\n            };\n            /** Iterator */\n            MapSchema.prototype[Symbol.iterator] = function () { return this.$items[Symbol.iterator](); };\n            Object.defineProperty(MapSchema.prototype, Symbol.toStringTag, {\n                get: function () { return this.$items[Symbol.toStringTag]; },\n                enumerable: false,\n                configurable: true\n            });\n            MapSchema.prototype.set = function (key, value) {\n                if (value === undefined || value === null) {\n                    throw new Error(\"MapSchema#set('\".concat(key, \"', \").concat(value, \"): trying to set \").concat(value, \" value on '\").concat(key, \"'.\"));\n                }\n                // get \"index\" for this value.\n                var hasIndex = typeof (this.$changes.indexes[key]) !== \"undefined\";\n                var index = (hasIndex)\n                    ? this.$changes.indexes[key]\n                    : this.$refId++;\n                var operation = (hasIndex)\n                    ? exports.OPERATION.REPLACE\n                    : exports.OPERATION.ADD;\n                var isRef = (value['$changes']) !== undefined;\n                if (isRef) {\n                    value['$changes'].setParent(this, this.$changes.root, index);\n                }\n                //\n                // (encoding)\n                // set a unique id to relate directly with this key/value.\n                //\n                if (!hasIndex) {\n                    this.$changes.indexes[key] = index;\n                    this.$indexes.set(index, key);\n                }\n                else if (isRef && // if is schema, force ADD operation if value differ from previous one.\n                    this.$items.get(key) !== value) {\n                    operation = exports.OPERATION.ADD;\n                }\n                this.$items.set(key, value);\n                this.$changes.change(key, operation);\n                return this;\n            };\n            MapSchema.prototype.get = function (key) {\n                return this.$items.get(key);\n            };\n            MapSchema.prototype.delete = function (key) {\n                //\n                // TODO: add a \"purge\" method after .encode() runs, to cleanup removed `$indexes`\n                //\n                // We don't remove $indexes to allow setting the same key in the same patch\n                // (See \"should allow to remove and set an item in the same place\" test)\n                //\n                // // const index = this.$changes.indexes[key];\n                // // this.$indexes.delete(index);\n                this.$changes.delete(key);\n                return this.$items.delete(key);\n            };\n            MapSchema.prototype.clear = function (changes) {\n                // discard previous operations.\n                this.$changes.discard(true, true);\n                this.$changes.indexes = {};\n                // clear previous indexes\n                this.$indexes.clear();\n                //\n                // When decoding:\n                // - enqueue items for DELETE callback.\n                // - flag child items for garbage collection.\n                //\n                if (changes) {\n                    removeChildRefs.call(this, changes);\n                }\n                // clear items\n                this.$items.clear();\n                this.$changes.operation({ index: 0, op: exports.OPERATION.CLEAR });\n                // touch all structures until reach root\n                this.$changes.touchParents();\n            };\n            MapSchema.prototype.has = function (key) {\n                return this.$items.has(key);\n            };\n            MapSchema.prototype.forEach = function (callbackfn) {\n                this.$items.forEach(callbackfn);\n            };\n            MapSchema.prototype.entries = function () {\n                return this.$items.entries();\n            };\n            MapSchema.prototype.keys = function () {\n                return this.$items.keys();\n            };\n            MapSchema.prototype.values = function () {\n                return this.$items.values();\n            };\n            Object.defineProperty(MapSchema.prototype, \"size\", {\n                get: function () {\n                    return this.$items.size;\n                },\n                enumerable: false,\n                configurable: true\n            });\n            MapSchema.prototype.setIndex = function (index, key) {\n                this.$indexes.set(index, key);\n            };\n            MapSchema.prototype.getIndex = function (index) {\n                return this.$indexes.get(index);\n            };\n            MapSchema.prototype.getByIndex = function (index) {\n                return this.$items.get(this.$indexes.get(index));\n            };\n            MapSchema.prototype.deleteByIndex = function (index) {\n                var key = this.$indexes.get(index);\n                this.$items.delete(key);\n                this.$indexes.delete(index);\n            };\n            MapSchema.prototype.toJSON = function () {\n                var map = {};\n                this.forEach(function (value, key) {\n                    map[key] = (typeof (value['toJSON']) === \"function\")\n                        ? value['toJSON']()\n                        : value;\n                });\n                return map;\n            };\n            //\n            // Decoding utilities\n            //\n            MapSchema.prototype.clone = function (isDecoding) {\n                var cloned;\n                if (isDecoding) {\n                    // client-side\n                    cloned = Object.assign(new MapSchema(), this);\n                }\n                else {\n                    // server-side\n                    cloned = new MapSchema();\n                    this.forEach(function (value, key) {\n                        if (value['$changes']) {\n                            cloned.set(key, value['clone']());\n                        }\n                        else {\n                            cloned.set(key, value);\n                        }\n                    });\n                }\n                return cloned;\n            };\n            return MapSchema;\n        }());\n\n        var registeredTypes = {};\n        function registerType(identifier, definition) {\n            registeredTypes[identifier] = definition;\n        }\n        function getType(identifier) {\n            return registeredTypes[identifier];\n        }\n\n        var SchemaDefinition = /** @class */ (function () {\n            function SchemaDefinition() {\n                //\n                // TODO: use a \"field\" structure combining all these properties per-field.\n                //\n                this.indexes = {};\n                this.fieldsByIndex = {};\n                this.deprecated = {};\n                this.descriptors = {};\n            }\n            SchemaDefinition.create = function (parent) {\n                var definition = new SchemaDefinition();\n                // support inheritance\n                definition.schema = Object.assign({}, parent && parent.schema || {});\n                definition.indexes = Object.assign({}, parent && parent.indexes || {});\n                definition.fieldsByIndex = Object.assign({}, parent && parent.fieldsByIndex || {});\n                definition.descriptors = Object.assign({}, parent && parent.descriptors || {});\n                definition.deprecated = Object.assign({}, parent && parent.deprecated || {});\n                return definition;\n            };\n            SchemaDefinition.prototype.addField = function (field, type) {\n                var index = this.getNextFieldIndex();\n                this.fieldsByIndex[index] = field;\n                this.indexes[field] = index;\n                this.schema[field] = (Array.isArray(type))\n                    ? { array: type[0] }\n                    : type;\n            };\n            SchemaDefinition.prototype.hasField = function (field) {\n                return this.indexes[field] !== undefined;\n            };\n            SchemaDefinition.prototype.addFilter = function (field, cb) {\n                if (!this.filters) {\n                    this.filters = {};\n                    this.indexesWithFilters = [];\n                }\n                this.filters[this.indexes[field]] = cb;\n                this.indexesWithFilters.push(this.indexes[field]);\n                return true;\n            };\n            SchemaDefinition.prototype.addChildrenFilter = function (field, cb) {\n                var index = this.indexes[field];\n                var type = this.schema[field];\n                if (getType(Object.keys(type)[0])) {\n                    if (!this.childFilters) {\n                        this.childFilters = {};\n                    }\n                    this.childFilters[index] = cb;\n                    return true;\n                }\n                else {\n                    console.warn(\"@filterChildren: field '\".concat(field, \"' can't have children. Ignoring filter.\"));\n                }\n            };\n            SchemaDefinition.prototype.getChildrenFilter = function (field) {\n                return this.childFilters && this.childFilters[this.indexes[field]];\n            };\n            SchemaDefinition.prototype.getNextFieldIndex = function () {\n                return Object.keys(this.schema || {}).length;\n            };\n            return SchemaDefinition;\n        }());\n        function hasFilter(klass) {\n            return klass._context && klass._context.useFilters;\n        }\n        var Context = /** @class */ (function () {\n            function Context() {\n                this.types = {};\n                this.schemas = new Map();\n                this.useFilters = false;\n            }\n            Context.prototype.has = function (schema) {\n                return this.schemas.has(schema);\n            };\n            Context.prototype.get = function (typeid) {\n                return this.types[typeid];\n            };\n            Context.prototype.add = function (schema, typeid) {\n                if (typeid === void 0) { typeid = this.schemas.size; }\n                // FIXME: move this to somewhere else?\n                // support inheritance\n                schema._definition = SchemaDefinition.create(schema._definition);\n                schema._typeid = typeid;\n                this.types[typeid] = schema;\n                this.schemas.set(schema, typeid);\n            };\n            Context.create = function (options) {\n                if (options === void 0) { options = {}; }\n                return function (definition) {\n                    if (!options.context) {\n                        options.context = new Context();\n                    }\n                    return type(definition, options);\n                };\n            };\n            return Context;\n        }());\n        var globalContext = new Context();\n        /**\n         * [See documentation](https://docs.colyseus.io/state/schema/)\n         *\n         * Annotate a Schema property to be serializeable.\n         * \\@type()'d fields are automatically flagged as \"dirty\" for the next patch.\n         *\n         * @example Standard usage, with automatic change tracking.\n         * ```\n         * \\@type(\"string\") propertyName: string;\n         * ```\n         *\n         * @example You can provide the \"manual\" option if you'd like to manually control your patches via .setDirty().\n         * ```\n         * \\@type(\"string\", { manual: true })\n         * ```\n         */\n        function type(type, options) {\n            if (options === void 0) { options = {}; }\n            return function (target, field) {\n                var context = options.context || globalContext;\n                var constructor = target.constructor;\n                constructor._context = context;\n                if (!type) {\n                    throw new Error(\"\".concat(constructor.name, \": @type() reference provided for \\\"\").concat(field, \"\\\" is undefined. Make sure you don't have any circular dependencies.\"));\n                }\n                /*\n                 * static schema\n                 */\n                if (!context.has(constructor)) {\n                    context.add(constructor);\n                }\n                var definition = constructor._definition;\n                definition.addField(field, type);\n                /**\n                 * skip if descriptor already exists for this field (`@deprecated()`)\n                 */\n                if (definition.descriptors[field]) {\n                    if (definition.deprecated[field]) {\n                        // do not create accessors for deprecated properties.\n                        return;\n                    }\n                    else {\n                        // trying to define same property multiple times across inheritance.\n                        // https://github.com/colyseus/colyseus-unity3d/issues/131#issuecomment-814308572\n                        try {\n                            throw new Error(\"@colyseus/schema: Duplicate '\".concat(field, \"' definition on '\").concat(constructor.name, \"'.\\nCheck @type() annotation\"));\n                        }\n                        catch (e) {\n                            var definitionAtLine = e.stack.split(\"\\n\")[4].trim();\n                            throw new Error(\"\".concat(e.message, \" \").concat(definitionAtLine));\n                        }\n                    }\n                }\n                var isArray = ArraySchema.is(type);\n                var isMap = !isArray && MapSchema.is(type);\n                // TODO: refactor me.\n                // Allow abstract intermediary classes with no fields to be serialized\n                // (See \"should support an inheritance with a Schema type without fields\" test)\n                if (typeof (type) !== \"string\" && !Schema.is(type)) {\n                    var childType = Object.values(type)[0];\n                    if (typeof (childType) !== \"string\" && !context.has(childType)) {\n                        context.add(childType);\n                    }\n                }\n                if (options.manual) {\n                    // do not declare getter/setter descriptor\n                    definition.descriptors[field] = {\n                        enumerable: true,\n                        configurable: true,\n                        writable: true,\n                    };\n                    return;\n                }\n                var fieldCached = \"_\".concat(field);\n                definition.descriptors[fieldCached] = {\n                    enumerable: false,\n                    configurable: false,\n                    writable: true,\n                };\n                definition.descriptors[field] = {\n                    get: function () {\n                        return this[fieldCached];\n                    },\n                    set: function (value) {\n                        /**\n                         * Create Proxy for array or map items\n                         */\n                        // skip if value is the same as cached.\n                        if (value === this[fieldCached]) {\n                            return;\n                        }\n                        if (value !== undefined &&\n                            value !== null) {\n                            // automaticallty transform Array into ArraySchema\n                            if (isArray && !(value instanceof ArraySchema)) {\n                                value = new (ArraySchema.bind.apply(ArraySchema, __spreadArray([void 0], value, false)))();\n                            }\n                            // automaticallty transform Map into MapSchema\n                            if (isMap && !(value instanceof MapSchema)) {\n                                value = new MapSchema(value);\n                            }\n                            // try to turn provided structure into a Proxy\n                            if (value['$proxy'] === undefined) {\n                                if (isMap) {\n                                    value = getMapProxy(value);\n                                }\n                                else if (isArray) {\n                                    value = getArrayProxy(value);\n                                }\n                            }\n                            // flag the change for encoding.\n                            this.$changes.change(field);\n                            //\n                            // call setParent() recursively for this and its child\n                            // structures.\n                            //\n                            if (value['$changes']) {\n                                value['$changes'].setParent(this, this.$changes.root, this._definition.indexes[field]);\n                            }\n                        }\n                        else if (this[fieldCached]) {\n                            //\n                            // Setting a field to `null` or `undefined` will delete it.\n                            //\n                            this.$changes.delete(field);\n                        }\n                        this[fieldCached] = value;\n                    },\n                    enumerable: true,\n                    configurable: true\n                };\n            };\n        }\n        /**\n         * `@filter()` decorator for defining data filters per client\n         */\n        function filter(cb) {\n            return function (target, field) {\n                var constructor = target.constructor;\n                var definition = constructor._definition;\n                if (definition.addFilter(field, cb)) {\n                    constructor._context.useFilters = true;\n                }\n            };\n        }\n        function filterChildren(cb) {\n            return function (target, field) {\n                var constructor = target.constructor;\n                var definition = constructor._definition;\n                if (definition.addChildrenFilter(field, cb)) {\n                    constructor._context.useFilters = true;\n                }\n            };\n        }\n        /**\n         * `@deprecated()` flag a field as deprecated.\n         * The previous `@type()` annotation should remain along with this one.\n         */\n        function deprecated(throws) {\n            if (throws === void 0) { throws = true; }\n            return function (target, field) {\n                var constructor = target.constructor;\n                var definition = constructor._definition;\n                definition.deprecated[field] = true;\n                if (throws) {\n                    definition.descriptors[field] = {\n                        get: function () { throw new Error(\"\".concat(field, \" is deprecated.\")); },\n                        set: function (value) { },\n                        enumerable: false,\n                        configurable: true\n                    };\n                }\n            };\n        }\n        function defineTypes(target, fields, options) {\n            if (options === void 0) { options = {}; }\n            if (!options.context) {\n                options.context = target._context || options.context || globalContext;\n            }\n            for (var field in fields) {\n                type(fields[field], options)(target.prototype, field);\n            }\n            return target;\n        }\n\n        /**\n         * Copyright (c) 2018 Endel Dreyer\n         * Copyright (c) 2014 Ion Drive Software Ltd.\n         *\n         * Permission is hereby granted, free of charge, to any person obtaining a copy\n         * of this software and associated documentation files (the \"Software\"), to deal\n         * in the Software without restriction, including without limitation the rights\n         * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n         * copies of the Software, and to permit persons to whom the Software is\n         * furnished to do so, subject to the following conditions:\n         *\n         * The above copyright notice and this permission notice shall be included in all\n         * copies or substantial portions of the Software.\n         *\n         * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n         * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n         * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n         * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n         * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n         * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n         * SOFTWARE\n         */\n        /**\n         * msgpack implementation highly based on notepack.io\n         * https://github.com/darrachequesne/notepack\n         */\n        function utf8Length(str) {\n            var c = 0, length = 0;\n            for (var i = 0, l = str.length; i < l; i++) {\n                c = str.charCodeAt(i);\n                if (c < 0x80) {\n                    length += 1;\n                }\n                else if (c < 0x800) {\n                    length += 2;\n                }\n                else if (c < 0xd800 || c >= 0xe000) {\n                    length += 3;\n                }\n                else {\n                    i++;\n                    length += 4;\n                }\n            }\n            return length;\n        }\n        function utf8Write(view, offset, str) {\n            var c = 0;\n            for (var i = 0, l = str.length; i < l; i++) {\n                c = str.charCodeAt(i);\n                if (c < 0x80) {\n                    view[offset++] = c;\n                }\n                else if (c < 0x800) {\n                    view[offset++] = 0xc0 | (c >> 6);\n                    view[offset++] = 0x80 | (c & 0x3f);\n                }\n                else if (c < 0xd800 || c >= 0xe000) {\n                    view[offset++] = 0xe0 | (c >> 12);\n                    view[offset++] = 0x80 | (c >> 6 & 0x3f);\n                    view[offset++] = 0x80 | (c & 0x3f);\n                }\n                else {\n                    i++;\n                    c = 0x10000 + (((c & 0x3ff) << 10) | (str.charCodeAt(i) & 0x3ff));\n                    view[offset++] = 0xf0 | (c >> 18);\n                    view[offset++] = 0x80 | (c >> 12 & 0x3f);\n                    view[offset++] = 0x80 | (c >> 6 & 0x3f);\n                    view[offset++] = 0x80 | (c & 0x3f);\n                }\n            }\n        }\n        function int8$1(bytes, value) {\n            bytes.push(value & 255);\n        }\n        function uint8$1(bytes, value) {\n            bytes.push(value & 255);\n        }\n        function int16$1(bytes, value) {\n            bytes.push(value & 255);\n            bytes.push((value >> 8) & 255);\n        }\n        function uint16$1(bytes, value) {\n            bytes.push(value & 255);\n            bytes.push((value >> 8) & 255);\n        }\n        function int32$1(bytes, value) {\n            bytes.push(value & 255);\n            bytes.push((value >> 8) & 255);\n            bytes.push((value >> 16) & 255);\n            bytes.push((value >> 24) & 255);\n        }\n        function uint32$1(bytes, value) {\n            var b4 = value >> 24;\n            var b3 = value >> 16;\n            var b2 = value >> 8;\n            var b1 = value;\n            bytes.push(b1 & 255);\n            bytes.push(b2 & 255);\n            bytes.push(b3 & 255);\n            bytes.push(b4 & 255);\n        }\n        function int64$1(bytes, value) {\n            var high = Math.floor(value / Math.pow(2, 32));\n            var low = value >>> 0;\n            uint32$1(bytes, low);\n            uint32$1(bytes, high);\n        }\n        function uint64$1(bytes, value) {\n            var high = (value / Math.pow(2, 32)) >> 0;\n            var low = value >>> 0;\n            uint32$1(bytes, low);\n            uint32$1(bytes, high);\n        }\n        function float32$1(bytes, value) {\n            writeFloat32(bytes, value);\n        }\n        function float64$1(bytes, value) {\n            writeFloat64(bytes, value);\n        }\n        var _int32$1 = new Int32Array(2);\n        var _float32$1 = new Float32Array(_int32$1.buffer);\n        var _float64$1 = new Float64Array(_int32$1.buffer);\n        function writeFloat32(bytes, value) {\n            _float32$1[0] = value;\n            int32$1(bytes, _int32$1[0]);\n        }\n        function writeFloat64(bytes, value) {\n            _float64$1[0] = value;\n            int32$1(bytes, _int32$1[0 ]);\n            int32$1(bytes, _int32$1[1 ]);\n        }\n        function boolean$1(bytes, value) {\n            return uint8$1(bytes, value ? 1 : 0);\n        }\n        function string$1(bytes, value) {\n            // encode `null` strings as empty.\n            if (!value) {\n                value = \"\";\n            }\n            var length = utf8Length(value);\n            var size = 0;\n            // fixstr\n            if (length < 0x20) {\n                bytes.push(length | 0xa0);\n                size = 1;\n            }\n            // str 8\n            else if (length < 0x100) {\n                bytes.push(0xd9);\n                uint8$1(bytes, length);\n                size = 2;\n            }\n            // str 16\n            else if (length < 0x10000) {\n                bytes.push(0xda);\n                uint16$1(bytes, length);\n                size = 3;\n            }\n            // str 32\n            else if (length < 0x100000000) {\n                bytes.push(0xdb);\n                uint32$1(bytes, length);\n                size = 5;\n            }\n            else {\n                throw new Error('String too long');\n            }\n            utf8Write(bytes, bytes.length, value);\n            return size + length;\n        }\n        function number$1(bytes, value) {\n            if (isNaN(value)) {\n                return number$1(bytes, 0);\n            }\n            else if (!isFinite(value)) {\n                return number$1(bytes, (value > 0) ? Number.MAX_SAFE_INTEGER : -Number.MAX_SAFE_INTEGER);\n            }\n            else if (value !== (value | 0)) {\n                bytes.push(0xcb);\n                writeFloat64(bytes, value);\n                return 9;\n                // TODO: encode float 32?\n                // is it possible to differentiate between float32 / float64 here?\n                // // float 32\n                // bytes.push(0xca);\n                // writeFloat32(bytes, value);\n                // return 5;\n            }\n            if (value >= 0) {\n                // positive fixnum\n                if (value < 0x80) {\n                    uint8$1(bytes, value);\n                    return 1;\n                }\n                // uint 8\n                if (value < 0x100) {\n                    bytes.push(0xcc);\n                    uint8$1(bytes, value);\n                    return 2;\n                }\n                // uint 16\n                if (value < 0x10000) {\n                    bytes.push(0xcd);\n                    uint16$1(bytes, value);\n                    return 3;\n                }\n                // uint 32\n                if (value < 0x100000000) {\n                    bytes.push(0xce);\n                    uint32$1(bytes, value);\n                    return 5;\n                }\n                // uint 64\n                bytes.push(0xcf);\n                uint64$1(bytes, value);\n                return 9;\n            }\n            else {\n                // negative fixnum\n                if (value >= -0x20) {\n                    bytes.push(0xe0 | (value + 0x20));\n                    return 1;\n                }\n                // int 8\n                if (value >= -0x80) {\n                    bytes.push(0xd0);\n                    int8$1(bytes, value);\n                    return 2;\n                }\n                // int 16\n                if (value >= -0x8000) {\n                    bytes.push(0xd1);\n                    int16$1(bytes, value);\n                    return 3;\n                }\n                // int 32\n                if (value >= -0x80000000) {\n                    bytes.push(0xd2);\n                    int32$1(bytes, value);\n                    return 5;\n                }\n                // int 64\n                bytes.push(0xd3);\n                int64$1(bytes, value);\n                return 9;\n            }\n        }\n\n        var encode = /*#__PURE__*/Object.freeze({\n            __proto__: null,\n            utf8Write: utf8Write,\n            int8: int8$1,\n            uint8: uint8$1,\n            int16: int16$1,\n            uint16: uint16$1,\n            int32: int32$1,\n            uint32: uint32$1,\n            int64: int64$1,\n            uint64: uint64$1,\n            float32: float32$1,\n            float64: float64$1,\n            writeFloat32: writeFloat32,\n            writeFloat64: writeFloat64,\n            boolean: boolean$1,\n            string: string$1,\n            number: number$1\n        });\n\n        /**\n         * Copyright (c) 2018 Endel Dreyer\n         * Copyright (c) 2014 Ion Drive Software Ltd.\n         *\n         * Permission is hereby granted, free of charge, to any person obtaining a copy\n         * of this software and associated documentation files (the \"Software\"), to deal\n         * in the Software without restriction, including without limitation the rights\n         * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n         * copies of the Software, and to permit persons to whom the Software is\n         * furnished to do so, subject to the following conditions:\n         *\n         * The above copyright notice and this permission notice shall be included in all\n         * copies or substantial portions of the Software.\n         *\n         * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n         * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n         * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n         * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n         * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n         * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n         * SOFTWARE\n         */\n        function utf8Read(bytes, offset, length) {\n            var string = '', chr = 0;\n            for (var i = offset, end = offset + length; i < end; i++) {\n                var byte = bytes[i];\n                if ((byte & 0x80) === 0x00) {\n                    string += String.fromCharCode(byte);\n                    continue;\n                }\n                if ((byte & 0xe0) === 0xc0) {\n                    string += String.fromCharCode(((byte & 0x1f) << 6) |\n                        (bytes[++i] & 0x3f));\n                    continue;\n                }\n                if ((byte & 0xf0) === 0xe0) {\n                    string += String.fromCharCode(((byte & 0x0f) << 12) |\n                        ((bytes[++i] & 0x3f) << 6) |\n                        ((bytes[++i] & 0x3f) << 0));\n                    continue;\n                }\n                if ((byte & 0xf8) === 0xf0) {\n                    chr = ((byte & 0x07) << 18) |\n                        ((bytes[++i] & 0x3f) << 12) |\n                        ((bytes[++i] & 0x3f) << 6) |\n                        ((bytes[++i] & 0x3f) << 0);\n                    if (chr >= 0x010000) { // surrogate pair\n                        chr -= 0x010000;\n                        string += String.fromCharCode((chr >>> 10) + 0xD800, (chr & 0x3FF) + 0xDC00);\n                    }\n                    else {\n                        string += String.fromCharCode(chr);\n                    }\n                    continue;\n                }\n                console.error('Invalid byte ' + byte.toString(16));\n                // (do not throw error to avoid server/client from crashing due to hack attemps)\n                // throw new Error('Invalid byte ' + byte.toString(16));\n            }\n            return string;\n        }\n        function int8(bytes, it) {\n            return uint8(bytes, it) << 24 >> 24;\n        }\n        function uint8(bytes, it) {\n            return bytes[it.offset++];\n        }\n        function int16(bytes, it) {\n            return uint16(bytes, it) << 16 >> 16;\n        }\n        function uint16(bytes, it) {\n            return bytes[it.offset++] | bytes[it.offset++] << 8;\n        }\n        function int32(bytes, it) {\n            return bytes[it.offset++] | bytes[it.offset++] << 8 | bytes[it.offset++] << 16 | bytes[it.offset++] << 24;\n        }\n        function uint32(bytes, it) {\n            return int32(bytes, it) >>> 0;\n        }\n        function float32(bytes, it) {\n            return readFloat32(bytes, it);\n        }\n        function float64(bytes, it) {\n            return readFloat64(bytes, it);\n        }\n        function int64(bytes, it) {\n            var low = uint32(bytes, it);\n            var high = int32(bytes, it) * Math.pow(2, 32);\n            return high + low;\n        }\n        function uint64(bytes, it) {\n            var low = uint32(bytes, it);\n            var high = uint32(bytes, it) * Math.pow(2, 32);\n            return high + low;\n        }\n        var _int32 = new Int32Array(2);\n        var _float32 = new Float32Array(_int32.buffer);\n        var _float64 = new Float64Array(_int32.buffer);\n        function readFloat32(bytes, it) {\n            _int32[0] = int32(bytes, it);\n            return _float32[0];\n        }\n        function readFloat64(bytes, it) {\n            _int32[0 ] = int32(bytes, it);\n            _int32[1 ] = int32(bytes, it);\n            return _float64[0];\n        }\n        function boolean(bytes, it) {\n            return uint8(bytes, it) > 0;\n        }\n        function string(bytes, it) {\n            var prefix = bytes[it.offset++];\n            var length;\n            if (prefix < 0xc0) {\n                // fixstr\n                length = prefix & 0x1f;\n            }\n            else if (prefix === 0xd9) {\n                length = uint8(bytes, it);\n            }\n            else if (prefix === 0xda) {\n                length = uint16(bytes, it);\n            }\n            else if (prefix === 0xdb) {\n                length = uint32(bytes, it);\n            }\n            var value = utf8Read(bytes, it.offset, length);\n            it.offset += length;\n            return value;\n        }\n        function stringCheck(bytes, it) {\n            var prefix = bytes[it.offset];\n            return (\n            // fixstr\n            (prefix < 0xc0 && prefix > 0xa0) ||\n                // str 8\n                prefix === 0xd9 ||\n                // str 16\n                prefix === 0xda ||\n                // str 32\n                prefix === 0xdb);\n        }\n        function number(bytes, it) {\n            var prefix = bytes[it.offset++];\n            if (prefix < 0x80) {\n                // positive fixint\n                return prefix;\n            }\n            else if (prefix === 0xca) {\n                // float 32\n                return readFloat32(bytes, it);\n            }\n            else if (prefix === 0xcb) {\n                // float 64\n                return readFloat64(bytes, it);\n            }\n            else if (prefix === 0xcc) {\n                // uint 8\n                return uint8(bytes, it);\n            }\n            else if (prefix === 0xcd) {\n                // uint 16\n                return uint16(bytes, it);\n            }\n            else if (prefix === 0xce) {\n                // uint 32\n                return uint32(bytes, it);\n            }\n            else if (prefix === 0xcf) {\n                // uint 64\n                return uint64(bytes, it);\n            }\n            else if (prefix === 0xd0) {\n                // int 8\n                return int8(bytes, it);\n            }\n            else if (prefix === 0xd1) {\n                // int 16\n                return int16(bytes, it);\n            }\n            else if (prefix === 0xd2) {\n                // int 32\n                return int32(bytes, it);\n            }\n            else if (prefix === 0xd3) {\n                // int 64\n                return int64(bytes, it);\n            }\n            else if (prefix > 0xdf) {\n                // negative fixint\n                return (0xff - prefix + 1) * -1;\n            }\n        }\n        function numberCheck(bytes, it) {\n            var prefix = bytes[it.offset];\n            // positive fixint - 0x00 - 0x7f\n            // float 32        - 0xca\n            // float 64        - 0xcb\n            // uint 8          - 0xcc\n            // uint 16         - 0xcd\n            // uint 32         - 0xce\n            // uint 64         - 0xcf\n            // int 8           - 0xd0\n            // int 16          - 0xd1\n            // int 32          - 0xd2\n            // int 64          - 0xd3\n            return (prefix < 0x80 ||\n                (prefix >= 0xca && prefix <= 0xd3));\n        }\n        function arrayCheck(bytes, it) {\n            return bytes[it.offset] < 0xa0;\n            // const prefix = bytes[it.offset] ;\n            // if (prefix < 0xa0) {\n            //   return prefix;\n            // // array\n            // } else if (prefix === 0xdc) {\n            //   it.offset += 2;\n            // } else if (0xdd) {\n            //   it.offset += 4;\n            // }\n            // return prefix;\n        }\n        function switchStructureCheck(bytes, it) {\n            return (\n            // previous byte should be `SWITCH_TO_STRUCTURE`\n            bytes[it.offset - 1] === SWITCH_TO_STRUCTURE &&\n                // next byte should be a number\n                (bytes[it.offset] < 0x80 || (bytes[it.offset] >= 0xca && bytes[it.offset] <= 0xd3)));\n        }\n\n        var decode = /*#__PURE__*/Object.freeze({\n            __proto__: null,\n            int8: int8,\n            uint8: uint8,\n            int16: int16,\n            uint16: uint16,\n            int32: int32,\n            uint32: uint32,\n            float32: float32,\n            float64: float64,\n            int64: int64,\n            uint64: uint64,\n            readFloat32: readFloat32,\n            readFloat64: readFloat64,\n            boolean: boolean,\n            string: string,\n            stringCheck: stringCheck,\n            number: number,\n            numberCheck: numberCheck,\n            arrayCheck: arrayCheck,\n            switchStructureCheck: switchStructureCheck\n        });\n\n        var CollectionSchema = /** @class */ (function () {\n            function CollectionSchema(initialValues) {\n                var _this = this;\n                this.$changes = new ChangeTree(this);\n                this.$items = new Map();\n                this.$indexes = new Map();\n                this.$refId = 0;\n                if (initialValues) {\n                    initialValues.forEach(function (v) { return _this.add(v); });\n                }\n            }\n            CollectionSchema.prototype.onAdd = function (callback, triggerAll) {\n                if (triggerAll === void 0) { triggerAll = true; }\n                return addCallback((this.$callbacks || (this.$callbacks = [])), exports.OPERATION.ADD, callback, (triggerAll)\n                    ? this.$items\n                    : undefined);\n            };\n            CollectionSchema.prototype.onRemove = function (callback) { return addCallback(this.$callbacks || (this.$callbacks = []), exports.OPERATION.DELETE, callback); };\n            CollectionSchema.prototype.onChange = function (callback) { return addCallback(this.$callbacks || (this.$callbacks = []), exports.OPERATION.REPLACE, callback); };\n            CollectionSchema.is = function (type) {\n                return type['collection'] !== undefined;\n            };\n            CollectionSchema.prototype.add = function (value) {\n                // set \"index\" for reference.\n                var index = this.$refId++;\n                var isRef = (value['$changes']) !== undefined;\n                if (isRef) {\n                    value['$changes'].setParent(this, this.$changes.root, index);\n                }\n                this.$changes.indexes[index] = index;\n                this.$indexes.set(index, index);\n                this.$items.set(index, value);\n                this.$changes.change(index);\n                return index;\n            };\n            CollectionSchema.prototype.at = function (index) {\n                var key = Array.from(this.$items.keys())[index];\n                return this.$items.get(key);\n            };\n            CollectionSchema.prototype.entries = function () {\n                return this.$items.entries();\n            };\n            CollectionSchema.prototype.delete = function (item) {\n                var entries = this.$items.entries();\n                var index;\n                var entry;\n                while (entry = entries.next()) {\n                    if (entry.done) {\n                        break;\n                    }\n                    if (item === entry.value[1]) {\n                        index = entry.value[0];\n                        break;\n                    }\n                }\n                if (index === undefined) {\n                    return false;\n                }\n                this.$changes.delete(index);\n                this.$indexes.delete(index);\n                return this.$items.delete(index);\n            };\n            CollectionSchema.prototype.clear = function (changes) {\n                // discard previous operations.\n                this.$changes.discard(true, true);\n                this.$changes.indexes = {};\n                // clear previous indexes\n                this.$indexes.clear();\n                //\n                // When decoding:\n                // - enqueue items for DELETE callback.\n                // - flag child items for garbage collection.\n                //\n                if (changes) {\n                    removeChildRefs.call(this, changes);\n                }\n                // clear items\n                this.$items.clear();\n                this.$changes.operation({ index: 0, op: exports.OPERATION.CLEAR });\n                // touch all structures until reach root\n                this.$changes.touchParents();\n            };\n            CollectionSchema.prototype.has = function (value) {\n                return Array.from(this.$items.values()).some(function (v) { return v === value; });\n            };\n            CollectionSchema.prototype.forEach = function (callbackfn) {\n                var _this = this;\n                this.$items.forEach(function (value, key, _) { return callbackfn(value, key, _this); });\n            };\n            CollectionSchema.prototype.values = function () {\n                return this.$items.values();\n            };\n            Object.defineProperty(CollectionSchema.prototype, \"size\", {\n                get: function () {\n                    return this.$items.size;\n                },\n                enumerable: false,\n                configurable: true\n            });\n            CollectionSchema.prototype.setIndex = function (index, key) {\n                this.$indexes.set(index, key);\n            };\n            CollectionSchema.prototype.getIndex = function (index) {\n                return this.$indexes.get(index);\n            };\n            CollectionSchema.prototype.getByIndex = function (index) {\n                return this.$items.get(this.$indexes.get(index));\n            };\n            CollectionSchema.prototype.deleteByIndex = function (index) {\n                var key = this.$indexes.get(index);\n                this.$items.delete(key);\n                this.$indexes.delete(index);\n            };\n            CollectionSchema.prototype.toArray = function () {\n                return Array.from(this.$items.values());\n            };\n            CollectionSchema.prototype.toJSON = function () {\n                var values = [];\n                this.forEach(function (value, key) {\n                    values.push((typeof (value['toJSON']) === \"function\")\n                        ? value['toJSON']()\n                        : value);\n                });\n                return values;\n            };\n            //\n            // Decoding utilities\n            //\n            CollectionSchema.prototype.clone = function (isDecoding) {\n                var cloned;\n                if (isDecoding) {\n                    // client-side\n                    cloned = Object.assign(new CollectionSchema(), this);\n                }\n                else {\n                    // server-side\n                    cloned = new CollectionSchema();\n                    this.forEach(function (value) {\n                        if (value['$changes']) {\n                            cloned.add(value['clone']());\n                        }\n                        else {\n                            cloned.add(value);\n                        }\n                    });\n                }\n                return cloned;\n            };\n            return CollectionSchema;\n        }());\n\n        var SetSchema = /** @class */ (function () {\n            function SetSchema(initialValues) {\n                var _this = this;\n                this.$changes = new ChangeTree(this);\n                this.$items = new Map();\n                this.$indexes = new Map();\n                this.$refId = 0;\n                if (initialValues) {\n                    initialValues.forEach(function (v) { return _this.add(v); });\n                }\n            }\n            SetSchema.prototype.onAdd = function (callback, triggerAll) {\n                if (triggerAll === void 0) { triggerAll = true; }\n                return addCallback((this.$callbacks || (this.$callbacks = [])), exports.OPERATION.ADD, callback, (triggerAll)\n                    ? this.$items\n                    : undefined);\n            };\n            SetSchema.prototype.onRemove = function (callback) { return addCallback(this.$callbacks || (this.$callbacks = []), exports.OPERATION.DELETE, callback); };\n            SetSchema.prototype.onChange = function (callback) { return addCallback(this.$callbacks || (this.$callbacks = []), exports.OPERATION.REPLACE, callback); };\n            SetSchema.is = function (type) {\n                return type['set'] !== undefined;\n            };\n            SetSchema.prototype.add = function (value) {\n                var _a, _b;\n                // immediatelly return false if value already added.\n                if (this.has(value)) {\n                    return false;\n                }\n                // set \"index\" for reference.\n                var index = this.$refId++;\n                if ((value['$changes']) !== undefined) {\n                    value['$changes'].setParent(this, this.$changes.root, index);\n                }\n                var operation = (_b = (_a = this.$changes.indexes[index]) === null || _a === void 0 ? void 0 : _a.op) !== null && _b !== void 0 ? _b : exports.OPERATION.ADD;\n                this.$changes.indexes[index] = index;\n                this.$indexes.set(index, index);\n                this.$items.set(index, value);\n                this.$changes.change(index, operation);\n                return index;\n            };\n            SetSchema.prototype.entries = function () {\n                return this.$items.entries();\n            };\n            SetSchema.prototype.delete = function (item) {\n                var entries = this.$items.entries();\n                var index;\n                var entry;\n                while (entry = entries.next()) {\n                    if (entry.done) {\n                        break;\n                    }\n                    if (item === entry.value[1]) {\n                        index = entry.value[0];\n                        break;\n                    }\n                }\n                if (index === undefined) {\n                    return false;\n                }\n                this.$changes.delete(index);\n                this.$indexes.delete(index);\n                return this.$items.delete(index);\n            };\n            SetSchema.prototype.clear = function (changes) {\n                // discard previous operations.\n                this.$changes.discard(true, true);\n                this.$changes.indexes = {};\n                // clear previous indexes\n                this.$indexes.clear();\n                //\n                // When decoding:\n                // - enqueue items for DELETE callback.\n                // - flag child items for garbage collection.\n                //\n                if (changes) {\n                    removeChildRefs.call(this, changes);\n                }\n                // clear items\n                this.$items.clear();\n                this.$changes.operation({ index: 0, op: exports.OPERATION.CLEAR });\n                // touch all structures until reach root\n                this.$changes.touchParents();\n            };\n            SetSchema.prototype.has = function (value) {\n                var values = this.$items.values();\n                var has = false;\n                var entry;\n                while (entry = values.next()) {\n                    if (entry.done) {\n                        break;\n                    }\n                    if (value === entry.value) {\n                        has = true;\n                        break;\n                    }\n                }\n                return has;\n            };\n            SetSchema.prototype.forEach = function (callbackfn) {\n                var _this = this;\n                this.$items.forEach(function (value, key, _) { return callbackfn(value, key, _this); });\n            };\n            SetSchema.prototype.values = function () {\n                return this.$items.values();\n            };\n            Object.defineProperty(SetSchema.prototype, \"size\", {\n                get: function () {\n                    return this.$items.size;\n                },\n                enumerable: false,\n                configurable: true\n            });\n            SetSchema.prototype.setIndex = function (index, key) {\n                this.$indexes.set(index, key);\n            };\n            SetSchema.prototype.getIndex = function (index) {\n                return this.$indexes.get(index);\n            };\n            SetSchema.prototype.getByIndex = function (index) {\n                return this.$items.get(this.$indexes.get(index));\n            };\n            SetSchema.prototype.deleteByIndex = function (index) {\n                var key = this.$indexes.get(index);\n                this.$items.delete(key);\n                this.$indexes.delete(index);\n            };\n            SetSchema.prototype.toArray = function () {\n                return Array.from(this.$items.values());\n            };\n            SetSchema.prototype.toJSON = function () {\n                var values = [];\n                this.forEach(function (value, key) {\n                    values.push((typeof (value['toJSON']) === \"function\")\n                        ? value['toJSON']()\n                        : value);\n                });\n                return values;\n            };\n            //\n            // Decoding utilities\n            //\n            SetSchema.prototype.clone = function (isDecoding) {\n                var cloned;\n                if (isDecoding) {\n                    // client-side\n                    cloned = Object.assign(new SetSchema(), this);\n                }\n                else {\n                    // server-side\n                    cloned = new SetSchema();\n                    this.forEach(function (value) {\n                        if (value['$changes']) {\n                            cloned.add(value['clone']());\n                        }\n                        else {\n                            cloned.add(value);\n                        }\n                    });\n                }\n                return cloned;\n            };\n            return SetSchema;\n        }());\n\n        var ClientState = /** @class */ (function () {\n            function ClientState() {\n                this.refIds = new WeakSet();\n                this.containerIndexes = new WeakMap();\n            }\n            // containerIndexes = new Map<ChangeTree, Set<number>>();\n            ClientState.prototype.addRefId = function (changeTree) {\n                if (!this.refIds.has(changeTree)) {\n                    this.refIds.add(changeTree);\n                    this.containerIndexes.set(changeTree, new Set());\n                }\n            };\n            ClientState.get = function (client) {\n                if (client.$filterState === undefined) {\n                    client.$filterState = new ClientState();\n                }\n                return client.$filterState;\n            };\n            return ClientState;\n        }());\n\n        var ReferenceTracker = /** @class */ (function () {\n            function ReferenceTracker() {\n                //\n                // Relation of refId => Schema structure\n                // For direct access of structures during decoding time.\n                //\n                this.refs = new Map();\n                this.refCounts = {};\n                this.deletedRefs = new Set();\n                this.nextUniqueId = 0;\n            }\n            ReferenceTracker.prototype.getNextUniqueId = function () {\n                return this.nextUniqueId++;\n            };\n            // for decoding\n            ReferenceTracker.prototype.addRef = function (refId, ref, incrementCount) {\n                if (incrementCount === void 0) { incrementCount = true; }\n                this.refs.set(refId, ref);\n                if (incrementCount) {\n                    this.refCounts[refId] = (this.refCounts[refId] || 0) + 1;\n                }\n            };\n            // for decoding\n            ReferenceTracker.prototype.removeRef = function (refId) {\n                this.refCounts[refId] = this.refCounts[refId] - 1;\n                this.deletedRefs.add(refId);\n            };\n            ReferenceTracker.prototype.clearRefs = function () {\n                this.refs.clear();\n                this.deletedRefs.clear();\n                this.refCounts = {};\n            };\n            // for decoding\n            ReferenceTracker.prototype.garbageCollectDeletedRefs = function () {\n                var _this = this;\n                this.deletedRefs.forEach(function (refId) {\n                    //\n                    // Skip active references.\n                    //\n                    if (_this.refCounts[refId] > 0) {\n                        return;\n                    }\n                    var ref = _this.refs.get(refId);\n                    //\n                    // Ensure child schema instances have their references removed as well.\n                    //\n                    if (ref instanceof Schema) {\n                        for (var fieldName in ref['_definition'].schema) {\n                            if (typeof (ref['_definition'].schema[fieldName]) !== \"string\" &&\n                                ref[fieldName] &&\n                                ref[fieldName]['$changes']) {\n                                _this.removeRef(ref[fieldName]['$changes'].refId);\n                            }\n                        }\n                    }\n                    else {\n                        var definition = ref['$changes'].parent._definition;\n                        var type = definition.schema[definition.fieldsByIndex[ref['$changes'].parentIndex]];\n                        if (typeof (Object.values(type)[0]) === \"function\") {\n                            Array.from(ref.values())\n                                .forEach(function (child) { return _this.removeRef(child['$changes'].refId); });\n                        }\n                    }\n                    _this.refs.delete(refId);\n                    delete _this.refCounts[refId];\n                });\n                // clear deleted refs.\n                this.deletedRefs.clear();\n            };\n            return ReferenceTracker;\n        }());\n\n        var EncodeSchemaError = /** @class */ (function (_super) {\n            __extends(EncodeSchemaError, _super);\n            function EncodeSchemaError() {\n                return _super !== null && _super.apply(this, arguments) || this;\n            }\n            return EncodeSchemaError;\n        }(Error));\n        function assertType(value, type, klass, field) {\n            var typeofTarget;\n            var allowNull = false;\n            switch (type) {\n                case \"number\":\n                case \"int8\":\n                case \"uint8\":\n                case \"int16\":\n                case \"uint16\":\n                case \"int32\":\n                case \"uint32\":\n                case \"int64\":\n                case \"uint64\":\n                case \"float32\":\n                case \"float64\":\n                    typeofTarget = \"number\";\n                    if (isNaN(value)) {\n                        console.log(\"trying to encode \\\"NaN\\\" in \".concat(klass.constructor.name, \"#\").concat(field));\n                    }\n                    break;\n                case \"string\":\n                    typeofTarget = \"string\";\n                    allowNull = true;\n                    break;\n                case \"boolean\":\n                    // boolean is always encoded as true/false based on truthiness\n                    return;\n            }\n            if (typeof (value) !== typeofTarget && (!allowNull || (allowNull && value !== null))) {\n                var foundValue = \"'\".concat(JSON.stringify(value), \"'\").concat((value && value.constructor && \" (\".concat(value.constructor.name, \")\")) || '');\n                throw new EncodeSchemaError(\"a '\".concat(typeofTarget, \"' was expected, but \").concat(foundValue, \" was provided in \").concat(klass.constructor.name, \"#\").concat(field));\n            }\n        }\n        function assertInstanceType(value, type, klass, field) {\n            if (!(value instanceof type)) {\n                throw new EncodeSchemaError(\"a '\".concat(type.name, \"' was expected, but '\").concat(value.constructor.name, \"' was provided in \").concat(klass.constructor.name, \"#\").concat(field));\n            }\n        }\n        function encodePrimitiveType(type, bytes, value, klass, field) {\n            assertType(value, type, klass, field);\n            var encodeFunc = encode[type];\n            if (encodeFunc) {\n                encodeFunc(bytes, value);\n            }\n            else {\n                throw new EncodeSchemaError(\"a '\".concat(type, \"' was expected, but \").concat(value, \" was provided in \").concat(klass.constructor.name, \"#\").concat(field));\n            }\n        }\n        function decodePrimitiveType(type, bytes, it) {\n            return decode[type](bytes, it);\n        }\n        /**\n         * Schema encoder / decoder\n         */\n        var Schema = /** @class */ (function () {\n            // allow inherited classes to have a constructor\n            function Schema() {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                // fix enumerability of fields for end-user\n                Object.defineProperties(this, {\n                    $changes: {\n                        value: new ChangeTree(this, undefined, new ReferenceTracker()),\n                        enumerable: false,\n                        writable: true\n                    },\n                    // $listeners: {\n                    //     value: undefined,\n                    //     enumerable: false,\n                    //     writable: true\n                    // },\n                    $callbacks: {\n                        value: undefined,\n                        enumerable: false,\n                        writable: true\n                    },\n                });\n                var descriptors = this._definition.descriptors;\n                if (descriptors) {\n                    Object.defineProperties(this, descriptors);\n                }\n                //\n                // Assign initial values\n                //\n                if (args[0]) {\n                    this.assign(args[0]);\n                }\n            }\n            Schema.onError = function (e) {\n                console.error(e);\n            };\n            Schema.is = function (type) {\n                return (type['_definition'] &&\n                    type['_definition'].schema !== undefined);\n            };\n            Schema.prototype.onChange = function (callback) {\n                return addCallback((this.$callbacks || (this.$callbacks = [])), exports.OPERATION.REPLACE, callback);\n            };\n            Schema.prototype.onRemove = function (callback) {\n                return addCallback((this.$callbacks || (this.$callbacks = [])), exports.OPERATION.DELETE, callback);\n            };\n            Schema.prototype.assign = function (props) {\n                Object.assign(this, props);\n                return this;\n            };\n            Object.defineProperty(Schema.prototype, \"_definition\", {\n                get: function () { return this.constructor._definition; },\n                enumerable: false,\n                configurable: true\n            });\n            /**\n             * (Server-side): Flag a property to be encoded for the next patch.\n             * @param instance Schema instance\n             * @param property string representing the property name, or number representing the index of the property.\n             * @param operation OPERATION to perform (detected automatically)\n             */\n            Schema.prototype.setDirty = function (property, operation) {\n                this.$changes.change(property, operation);\n            };\n            /**\n             * Client-side: listen for changes on property.\n             * @param prop the property name\n             * @param callback callback to be triggered on property change\n             * @param immediate trigger immediatelly if property has been already set.\n             */\n            Schema.prototype.listen = function (prop, callback, immediate) {\n                var _this = this;\n                if (immediate === void 0) { immediate = true; }\n                if (!this.$callbacks) {\n                    this.$callbacks = {};\n                }\n                if (!this.$callbacks[prop]) {\n                    this.$callbacks[prop] = [];\n                }\n                this.$callbacks[prop].push(callback);\n                if (immediate && this[prop] !== undefined) {\n                    callback(this[prop], undefined);\n                }\n                // return un-register callback.\n                return function () { return spliceOne(_this.$callbacks[prop], _this.$callbacks[prop].indexOf(callback)); };\n            };\n            Schema.prototype.decode = function (bytes, it, ref) {\n                var _a;\n                if (it === void 0) { it = { offset: 0 }; }\n                if (ref === void 0) { ref = this; }\n                var allChanges = [];\n                var $root = this.$changes.root;\n                var totalBytes = bytes.length;\n                var refId = 0;\n                $root.refs.set(refId, this);\n                while (it.offset < totalBytes) {\n                    var byte = bytes[it.offset++];\n                    if (byte == SWITCH_TO_STRUCTURE) {\n                        refId = number(bytes, it);\n                        var nextRef = $root.refs.get(refId);\n                        //\n                        // Trying to access a reference that haven't been decoded yet.\n                        //\n                        if (!nextRef) {\n                            throw new Error(\"\\\"refId\\\" not found: \".concat(refId));\n                        }\n                        ref = nextRef;\n                        continue;\n                    }\n                    var changeTree = ref['$changes'];\n                    var isSchema = (ref['_definition'] !== undefined);\n                    var operation = (isSchema)\n                        ? (byte >> 6) << 6 // \"compressed\" index + operation\n                        : byte; // \"uncompressed\" index + operation (array/map items)\n                    if (operation === exports.OPERATION.CLEAR) {\n                        //\n                        // TODO: refactor me!\n                        // The `.clear()` method is calling `$root.removeRef(refId)` for\n                        // each item inside this collection\n                        //\n                        ref.clear(allChanges);\n                        continue;\n                    }\n                    var fieldIndex = (isSchema)\n                        ? byte % (operation || 255) // if \"REPLACE\" operation (0), use 255\n                        : number(bytes, it);\n                    var fieldName = (isSchema)\n                        ? (ref['_definition'].fieldsByIndex[fieldIndex])\n                        : \"\";\n                    var type = changeTree.getType(fieldIndex);\n                    var value = void 0;\n                    var previousValue = void 0;\n                    var dynamicIndex = void 0;\n                    if (!isSchema) {\n                        previousValue = ref['getByIndex'](fieldIndex);\n                        if ((operation & exports.OPERATION.ADD) === exports.OPERATION.ADD) { // ADD or DELETE_AND_ADD\n                            dynamicIndex = (ref instanceof MapSchema)\n                                ? string(bytes, it)\n                                : fieldIndex;\n                            ref['setIndex'](fieldIndex, dynamicIndex);\n                        }\n                        else {\n                            // here\n                            dynamicIndex = ref['getIndex'](fieldIndex);\n                        }\n                    }\n                    else {\n                        previousValue = ref[\"_\".concat(fieldName)];\n                    }\n                    //\n                    // Delete operations\n                    //\n                    if ((operation & exports.OPERATION.DELETE) === exports.OPERATION.DELETE) {\n                        if (operation !== exports.OPERATION.DELETE_AND_ADD) {\n                            ref['deleteByIndex'](fieldIndex);\n                        }\n                        // Flag `refId` for garbage collection.\n                        if (previousValue && previousValue['$changes']) {\n                            $root.removeRef(previousValue['$changes'].refId);\n                        }\n                        value = null;\n                    }\n                    if (fieldName === undefined) {\n                        console.warn(\"@colyseus/schema: definition mismatch\");\n                        //\n                        // keep skipping next bytes until reaches a known structure\n                        // by local decoder.\n                        //\n                        var nextIterator = { offset: it.offset };\n                        while (it.offset < totalBytes) {\n                            if (switchStructureCheck(bytes, it)) {\n                                nextIterator.offset = it.offset + 1;\n                                if ($root.refs.has(number(bytes, nextIterator))) {\n                                    break;\n                                }\n                            }\n                            it.offset++;\n                        }\n                        continue;\n                    }\n                    else if (operation === exports.OPERATION.DELETE) ;\n                    else if (Schema.is(type)) {\n                        var refId_1 = number(bytes, it);\n                        value = $root.refs.get(refId_1);\n                        if (operation !== exports.OPERATION.REPLACE) {\n                            var childType = this.getSchemaType(bytes, it, type);\n                            if (!value) {\n                                value = this.createTypeInstance(childType);\n                                value.$changes.refId = refId_1;\n                                if (previousValue) {\n                                    value.$callbacks = previousValue.$callbacks;\n                                    // value.$listeners = previousValue.$listeners;\n                                    if (previousValue['$changes'].refId &&\n                                        refId_1 !== previousValue['$changes'].refId) {\n                                        $root.removeRef(previousValue['$changes'].refId);\n                                    }\n                                }\n                            }\n                            $root.addRef(refId_1, value, (value !== previousValue));\n                        }\n                    }\n                    else if (typeof (type) === \"string\") {\n                        //\n                        // primitive value (number, string, boolean, etc)\n                        //\n                        value = decodePrimitiveType(type, bytes, it);\n                    }\n                    else {\n                        var typeDef = getType(Object.keys(type)[0]);\n                        var refId_2 = number(bytes, it);\n                        var valueRef = ($root.refs.has(refId_2))\n                            ? previousValue || $root.refs.get(refId_2)\n                            : new typeDef.constructor();\n                        value = valueRef.clone(true);\n                        value.$changes.refId = refId_2;\n                        // preserve schema callbacks\n                        if (previousValue) {\n                            value['$callbacks'] = previousValue['$callbacks'];\n                            if (previousValue['$changes'].refId &&\n                                refId_2 !== previousValue['$changes'].refId) {\n                                $root.removeRef(previousValue['$changes'].refId);\n                                //\n                                // Trigger onRemove if structure has been replaced.\n                                //\n                                var entries = previousValue.entries();\n                                var iter = void 0;\n                                while ((iter = entries.next()) && !iter.done) {\n                                    var key = (_a = iter.value, _a[0]), value_1 = _a[1];\n                                    allChanges.push({\n                                        refId: refId_2,\n                                        op: exports.OPERATION.DELETE,\n                                        field: key,\n                                        value: undefined,\n                                        previousValue: value_1,\n                                    });\n                                }\n                            }\n                        }\n                        $root.addRef(refId_2, value, (valueRef !== previousValue));\n                    }\n                    if (value !== null &&\n                        value !== undefined) {\n                        if (value['$changes']) {\n                            value['$changes'].setParent(changeTree.ref, changeTree.root, fieldIndex);\n                        }\n                        if (ref instanceof Schema) {\n                            ref[fieldName] = value;\n                            // ref[`_${fieldName}`] = value;\n                        }\n                        else if (ref instanceof MapSchema) {\n                            // const key = ref['$indexes'].get(field);\n                            var key = dynamicIndex;\n                            // ref.set(key, value);\n                            ref['$items'].set(key, value);\n                            ref['$changes'].allChanges.add(fieldIndex);\n                        }\n                        else if (ref instanceof ArraySchema) {\n                            // const key = ref['$indexes'][field];\n                            // console.log(\"SETTING FOR ArraySchema =>\", { field, key, value });\n                            // ref[key] = value;\n                            ref.setAt(fieldIndex, value);\n                        }\n                        else if (ref instanceof CollectionSchema) {\n                            var index = ref.add(value);\n                            ref['setIndex'](fieldIndex, index);\n                        }\n                        else if (ref instanceof SetSchema) {\n                            var index = ref.add(value);\n                            if (index !== false) {\n                                ref['setIndex'](fieldIndex, index);\n                            }\n                        }\n                    }\n                    if (previousValue !== value) {\n                        allChanges.push({\n                            refId: refId,\n                            op: operation,\n                            field: fieldName,\n                            dynamicIndex: dynamicIndex,\n                            value: value,\n                            previousValue: previousValue,\n                        });\n                    }\n                }\n                this._triggerChanges(allChanges);\n                // drop references of unused schemas\n                $root.garbageCollectDeletedRefs();\n                return allChanges;\n            };\n            Schema.prototype.encode = function (encodeAll, bytes, useFilters) {\n                if (encodeAll === void 0) { encodeAll = false; }\n                if (bytes === void 0) { bytes = []; }\n                if (useFilters === void 0) { useFilters = false; }\n                var rootChangeTree = this.$changes;\n                var refIdsVisited = new WeakSet();\n                var changeTrees = [rootChangeTree];\n                var numChangeTrees = 1;\n                for (var i = 0; i < numChangeTrees; i++) {\n                    var changeTree = changeTrees[i];\n                    var ref = changeTree.ref;\n                    var isSchema = (ref instanceof Schema);\n                    // Generate unique refId for the ChangeTree.\n                    changeTree.ensureRefId();\n                    // mark this ChangeTree as visited.\n                    refIdsVisited.add(changeTree);\n                    // root `refId` is skipped.\n                    if (changeTree !== rootChangeTree &&\n                        (changeTree.changed || encodeAll)) {\n                        uint8$1(bytes, SWITCH_TO_STRUCTURE);\n                        number$1(bytes, changeTree.refId);\n                    }\n                    var changes = (encodeAll)\n                        ? Array.from(changeTree.allChanges)\n                        : Array.from(changeTree.changes.values());\n                    for (var j = 0, cl = changes.length; j < cl; j++) {\n                        var operation = (encodeAll)\n                            ? { op: exports.OPERATION.ADD, index: changes[j] }\n                            : changes[j];\n                        var fieldIndex = operation.index;\n                        var field = (isSchema)\n                            ? ref['_definition'].fieldsByIndex && ref['_definition'].fieldsByIndex[fieldIndex]\n                            : fieldIndex;\n                        // cache begin index if `useFilters`\n                        var beginIndex = bytes.length;\n                        // encode field index + operation\n                        if (operation.op !== exports.OPERATION.TOUCH) {\n                            if (isSchema) {\n                                //\n                                // Compress `fieldIndex` + `operation` into a single byte.\n                                // This adds a limitaion of 64 fields per Schema structure\n                                //\n                                uint8$1(bytes, (fieldIndex | operation.op));\n                            }\n                            else {\n                                uint8$1(bytes, operation.op);\n                                // custom operations\n                                if (operation.op === exports.OPERATION.CLEAR) {\n                                    continue;\n                                }\n                                // indexed operations\n                                number$1(bytes, fieldIndex);\n                            }\n                        }\n                        //\n                        // encode \"alias\" for dynamic fields (maps)\n                        //\n                        if (!isSchema &&\n                            (operation.op & exports.OPERATION.ADD) == exports.OPERATION.ADD // ADD or DELETE_AND_ADD\n                        ) {\n                            if (ref instanceof MapSchema) {\n                                //\n                                // MapSchema dynamic key\n                                //\n                                var dynamicIndex = changeTree.ref['$indexes'].get(fieldIndex);\n                                string$1(bytes, dynamicIndex);\n                            }\n                        }\n                        if (operation.op === exports.OPERATION.DELETE) {\n                            //\n                            // TODO: delete from filter cache data.\n                            //\n                            // if (useFilters) {\n                            //     delete changeTree.caches[fieldIndex];\n                            // }\n                            continue;\n                        }\n                        // const type = changeTree.childType || ref._schema[field];\n                        var type = changeTree.getType(fieldIndex);\n                        // const type = changeTree.getType(fieldIndex);\n                        var value = changeTree.getValue(fieldIndex);\n                        // Enqueue ChangeTree to be visited\n                        if (value &&\n                            value['$changes'] &&\n                            !refIdsVisited.has(value['$changes'])) {\n                            changeTrees.push(value['$changes']);\n                            value['$changes'].ensureRefId();\n                            numChangeTrees++;\n                        }\n                        if (operation.op === exports.OPERATION.TOUCH) {\n                            continue;\n                        }\n                        if (Schema.is(type)) {\n                            assertInstanceType(value, type, ref, field);\n                            //\n                            // Encode refId for this instance.\n                            // The actual instance is going to be encoded on next `changeTree` iteration.\n                            //\n                            number$1(bytes, value.$changes.refId);\n                            // Try to encode inherited TYPE_ID if it's an ADD operation.\n                            if ((operation.op & exports.OPERATION.ADD) === exports.OPERATION.ADD) {\n                                this.tryEncodeTypeId(bytes, type, value.constructor);\n                            }\n                        }\n                        else if (typeof (type) === \"string\") {\n                            //\n                            // Primitive values\n                            //\n                            encodePrimitiveType(type, bytes, value, ref, field);\n                        }\n                        else {\n                            //\n                            // Custom type (MapSchema, ArraySchema, etc)\n                            //\n                            var definition = getType(Object.keys(type)[0]);\n                            //\n                            // ensure a ArraySchema has been provided\n                            //\n                            assertInstanceType(ref[\"_\".concat(field)], definition.constructor, ref, field);\n                            //\n                            // Encode refId for this instance.\n                            // The actual instance is going to be encoded on next `changeTree` iteration.\n                            //\n                            number$1(bytes, value.$changes.refId);\n                        }\n                        if (useFilters) {\n                            // cache begin / end index\n                            changeTree.cache(fieldIndex, bytes.slice(beginIndex));\n                        }\n                    }\n                    if (!encodeAll && !useFilters) {\n                        changeTree.discard();\n                    }\n                }\n                return bytes;\n            };\n            Schema.prototype.encodeAll = function (useFilters) {\n                return this.encode(true, [], useFilters);\n            };\n            Schema.prototype.applyFilters = function (client, encodeAll) {\n                var _a, _b;\n                if (encodeAll === void 0) { encodeAll = false; }\n                var root = this;\n                var refIdsDissallowed = new Set();\n                var $filterState = ClientState.get(client);\n                var changeTrees = [this.$changes];\n                var numChangeTrees = 1;\n                var filteredBytes = [];\n                var _loop_1 = function (i) {\n                    var changeTree = changeTrees[i];\n                    if (refIdsDissallowed.has(changeTree.refId)) {\n                        return \"continue\";\n                    }\n                    var ref = changeTree.ref;\n                    var isSchema = ref instanceof Schema;\n                    uint8$1(filteredBytes, SWITCH_TO_STRUCTURE);\n                    number$1(filteredBytes, changeTree.refId);\n                    var clientHasRefId = $filterState.refIds.has(changeTree);\n                    var isEncodeAll = (encodeAll || !clientHasRefId);\n                    // console.log(\"REF:\", ref.constructor.name);\n                    // console.log(\"Encode all?\", isEncodeAll);\n                    //\n                    // include `changeTree` on list of known refIds by this client.\n                    //\n                    $filterState.addRefId(changeTree);\n                    var containerIndexes = $filterState.containerIndexes.get(changeTree);\n                    var changes = (isEncodeAll)\n                        ? Array.from(changeTree.allChanges)\n                        : Array.from(changeTree.changes.values());\n                    //\n                    // WORKAROUND: tries to re-evaluate previously not included @filter() attributes\n                    // - see \"DELETE a field of Schema\" test case.\n                    //\n                    if (!encodeAll &&\n                        isSchema &&\n                        ref._definition.indexesWithFilters) {\n                        var indexesWithFilters = ref._definition.indexesWithFilters;\n                        indexesWithFilters.forEach(function (indexWithFilter) {\n                            if (!containerIndexes.has(indexWithFilter) &&\n                                changeTree.allChanges.has(indexWithFilter)) {\n                                if (isEncodeAll) {\n                                    changes.push(indexWithFilter);\n                                }\n                                else {\n                                    changes.push({ op: exports.OPERATION.ADD, index: indexWithFilter, });\n                                }\n                            }\n                        });\n                    }\n                    for (var j = 0, cl = changes.length; j < cl; j++) {\n                        var change = (isEncodeAll)\n                            ? { op: exports.OPERATION.ADD, index: changes[j] }\n                            : changes[j];\n                        // custom operations\n                        if (change.op === exports.OPERATION.CLEAR) {\n                            uint8$1(filteredBytes, change.op);\n                            continue;\n                        }\n                        var fieldIndex = change.index;\n                        //\n                        // Deleting fields: encode the operation + field index\n                        //\n                        if (change.op === exports.OPERATION.DELETE) {\n                            //\n                            // DELETE operations also need to go through filtering.\n                            //\n                            // TODO: cache the previous value so we can access the value (primitive or `refId`)\n                            // (check against `$filterState.refIds`)\n                            //\n                            if (isSchema) {\n                                uint8$1(filteredBytes, change.op | fieldIndex);\n                            }\n                            else {\n                                uint8$1(filteredBytes, change.op);\n                                number$1(filteredBytes, fieldIndex);\n                            }\n                            continue;\n                        }\n                        // indexed operation\n                        var value = changeTree.getValue(fieldIndex);\n                        var type = changeTree.getType(fieldIndex);\n                        if (isSchema) {\n                            // Is a Schema!\n                            var filter = (ref._definition.filters &&\n                                ref._definition.filters[fieldIndex]);\n                            if (filter && !filter.call(ref, client, value, root)) {\n                                if (value && value['$changes']) {\n                                    refIdsDissallowed.add(value['$changes'].refId);\n                                }\n                                continue;\n                            }\n                        }\n                        else {\n                            // Is a collection! (map, array, etc.)\n                            var parent = changeTree.parent;\n                            var filter = changeTree.getChildrenFilter();\n                            if (filter && !filter.call(parent, client, ref['$indexes'].get(fieldIndex), value, root)) {\n                                if (value && value['$changes']) {\n                                    refIdsDissallowed.add(value['$changes'].refId);\n                                }\n                                continue;\n                            }\n                        }\n                        // visit child ChangeTree on further iteration.\n                        if (value['$changes']) {\n                            changeTrees.push(value['$changes']);\n                            numChangeTrees++;\n                        }\n                        //\n                        // Copy cached bytes\n                        //\n                        if (change.op !== exports.OPERATION.TOUCH) {\n                            //\n                            // TODO: refactor me!\n                            //\n                            if (change.op === exports.OPERATION.ADD || isSchema) {\n                                //\n                                // use cached bytes directly if is from Schema type.\n                                //\n                                filteredBytes.push.apply(filteredBytes, (_a = changeTree.caches[fieldIndex]) !== null && _a !== void 0 ? _a : []);\n                                containerIndexes.add(fieldIndex);\n                            }\n                            else {\n                                if (containerIndexes.has(fieldIndex)) {\n                                    //\n                                    // use cached bytes if already has the field\n                                    //\n                                    filteredBytes.push.apply(filteredBytes, (_b = changeTree.caches[fieldIndex]) !== null && _b !== void 0 ? _b : []);\n                                }\n                                else {\n                                    //\n                                    // force ADD operation if field is not known by this client.\n                                    //\n                                    containerIndexes.add(fieldIndex);\n                                    uint8$1(filteredBytes, exports.OPERATION.ADD);\n                                    number$1(filteredBytes, fieldIndex);\n                                    if (ref instanceof MapSchema) {\n                                        //\n                                        // MapSchema dynamic key\n                                        //\n                                        var dynamicIndex = changeTree.ref['$indexes'].get(fieldIndex);\n                                        string$1(filteredBytes, dynamicIndex);\n                                    }\n                                    if (value['$changes']) {\n                                        number$1(filteredBytes, value['$changes'].refId);\n                                    }\n                                    else {\n                                        // \"encodePrimitiveType\" without type checking.\n                                        // the type checking has been done on the first .encode() call.\n                                        encode[type](filteredBytes, value);\n                                    }\n                                }\n                            }\n                        }\n                        else if (value['$changes'] && !isSchema) {\n                            //\n                            // TODO:\n                            // - track ADD/REPLACE/DELETE instances on `$filterState`\n                            // - do NOT always encode dynamicIndex for MapSchema.\n                            //   (If client already has that key, only the first index is necessary.)\n                            //\n                            uint8$1(filteredBytes, exports.OPERATION.ADD);\n                            number$1(filteredBytes, fieldIndex);\n                            if (ref instanceof MapSchema) {\n                                //\n                                // MapSchema dynamic key\n                                //\n                                var dynamicIndex = changeTree.ref['$indexes'].get(fieldIndex);\n                                string$1(filteredBytes, dynamicIndex);\n                            }\n                            number$1(filteredBytes, value['$changes'].refId);\n                        }\n                    }\n                };\n                for (var i = 0; i < numChangeTrees; i++) {\n                    _loop_1(i);\n                }\n                return filteredBytes;\n            };\n            Schema.prototype.clone = function () {\n                var _a;\n                var cloned = new (this.constructor);\n                var schema = this._definition.schema;\n                for (var field in schema) {\n                    if (typeof (this[field]) === \"object\" &&\n                        typeof ((_a = this[field]) === null || _a === void 0 ? void 0 : _a.clone) === \"function\") {\n                        // deep clone\n                        cloned[field] = this[field].clone();\n                    }\n                    else {\n                        // primitive values\n                        cloned[field] = this[field];\n                    }\n                }\n                return cloned;\n            };\n            Schema.prototype.toJSON = function () {\n                var schema = this._definition.schema;\n                var deprecated = this._definition.deprecated;\n                var obj = {};\n                for (var field in schema) {\n                    if (!deprecated[field] && this[field] !== null && typeof (this[field]) !== \"undefined\") {\n                        obj[field] = (typeof (this[field]['toJSON']) === \"function\")\n                            ? this[field]['toJSON']()\n                            : this[\"_\".concat(field)];\n                    }\n                }\n                return obj;\n            };\n            Schema.prototype.discardAllChanges = function () {\n                this.$changes.discardAll();\n            };\n            Schema.prototype.getByIndex = function (index) {\n                return this[this._definition.fieldsByIndex[index]];\n            };\n            Schema.prototype.deleteByIndex = function (index) {\n                this[this._definition.fieldsByIndex[index]] = undefined;\n            };\n            Schema.prototype.tryEncodeTypeId = function (bytes, type, targetType) {\n                if (type._typeid !== targetType._typeid) {\n                    uint8$1(bytes, TYPE_ID);\n                    number$1(bytes, targetType._typeid);\n                }\n            };\n            Schema.prototype.getSchemaType = function (bytes, it, defaultType) {\n                var type;\n                if (bytes[it.offset] === TYPE_ID) {\n                    it.offset++;\n                    type = this.constructor._context.get(number(bytes, it));\n                }\n                return type || defaultType;\n            };\n            Schema.prototype.createTypeInstance = function (type) {\n                var instance = new type();\n                // assign root on $changes\n                instance.$changes.root = this.$changes.root;\n                return instance;\n            };\n            Schema.prototype._triggerChanges = function (changes) {\n                var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n                var uniqueRefIds = new Set();\n                var $refs = this.$changes.root.refs;\n                var _loop_2 = function (i) {\n                    var change = changes[i];\n                    var refId = change.refId;\n                    var ref = $refs.get(refId);\n                    var $callbacks = ref['$callbacks'];\n                    //\n                    // trigger onRemove on child structure.\n                    //\n                    if ((change.op & exports.OPERATION.DELETE) === exports.OPERATION.DELETE &&\n                        change.previousValue instanceof Schema) {\n                        (_b = (_a = change.previousValue['$callbacks']) === null || _a === void 0 ? void 0 : _a[exports.OPERATION.DELETE]) === null || _b === void 0 ? void 0 : _b.forEach(function (callback) { return callback(); });\n                    }\n                    // no callbacks defined, skip this structure!\n                    if (!$callbacks) {\n                        return \"continue\";\n                    }\n                    if (ref instanceof Schema) {\n                        if (!uniqueRefIds.has(refId)) {\n                            try {\n                                // trigger onChange\n                                (_c = $callbacks === null || $callbacks === void 0 ? void 0 : $callbacks[exports.OPERATION.REPLACE]) === null || _c === void 0 ? void 0 : _c.forEach(function (callback) {\n                                    return callback(changes);\n                                });\n                            }\n                            catch (e) {\n                                Schema.onError(e);\n                            }\n                        }\n                        try {\n                            if ($callbacks.hasOwnProperty(change.field)) {\n                                (_d = $callbacks[change.field]) === null || _d === void 0 ? void 0 : _d.forEach(function (callback) {\n                                    return callback(change.value, change.previousValue);\n                                });\n                            }\n                        }\n                        catch (e) {\n                            Schema.onError(e);\n                        }\n                    }\n                    else {\n                        // is a collection of items\n                        if (change.op === exports.OPERATION.ADD && change.previousValue === undefined) {\n                            // triger onAdd\n                            (_e = $callbacks[exports.OPERATION.ADD]) === null || _e === void 0 ? void 0 : _e.forEach(function (callback) { var _a; return callback(change.value, (_a = change.dynamicIndex) !== null && _a !== void 0 ? _a : change.field); });\n                        }\n                        else if (change.op === exports.OPERATION.DELETE) {\n                            //\n                            // FIXME: `previousValue` should always be available.\n                            // ADD + DELETE operations are still encoding DELETE operation.\n                            //\n                            if (change.previousValue !== undefined) {\n                                // triger onRemove\n                                (_f = $callbacks[exports.OPERATION.DELETE]) === null || _f === void 0 ? void 0 : _f.forEach(function (callback) { var _a; return callback(change.previousValue, (_a = change.dynamicIndex) !== null && _a !== void 0 ? _a : change.field); });\n                            }\n                        }\n                        else if (change.op === exports.OPERATION.DELETE_AND_ADD) {\n                            // triger onRemove\n                            if (change.previousValue !== undefined) {\n                                (_g = $callbacks[exports.OPERATION.DELETE]) === null || _g === void 0 ? void 0 : _g.forEach(function (callback) { var _a; return callback(change.previousValue, (_a = change.dynamicIndex) !== null && _a !== void 0 ? _a : change.field); });\n                            }\n                            // triger onAdd\n                            (_h = $callbacks[exports.OPERATION.ADD]) === null || _h === void 0 ? void 0 : _h.forEach(function (callback) { var _a; return callback(change.value, (_a = change.dynamicIndex) !== null && _a !== void 0 ? _a : change.field); });\n                        }\n                        // trigger onChange\n                        if (change.value !== change.previousValue) {\n                            (_j = $callbacks[exports.OPERATION.REPLACE]) === null || _j === void 0 ? void 0 : _j.forEach(function (callback) { var _a; return callback(change.value, (_a = change.dynamicIndex) !== null && _a !== void 0 ? _a : change.field); });\n                        }\n                    }\n                    uniqueRefIds.add(refId);\n                };\n                for (var i = 0; i < changes.length; i++) {\n                    _loop_2(i);\n                }\n            };\n            Schema._definition = SchemaDefinition.create();\n            return Schema;\n        }());\n\n        function dumpChanges(schema) {\n            var changeTrees = [schema['$changes']];\n            var numChangeTrees = 1;\n            var dump = {};\n            var currentStructure = dump;\n            var _loop_1 = function (i) {\n                var changeTree = changeTrees[i];\n                changeTree.changes.forEach(function (change) {\n                    var ref = changeTree.ref;\n                    var fieldIndex = change.index;\n                    var field = (ref['_definition'])\n                        ? ref['_definition'].fieldsByIndex[fieldIndex]\n                        : ref['$indexes'].get(fieldIndex);\n                    currentStructure[field] = changeTree.getValue(fieldIndex);\n                });\n            };\n            for (var i = 0; i < numChangeTrees; i++) {\n                _loop_1(i);\n            }\n            return dump;\n        }\n\n        var reflectionContext = { context: new Context() };\n        /**\n         * Reflection\n         */\n        var ReflectionField = /** @class */ (function (_super) {\n            __extends(ReflectionField, _super);\n            function ReflectionField() {\n                return _super !== null && _super.apply(this, arguments) || this;\n            }\n            __decorate([\n                type(\"string\", reflectionContext)\n            ], ReflectionField.prototype, \"name\", void 0);\n            __decorate([\n                type(\"string\", reflectionContext)\n            ], ReflectionField.prototype, \"type\", void 0);\n            __decorate([\n                type(\"number\", reflectionContext)\n            ], ReflectionField.prototype, \"referencedType\", void 0);\n            return ReflectionField;\n        }(Schema));\n        var ReflectionType = /** @class */ (function (_super) {\n            __extends(ReflectionType, _super);\n            function ReflectionType() {\n                var _this = _super !== null && _super.apply(this, arguments) || this;\n                _this.fields = new ArraySchema();\n                return _this;\n            }\n            __decorate([\n                type(\"number\", reflectionContext)\n            ], ReflectionType.prototype, \"id\", void 0);\n            __decorate([\n                type([ReflectionField], reflectionContext)\n            ], ReflectionType.prototype, \"fields\", void 0);\n            return ReflectionType;\n        }(Schema));\n        var Reflection = /** @class */ (function (_super) {\n            __extends(Reflection, _super);\n            function Reflection() {\n                var _this = _super !== null && _super.apply(this, arguments) || this;\n                _this.types = new ArraySchema();\n                return _this;\n            }\n            Reflection.encode = function (instance) {\n                var rootSchemaType = instance.constructor;\n                var reflection = new Reflection();\n                reflection.rootType = rootSchemaType._typeid;\n                var buildType = function (currentType, schema) {\n                    for (var fieldName in schema) {\n                        var field = new ReflectionField();\n                        field.name = fieldName;\n                        var fieldType = void 0;\n                        if (typeof (schema[fieldName]) === \"string\") {\n                            fieldType = schema[fieldName];\n                        }\n                        else {\n                            var type_1 = schema[fieldName];\n                            var childTypeSchema = void 0;\n                            //\n                            // TODO: refactor below.\n                            //\n                            if (Schema.is(type_1)) {\n                                fieldType = \"ref\";\n                                childTypeSchema = schema[fieldName];\n                            }\n                            else {\n                                fieldType = Object.keys(type_1)[0];\n                                if (typeof (type_1[fieldType]) === \"string\") {\n                                    fieldType += \":\" + type_1[fieldType]; // array:string\n                                }\n                                else {\n                                    childTypeSchema = type_1[fieldType];\n                                }\n                            }\n                            field.referencedType = (childTypeSchema)\n                                ? childTypeSchema._typeid\n                                : -1;\n                        }\n                        field.type = fieldType;\n                        currentType.fields.push(field);\n                    }\n                    reflection.types.push(currentType);\n                };\n                var types = rootSchemaType._context.types;\n                for (var typeid in types) {\n                    var type_2 = new ReflectionType();\n                    type_2.id = Number(typeid);\n                    buildType(type_2, types[typeid]._definition.schema);\n                }\n                return reflection.encodeAll();\n            };\n            Reflection.decode = function (bytes, it) {\n                var context = new Context();\n                var reflection = new Reflection();\n                reflection.decode(bytes, it);\n                var schemaTypes = reflection.types.reduce(function (types, reflectionType) {\n                    var schema = /** @class */ (function (_super) {\n                        __extends(_, _super);\n                        function _() {\n                            return _super !== null && _super.apply(this, arguments) || this;\n                        }\n                        return _;\n                    }(Schema));\n                    var typeid = reflectionType.id;\n                    types[typeid] = schema;\n                    context.add(schema, typeid);\n                    return types;\n                }, {});\n                reflection.types.forEach(function (reflectionType) {\n                    var schemaType = schemaTypes[reflectionType.id];\n                    reflectionType.fields.forEach(function (field) {\n                        var _a;\n                        if (field.referencedType !== undefined) {\n                            var fieldType = field.type;\n                            var refType = schemaTypes[field.referencedType];\n                            // map or array of primitive type (-1)\n                            if (!refType) {\n                                var typeInfo = field.type.split(\":\");\n                                fieldType = typeInfo[0];\n                                refType = typeInfo[1];\n                            }\n                            if (fieldType === \"ref\") {\n                                type(refType, { context: context })(schemaType.prototype, field.name);\n                            }\n                            else {\n                                type((_a = {}, _a[fieldType] = refType, _a), { context: context })(schemaType.prototype, field.name);\n                            }\n                        }\n                        else {\n                            type(field.type, { context: context })(schemaType.prototype, field.name);\n                        }\n                    });\n                });\n                var rootType = schemaTypes[reflection.rootType];\n                var rootInstance = new rootType();\n                /**\n                 * auto-initialize referenced types on root type\n                 * to allow registering listeners immediatelly on client-side\n                 */\n                for (var fieldName in rootType._definition.schema) {\n                    var fieldType = rootType._definition.schema[fieldName];\n                    if (typeof (fieldType) !== \"string\") {\n                        rootInstance[fieldName] = (typeof (fieldType) === \"function\")\n                            ? new fieldType() // is a schema reference\n                            : new (getType(Object.keys(fieldType)[0])).constructor(); // is a \"collection\"\n                    }\n                }\n                return rootInstance;\n            };\n            __decorate([\n                type([ReflectionType], reflectionContext)\n            ], Reflection.prototype, \"types\", void 0);\n            __decorate([\n                type(\"number\", reflectionContext)\n            ], Reflection.prototype, \"rootType\", void 0);\n            return Reflection;\n        }(Schema));\n\n        registerType(\"map\", { constructor: MapSchema });\n        registerType(\"array\", { constructor: ArraySchema });\n        registerType(\"set\", { constructor: SetSchema });\n        registerType(\"collection\", { constructor: CollectionSchema, });\n\n        exports.ArraySchema = ArraySchema;\n        exports.CollectionSchema = CollectionSchema;\n        exports.Context = Context;\n        exports.MapSchema = MapSchema;\n        exports.Reflection = Reflection;\n        exports.ReflectionField = ReflectionField;\n        exports.ReflectionType = ReflectionType;\n        exports.Schema = Schema;\n        exports.SchemaDefinition = SchemaDefinition;\n        exports.SetSchema = SetSchema;\n        exports.decode = decode;\n        exports.defineTypes = defineTypes;\n        exports.deprecated = deprecated;\n        exports.dumpChanges = dumpChanges;\n        exports.encode = encode;\n        exports.filter = filter;\n        exports.filterChildren = filterChildren;\n        exports.hasFilter = hasFilter;\n        exports.registerType = registerType;\n        exports.type = type;\n\n        Object.defineProperty(exports, '__esModule', { value: true });\n\n    }));\n    });\n\n    var Room = /** @class */ (function () {\n        function Room(name, rootSchema) {\n            var _this = this;\n            // Public signals\n            this.onStateChange = createSignal();\n            this.onError = createSignal();\n            this.onLeave = createSignal();\n            this.onJoin = createSignal();\n            this.hasJoined = false;\n            this.onMessageHandlers = createNanoEvents();\n            this.roomId = null;\n            this.name = name;\n            if (rootSchema) {\n                this.serializer = new (getSerializer(\"schema\"));\n                this.rootSchema = rootSchema;\n                this.serializer.state = new rootSchema();\n            }\n            this.onError(function (code, message) { return console.warn(\"colyseus.js - onError => (\".concat(code, \") \").concat(message)); });\n            this.onLeave(function () { return _this.removeAllListeners(); });\n        }\n        Object.defineProperty(Room.prototype, \"id\", {\n            // TODO: deprecate me on version 1.0\n            get: function () { return this.roomId; },\n            enumerable: false,\n            configurable: true\n        });\n        Room.prototype.connect = function (endpoint, devModeCloseCallback, room // when reconnecting on devMode, re-use previous room intance for handling events.\n        ) {\n            if (room === void 0) { room = this; }\n            var connection = new Connection();\n            room.connection = connection;\n            connection.events.onmessage = Room.prototype.onMessageCallback.bind(room);\n            connection.events.onclose = function (e) {\n                if (!room.hasJoined) {\n                    console.warn(\"Room connection was closed unexpectedly (\".concat(e.code, \"): \").concat(e.reason));\n                    room.onError.invoke(e.code, e.reason);\n                    return;\n                }\n                if (e.code === CloseCode.DEVMODE_RESTART && devModeCloseCallback) {\n                    devModeCloseCallback();\n                }\n                else {\n                    room.onLeave.invoke(e.code);\n                    room.destroy();\n                }\n            };\n            connection.events.onerror = function (e) {\n                console.warn(\"Room, onError (\".concat(e.code, \"): \").concat(e.reason));\n                room.onError.invoke(e.code, e.reason);\n            };\n            connection.connect(endpoint);\n        };\n        Room.prototype.leave = function (consented) {\n            var _this = this;\n            if (consented === void 0) { consented = true; }\n            return new Promise(function (resolve) {\n                _this.onLeave(function (code) { return resolve(code); });\n                if (_this.connection) {\n                    if (consented) {\n                        _this.connection.send([exports.Protocol.LEAVE_ROOM]);\n                    }\n                    else {\n                        _this.connection.close();\n                    }\n                }\n                else {\n                    _this.onLeave.invoke(CloseCode.CONSENTED);\n                }\n            });\n        };\n        Room.prototype.onMessage = function (type, callback) {\n            return this.onMessageHandlers.on(this.getMessageHandlerKey(type), callback);\n        };\n        Room.prototype.send = function (type, message) {\n            var initialBytes = [exports.Protocol.ROOM_DATA];\n            if (typeof (type) === \"string\") {\n                umd.encode.string(initialBytes, type);\n            }\n            else {\n                umd.encode.number(initialBytes, type);\n            }\n            var arr;\n            if (message !== undefined) {\n                var encoded = encode(message);\n                arr = new Uint8Array(initialBytes.length + encoded.byteLength);\n                arr.set(new Uint8Array(initialBytes), 0);\n                arr.set(new Uint8Array(encoded), initialBytes.length);\n            }\n            else {\n                arr = new Uint8Array(initialBytes);\n            }\n            this.connection.send(arr.buffer);\n        };\n        Room.prototype.sendBytes = function (type, bytes) {\n            var initialBytes = [exports.Protocol.ROOM_DATA_BYTES];\n            if (typeof (type) === \"string\") {\n                umd.encode.string(initialBytes, type);\n            }\n            else {\n                umd.encode.number(initialBytes, type);\n            }\n            var arr;\n            arr = new Uint8Array(initialBytes.length + (bytes.byteLength || bytes.length));\n            arr.set(new Uint8Array(initialBytes), 0);\n            arr.set(new Uint8Array(bytes), initialBytes.length);\n            this.connection.send(arr.buffer);\n        };\n        Object.defineProperty(Room.prototype, \"state\", {\n            get: function () {\n                return this.serializer.getState();\n            },\n            enumerable: false,\n            configurable: true\n        });\n        Room.prototype.removeAllListeners = function () {\n            this.onJoin.clear();\n            this.onStateChange.clear();\n            this.onError.clear();\n            this.onLeave.clear();\n            this.onMessageHandlers.events = {};\n        };\n        Room.prototype.onMessageCallback = function (event) {\n            var bytes = Array.from(new Uint8Array(event.data));\n            var code = bytes[0];\n            if (code === exports.Protocol.JOIN_ROOM) {\n                var offset = 1;\n                var reconnectionToken = utf8Read(bytes, offset);\n                offset += utf8Length(reconnectionToken);\n                this.serializerId = utf8Read(bytes, offset);\n                offset += utf8Length(this.serializerId);\n                // Instantiate serializer if not locally available.\n                if (!this.serializer) {\n                    var serializer = getSerializer(this.serializerId);\n                    this.serializer = new serializer();\n                }\n                if (bytes.length > offset && this.serializer.handshake) {\n                    this.serializer.handshake(bytes, { offset: offset });\n                }\n                this.reconnectionToken = \"\".concat(this.roomId, \":\").concat(reconnectionToken);\n                this.hasJoined = true;\n                this.onJoin.invoke();\n                // acknowledge successfull JOIN_ROOM\n                this.connection.send([exports.Protocol.JOIN_ROOM]);\n            }\n            else if (code === exports.Protocol.ERROR) {\n                var it_1 = { offset: 1 };\n                var code_1 = umd.decode.number(bytes, it_1);\n                var message = umd.decode.string(bytes, it_1);\n                this.onError.invoke(code_1, message);\n            }\n            else if (code === exports.Protocol.LEAVE_ROOM) {\n                this.leave();\n            }\n            else if (code === exports.Protocol.ROOM_DATA_SCHEMA) {\n                var it_2 = { offset: 1 };\n                var context_1 = this.serializer.getState().constructor._context;\n                var type = context_1.get(umd.decode.number(bytes, it_2));\n                var message = new type();\n                message.decode(bytes, it_2);\n                this.dispatchMessage(type, message);\n            }\n            else if (code === exports.Protocol.ROOM_STATE) {\n                bytes.shift(); // drop `code` byte\n                this.setState(bytes);\n            }\n            else if (code === exports.Protocol.ROOM_STATE_PATCH) {\n                bytes.shift(); // drop `code` byte\n                this.patch(bytes);\n            }\n            else if (code === exports.Protocol.ROOM_DATA) {\n                var it_3 = { offset: 1 };\n                var type = (umd.decode.stringCheck(bytes, it_3))\n                    ? umd.decode.string(bytes, it_3)\n                    : umd.decode.number(bytes, it_3);\n                var message = (bytes.length > it_3.offset)\n                    ? decode(event.data, it_3.offset)\n                    : undefined;\n                this.dispatchMessage(type, message);\n            }\n            else if (code === exports.Protocol.ROOM_DATA_BYTES) {\n                var it_4 = { offset: 1 };\n                var type = (umd.decode.stringCheck(bytes, it_4))\n                    ? umd.decode.string(bytes, it_4)\n                    : umd.decode.number(bytes, it_4);\n                this.dispatchMessage(type, new Uint8Array(bytes.slice(it_4.offset)));\n            }\n        };\n        Room.prototype.setState = function (encodedState) {\n            this.serializer.setState(encodedState);\n            this.onStateChange.invoke(this.serializer.getState());\n        };\n        Room.prototype.patch = function (binaryPatch) {\n            this.serializer.patch(binaryPatch);\n            this.onStateChange.invoke(this.serializer.getState());\n        };\n        Room.prototype.dispatchMessage = function (type, message) {\n            var messageType = this.getMessageHandlerKey(type);\n            if (this.onMessageHandlers.events[messageType]) {\n                this.onMessageHandlers.emit(messageType, message);\n            }\n            else if (this.onMessageHandlers.events['*']) {\n                this.onMessageHandlers.emit('*', type, message);\n            }\n            else {\n                console.warn(\"colyseus.js: onMessage() not registered for type '\".concat(type, \"'.\"));\n            }\n        };\n        Room.prototype.destroy = function () {\n            if (this.serializer) {\n                this.serializer.teardown();\n            }\n        };\n        Room.prototype.getMessageHandlerKey = function (type) {\n            switch (typeof (type)) {\n                // typeof Schema\n                case \"function\": return \"$\".concat(type._typeid);\n                // string\n                case \"string\": return type;\n                // number\n                case \"number\": return \"i\".concat(type);\n                default: throw new Error(\"invalid message type.\");\n            }\n        };\n        return Room;\n    }());\n\n    var _a;\n    var MatchMakeError = /** @class */ (function (_super) {\n        __extends(MatchMakeError, _super);\n        function MatchMakeError(message, code) {\n            var _this = _super.call(this, message) || this;\n            _this.code = code;\n            Object.setPrototypeOf(_this, MatchMakeError.prototype);\n            return _this;\n        }\n        return MatchMakeError;\n    }(Error));\n    // - React Native does not provide `window.location`\n    // - Cocos Creator (Native) does not provide `window.location.hostname`\n    var DEFAULT_ENDPOINT = (typeof (window) !== \"undefined\" && typeof ((_a = window === null || window === void 0 ? void 0 : window.location) === null || _a === void 0 ? void 0 : _a.hostname) !== \"undefined\")\n        ? \"\".concat(window.location.protocol.replace(\"http\", \"ws\"), \"//\").concat(window.location.hostname).concat((window.location.port && \":\".concat(window.location.port)))\n        : \"ws://127.0.0.1:2567\";\n    var Client = /** @class */ (function () {\n        function Client(settings) {\n            if (settings === void 0) { settings = DEFAULT_ENDPOINT; }\n            if (typeof (settings) === \"string\") {\n                //\n                // endpoint by url\n                //\n                var url = new URL(settings);\n                var secure = (url.protocol === \"https:\" || url.protocol === \"wss:\");\n                var port = Number(url.port || (secure ? 443 : 80));\n                this.settings = {\n                    hostname: url.hostname,\n                    pathname: url.pathname !== \"/\" ? url.pathname : \"\",\n                    port: port,\n                    secure: secure\n                };\n            }\n            else {\n                //\n                // endpoint by settings\n                //\n                if (settings.port === undefined) {\n                    settings.port = (settings.secure) ? 443 : 80;\n                }\n                if (settings.pathname === undefined) {\n                    settings.pathname = \"\";\n                }\n                this.settings = settings;\n            }\n        }\n        Client.prototype.joinOrCreate = function (roomName, options, rootSchema) {\n            if (options === void 0) { options = {}; }\n            return __awaiter(this, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this.createMatchMakeRequest('joinOrCreate', roomName, options, rootSchema)];\n                        case 1: return [2 /*return*/, _a.sent()];\n                    }\n                });\n            });\n        };\n        Client.prototype.create = function (roomName, options, rootSchema) {\n            if (options === void 0) { options = {}; }\n            return __awaiter(this, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this.createMatchMakeRequest('create', roomName, options, rootSchema)];\n                        case 1: return [2 /*return*/, _a.sent()];\n                    }\n                });\n            });\n        };\n        Client.prototype.join = function (roomName, options, rootSchema) {\n            if (options === void 0) { options = {}; }\n            return __awaiter(this, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this.createMatchMakeRequest('join', roomName, options, rootSchema)];\n                        case 1: return [2 /*return*/, _a.sent()];\n                    }\n                });\n            });\n        };\n        Client.prototype.joinById = function (roomId, options, rootSchema) {\n            if (options === void 0) { options = {}; }\n            return __awaiter(this, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this.createMatchMakeRequest('joinById', roomId, options, rootSchema)];\n                        case 1: return [2 /*return*/, _a.sent()];\n                    }\n                });\n            });\n        };\n        /**\n         * Re-establish connection with a room this client was previously connected to.\n         *\n         * @param reconnectionToken The `room.reconnectionToken` from previously connected room.\n         * @param rootSchema (optional) Concrete root schema definition\n         * @returns Promise<Room>\n         */\n        Client.prototype.reconnect = function (reconnectionToken, rootSchema) {\n            return __awaiter(this, void 0, void 0, function () {\n                var _a, roomId, token;\n                return __generator(this, function (_b) {\n                    switch (_b.label) {\n                        case 0:\n                            if (typeof (reconnectionToken) === \"string\" && typeof (rootSchema) === \"string\") {\n                                throw new Error(\"DEPRECATED: .reconnect() now only accepts 'reconnectionToken' as argument.\\nYou can get this token from previously connected `room.reconnectionToken`\");\n                            }\n                            _a = reconnectionToken.split(\":\"), roomId = _a[0], token = _a[1];\n                            return [4 /*yield*/, this.createMatchMakeRequest('reconnect', roomId, { reconnectionToken: token }, rootSchema)];\n                        case 1: return [2 /*return*/, _b.sent()];\n                    }\n                });\n            });\n        };\n        Client.prototype.getAvailableRooms = function (roomName) {\n            if (roomName === void 0) { roomName = \"\"; }\n            return __awaiter(this, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, get_1(this.getHttpEndpoint(\"\".concat(roomName)), {\n                                headers: {\n                                    'Accept': 'application/json'\n                                }\n                            })];\n                        case 1: return [2 /*return*/, (_a.sent()).data];\n                    }\n                });\n            });\n        };\n        Client.prototype.consumeSeatReservation = function (response, rootSchema, reuseRoomInstance // used in devMode\n        ) {\n            return __awaiter(this, void 0, void 0, function () {\n                var room, options, targetRoom;\n                var _this = this;\n                return __generator(this, function (_a) {\n                    room = this.createRoom(response.room.name, rootSchema);\n                    room.roomId = response.room.roomId;\n                    room.sessionId = response.sessionId;\n                    options = { sessionId: room.sessionId };\n                    // forward \"reconnection token\" in case of reconnection.\n                    if (response.reconnectionToken) {\n                        options.reconnectionToken = response.reconnectionToken;\n                    }\n                    targetRoom = reuseRoomInstance || room;\n                    room.connect(this.buildEndpoint(response.room, options), response.devMode && (function () { return __awaiter(_this, void 0, void 0, function () {\n                        var retryCount, retryMaxRetries, retryReconnection;\n                        var _this = this;\n                        return __generator(this, function (_a) {\n                            console.info(\"[Colyseus devMode]: \".concat(String.fromCodePoint(0x1F504), \" Re-establishing connection with room id '\").concat(room.roomId, \"'...\")); // \n                            retryCount = 0;\n                            retryMaxRetries = 8;\n                            retryReconnection = function () { return __awaiter(_this, void 0, void 0, function () {\n                                return __generator(this, function (_a) {\n                                    switch (_a.label) {\n                                        case 0:\n                                            retryCount++;\n                                            _a.label = 1;\n                                        case 1:\n                                            _a.trys.push([1, 3, , 4]);\n                                            return [4 /*yield*/, this.consumeSeatReservation(response, rootSchema, targetRoom)];\n                                        case 2:\n                                            _a.sent();\n                                            console.info(\"[Colyseus devMode]: \".concat(String.fromCodePoint(0x2705), \" Successfully re-established connection with room '\").concat(room.roomId, \"'\")); // \n                                            return [3 /*break*/, 4];\n                                        case 3:\n                                            _a.sent();\n                                            if (retryCount < retryMaxRetries) {\n                                                console.info(\"[Colyseus devMode]: \".concat(String.fromCodePoint(0x1F504), \" retrying... (\").concat(retryCount, \" out of \").concat(retryMaxRetries, \")\")); // \n                                                setTimeout(retryReconnection, 2000);\n                                            }\n                                            else {\n                                                console.info(\"[Colyseus devMode]: \".concat(String.fromCodePoint(0x274C), \" Failed to reconnect. Is your server running? Please check server logs.\")); // \n                                            }\n                                            return [3 /*break*/, 4];\n                                        case 4: return [2 /*return*/];\n                                    }\n                                });\n                            }); };\n                            setTimeout(retryReconnection, 2000);\n                            return [2 /*return*/];\n                        });\n                    }); }), targetRoom);\n                    return [2 /*return*/, new Promise(function (resolve, reject) {\n                            var onError = function (code, message) { return reject(new ServerError(code, message)); };\n                            targetRoom.onError.once(onError);\n                            targetRoom['onJoin'].once(function () {\n                                targetRoom.onError.remove(onError);\n                                resolve(targetRoom);\n                            });\n                        })];\n                });\n            });\n        };\n        Client.prototype.createMatchMakeRequest = function (method, roomName, options, rootSchema, reuseRoomInstance) {\n            if (options === void 0) { options = {}; }\n            return __awaiter(this, void 0, void 0, function () {\n                var response;\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, post_1(this.getHttpEndpoint(\"\".concat(method, \"/\").concat(roomName)), {\n                                headers: {\n                                    'Accept': 'application/json',\n                                    'Content-Type': 'application/json'\n                                },\n                                body: JSON.stringify(options)\n                            })];\n                        case 1:\n                            response = (_a.sent()).data;\n                            if (response.error) {\n                                throw new MatchMakeError(response.error, response.code);\n                            }\n                            // forward reconnection token during \"reconnect\" methods.\n                            if (method === \"reconnect\") {\n                                response.reconnectionToken = options.reconnectionToken;\n                            }\n                            return [4 /*yield*/, this.consumeSeatReservation(response, rootSchema, reuseRoomInstance)];\n                        case 2: return [2 /*return*/, _a.sent()];\n                    }\n                });\n            });\n        };\n        Client.prototype.createRoom = function (roomName, rootSchema) {\n            return new Room(roomName, rootSchema);\n        };\n        Client.prototype.buildEndpoint = function (room, options) {\n            if (options === void 0) { options = {}; }\n            var params = [];\n            for (var name_1 in options) {\n                if (!options.hasOwnProperty(name_1)) {\n                    continue;\n                }\n                params.push(\"\".concat(name_1, \"=\").concat(options[name_1]));\n            }\n            var endpoint = (this.settings.secure)\n                ? \"wss://\"\n                : \"ws://\";\n            if (room.publicAddress) {\n                endpoint += \"\".concat(room.publicAddress);\n            }\n            else {\n                endpoint += \"\".concat(this.settings.hostname).concat(this.getEndpointPort()).concat(this.settings.pathname);\n            }\n            return \"\".concat(endpoint, \"/\").concat(room.processId, \"/\").concat(room.roomId, \"?\").concat(params.join('&'));\n        };\n        Client.prototype.getHttpEndpoint = function (segments) {\n            if (segments === void 0) { segments = ''; }\n            return \"\".concat((this.settings.secure) ? \"https\" : \"http\", \"://\").concat(this.settings.hostname).concat(this.getEndpointPort()).concat(this.settings.pathname, \"/matchmake/\").concat(segments);\n        };\n        Client.prototype.getEndpointPort = function () {\n            return (this.settings.port !== 80 && this.settings.port !== 443)\n                ? \":\".concat(this.settings.port)\n                : \"\";\n        };\n        return Client;\n    }());\n\n    /// <reference path=\"../typings/cocos-creator.d.ts\" />\n    /**\n     * We do not assign 'storage' to window.localStorage immediatelly for React\n     * Native compatibility. window.localStorage is not present when this module is\n     * loaded.\n     */\n    var storage;\n    function getStorage() {\n        if (!storage) {\n            storage = (typeof (cc) !== 'undefined' && cc.sys && cc.sys.localStorage)\n                ? cc.sys.localStorage // compatibility with cocos creator\n                : typeof (window) !== \"undefined\" && window.localStorage //RN does have window object at this point, but localStorage is not defined\n                    ? window.localStorage // regular browser environment\n                    : {\n                        cache: {},\n                        setItem: function (key, value) { this.cache[key] = value; },\n                        getItem: function (key) { this.cache[key]; },\n                        removeItem: function (key) { delete this.cache[key]; },\n                    };\n        }\n        return storage;\n    }\n    function setItem(key, value) {\n        getStorage().setItem(key, value);\n    }\n    function removeItem(key) {\n        getStorage().removeItem(key);\n    }\n    function getItem(key, callback) {\n        var value = getStorage().getItem(key);\n        if (typeof (Promise) === 'undefined' || // old browsers\n            !(value instanceof Promise)) {\n            // browser has synchronous return\n            callback(value);\n        }\n        else {\n            // react-native is asynchronous\n            value.then(function (id) { return callback(id); });\n        }\n    }\n\n    var TOKEN_STORAGE = \"colyseus-auth-token\";\n    exports.Platform = void 0;\n    (function (Platform) {\n        Platform[\"ios\"] = \"ios\";\n        Platform[\"android\"] = \"android\";\n    })(exports.Platform || (exports.Platform = {}));\n    var Auth = /** @class */ (function () {\n        function Auth(endpoint) {\n            var _this = this;\n            this._id = undefined;\n            this.username = undefined;\n            this.displayName = undefined;\n            this.avatarUrl = undefined;\n            this.isAnonymous = undefined;\n            this.email = undefined;\n            this.lang = undefined;\n            this.location = undefined;\n            this.timezone = undefined;\n            this.metadata = undefined;\n            this.devices = undefined;\n            this.facebookId = undefined;\n            this.twitterId = undefined;\n            this.googleId = undefined;\n            this.gameCenterId = undefined;\n            this.steamId = undefined;\n            this.friendIds = undefined;\n            this.blockedUserIds = undefined;\n            this.createdAt = undefined;\n            this.updatedAt = undefined;\n            // auth token\n            this.token = undefined;\n            this.endpoint = endpoint.replace(\"ws\", \"http\");\n            getItem(TOKEN_STORAGE, function (token) { return _this.token = token; });\n        }\n        Object.defineProperty(Auth.prototype, \"hasToken\", {\n            get: function () {\n                return !!this.token;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        Auth.prototype.login = function (options) {\n            if (options === void 0) { options = {}; }\n            return __awaiter(this, void 0, void 0, function () {\n                var queryParams, data, attr;\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0:\n                            queryParams = Object.assign({}, options);\n                            if (this.hasToken) {\n                                queryParams.token = this.token;\n                            }\n                            return [4 /*yield*/, this.request('post', '/auth', queryParams)];\n                        case 1:\n                            data = _a.sent();\n                            // set & cache token\n                            this.token = data.token;\n                            setItem(TOKEN_STORAGE, this.token);\n                            for (attr in data) {\n                                if (this.hasOwnProperty(attr)) {\n                                    this[attr] = data[attr];\n                                }\n                            }\n                            this.registerPingService();\n                            return [2 /*return*/, this];\n                    }\n                });\n            });\n        };\n        Auth.prototype.save = function () {\n            return __awaiter(this, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this.request('put', '/auth', {}, {\n                                username: this.username,\n                                displayName: this.displayName,\n                                avatarUrl: this.avatarUrl,\n                                lang: this.lang,\n                                location: this.location,\n                                timezone: this.timezone,\n                            })];\n                        case 1:\n                            _a.sent();\n                            return [2 /*return*/, this];\n                    }\n                });\n            });\n        };\n        Auth.prototype.getFriends = function () {\n            return __awaiter(this, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this.request('get', '/friends/all')];\n                        case 1: return [2 /*return*/, (_a.sent())];\n                    }\n                });\n            });\n        };\n        Auth.prototype.getOnlineFriends = function () {\n            return __awaiter(this, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this.request('get', '/friends/online')];\n                        case 1: return [2 /*return*/, (_a.sent())];\n                    }\n                });\n            });\n        };\n        Auth.prototype.getFriendRequests = function () {\n            return __awaiter(this, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this.request('get', '/friends/requests')];\n                        case 1: return [2 /*return*/, (_a.sent())];\n                    }\n                });\n            });\n        };\n        Auth.prototype.sendFriendRequest = function (friendId) {\n            return __awaiter(this, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this.request('post', '/friends/requests', { userId: friendId })];\n                        case 1: return [2 /*return*/, (_a.sent())];\n                    }\n                });\n            });\n        };\n        Auth.prototype.acceptFriendRequest = function (friendId) {\n            return __awaiter(this, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this.request('put', '/friends/requests', { userId: friendId })];\n                        case 1: return [2 /*return*/, (_a.sent())];\n                    }\n                });\n            });\n        };\n        Auth.prototype.declineFriendRequest = function (friendId) {\n            return __awaiter(this, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this.request('del', '/friends/requests', { userId: friendId })];\n                        case 1: return [2 /*return*/, (_a.sent())];\n                    }\n                });\n            });\n        };\n        Auth.prototype.blockUser = function (friendId) {\n            return __awaiter(this, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this.request('post', '/friends/block', { userId: friendId })];\n                        case 1: return [2 /*return*/, (_a.sent())];\n                    }\n                });\n            });\n        };\n        Auth.prototype.unblockUser = function (friendId) {\n            return __awaiter(this, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this.request('put', '/friends/block', { userId: friendId })];\n                        case 1: return [2 /*return*/, (_a.sent())];\n                    }\n                });\n            });\n        };\n        Auth.prototype.request = function (method, segments, query, body, headers) {\n            if (query === void 0) { query = {}; }\n            if (headers === void 0) { headers = {}; }\n            return __awaiter(this, void 0, void 0, function () {\n                var queryParams, name_1, queryString, opts;\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0:\n                            headers['Accept'] = 'application/json';\n                            if (this.hasToken) {\n                                headers['Authorization'] = 'Bearer ' + this.token;\n                            }\n                            queryParams = [];\n                            for (name_1 in query) {\n                                queryParams.push(\"\".concat(name_1, \"=\").concat(query[name_1]));\n                            }\n                            queryString = (queryParams.length > 0)\n                                ? \"?\".concat(queryParams.join(\"&\"))\n                                : '';\n                            opts = { headers: headers };\n                            if (body) {\n                                opts.body = body;\n                            }\n                            return [4 /*yield*/, http[method](\"\".concat(this.endpoint).concat(segments).concat(queryString), opts)];\n                        case 1: return [2 /*return*/, (_a.sent()).data];\n                    }\n                });\n            });\n        };\n        Auth.prototype.logout = function () {\n            this.token = undefined;\n            removeItem(TOKEN_STORAGE);\n            this.unregisterPingService();\n        };\n        Auth.prototype.registerPingService = function (timeout) {\n            var _this = this;\n            if (timeout === void 0) { timeout = 15000; }\n            this.unregisterPingService();\n            this.keepOnlineInterval = setInterval(function () { return _this.request('get', '/auth'); }, timeout);\n        };\n        Auth.prototype.unregisterPingService = function () {\n            clearInterval(this.keepOnlineInterval);\n        };\n        return Auth;\n    }());\n\n    var SchemaSerializer = /** @class */ (function () {\n        function SchemaSerializer() {\n        }\n        SchemaSerializer.prototype.setState = function (rawState) {\n            return this.state.decode(rawState);\n        };\n        SchemaSerializer.prototype.getState = function () {\n            return this.state;\n        };\n        SchemaSerializer.prototype.patch = function (patches) {\n            return this.state.decode(patches);\n        };\n        SchemaSerializer.prototype.teardown = function () {\n            var _a, _b;\n            (_b = (_a = this.state) === null || _a === void 0 ? void 0 : _a['$changes']) === null || _b === void 0 ? void 0 : _b.root.clearRefs();\n        };\n        SchemaSerializer.prototype.handshake = function (bytes, it) {\n            if (this.state) {\n                // TODO: validate client/server definitinos\n                var reflection = new umd.Reflection();\n                reflection.decode(bytes, it);\n            }\n            else {\n                // initialize reflected state from server\n                this.state = umd.Reflection.decode(bytes, it);\n            }\n        };\n        return SchemaSerializer;\n    }());\n\n    var NoneSerializer = /** @class */ (function () {\n        function NoneSerializer() {\n        }\n        NoneSerializer.prototype.setState = function (rawState) { };\n        NoneSerializer.prototype.getState = function () { return null; };\n        NoneSerializer.prototype.patch = function (patches) { };\n        NoneSerializer.prototype.teardown = function () { };\n        NoneSerializer.prototype.handshake = function (bytes) { };\n        return NoneSerializer;\n    }());\n\n    registerSerializer('schema', SchemaSerializer);\n    registerSerializer('none', NoneSerializer);\n\n    exports.Auth = Auth;\n    exports.Client = Client;\n    exports.Room = Room;\n    exports.SchemaSerializer = SchemaSerializer;\n    exports.registerSerializer = registerSerializer;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceMappingURL=colyseus.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL2NvbHlzZXVzLmpzL2Rpc3QvY29seXNldXMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBLElBQUksS0FBNEQ7QUFDaEUsSUFBSSxDQUN5RztBQUM3RyxDQUFDLDhCQUE4Qjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0MscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywrREFBK0QsaUJBQWlCO0FBQ2hIO0FBQ0Esd0NBQXdDLE1BQU0sK0JBQStCLFlBQVk7QUFDekYsdUNBQXVDLE1BQU0sbUNBQW1DLFlBQVk7QUFDNUYsb0NBQW9DO0FBQ3BDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw2QkFBNkIsMEJBQTBCLGNBQWMscUJBQXFCO0FBQzVHLHFCQUFxQixvREFBb0QscUVBQXFFLGNBQWM7QUFDNUosMkJBQTJCLHNCQUFzQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsdUNBQXVDLFNBQVM7QUFDaEQsdUNBQXVDLFdBQVcsVUFBVTtBQUM1RCw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLGtIQUFrSCxPQUFPO0FBQ3pILHFGQUFxRixpQkFBaUI7QUFDdEcsNkRBQTZELGdCQUFnQixRQUFRO0FBQ3JGLG1EQUFtRCxnQkFBZ0IsZ0JBQWdCO0FBQ25GO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQSxjQUFjLFlBQVksYUFBYSxTQUFTLFVBQVU7QUFDMUQsd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQjtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyw4QkFBOEI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxTQUFTO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQywrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixxREFBcUQ7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0RBQWtEO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsWUFBWTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixxREFBcUQ7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxpQkFBaUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLDRDQUE0QztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLDhDQUE4QztBQUNuRDtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsU0FBUztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix1QkFBdUI7QUFDcEQ7QUFDQTtBQUNBLHVEQUF1RCxvQ0FBb0M7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsdUJBQXVCO0FBQ3BEO0FBQ0E7QUFDQSxzRUFBc0Usb0NBQW9DO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsdUJBQXVCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQSw2QkFBNkIsdUJBQXVCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix1QkFBdUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTs7QUFFQSwwSEFBMEgscUJBQU0sbUJBQW1CLHFCQUFNOztBQUV6SjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDM0Ysa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxRQUFRO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGLE9BQU87QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbURBQW1EO0FBQ25ELHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsOENBQThDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLDJDQUEyQztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0JBQWdCO0FBQzNDLDJCQUEyQixnQkFBZ0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxpQ0FBaUM7QUFDeEYsMENBQTBDLDRDQUE0QztBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0dBQXdHLDZCQUE2QjtBQUNySSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsU0FBUztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsdUJBQXVCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx1QkFBdUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHVDQUF1QztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHVCQUF1QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0Esb0NBQW9DLHlCQUF5QjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsdUJBQXVCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUhBQXlIO0FBQ3pIO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSx5QkFBeUI7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBLG1DQUFtQyx5Q0FBeUM7QUFDNUU7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsdUNBQXVDO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCwrQkFBK0I7QUFDbkYscURBQXFELGdDQUFnQztBQUNyRiwyREFBMkQsc0NBQXNDO0FBQ2pHLHlEQUF5RCxvQ0FBb0M7QUFDN0Ysd0RBQXdELG1DQUFtQztBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsY0FBYztBQUM1QztBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsdURBQXVEO0FBQ2xHLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLE9BQU87QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxTQUFTO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsc0JBQXNCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyx1Q0FBdUM7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUscUJBQXFCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCx1Q0FBdUM7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxzQkFBc0I7QUFDL0U7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsdUNBQXVDO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsdUNBQXVDO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxrREFBa0Q7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx1QkFBdUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxzQ0FBc0M7QUFDekU7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUMsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsVUFBVTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxtQkFBbUI7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1Qyx3Q0FBd0M7QUFDeEMsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG9CQUFvQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxRQUFRO0FBQ2pFO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELG9EQUFvRDtBQUN2RztBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EseURBQXlELFFBQVE7QUFDakU7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxvQkFBb0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlOQUFpTixvQkFBb0I7QUFDck87QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwySUFBMkksUUFBUSwwR0FBMEc7QUFDN1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtKQUFrSixRQUFRLGtIQUFrSDtBQUM1UTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0pBQWtKLFFBQVEsa0hBQWtIO0FBQzVRO0FBQ0E7QUFDQSwySUFBMkksUUFBUSwwR0FBMEc7QUFDN1A7QUFDQTtBQUNBO0FBQ0EsK0lBQStJLFFBQVEsMEdBQTBHO0FBQ2pRO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG9CQUFvQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsNEJBQTRCLG9CQUFvQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsSUFBSTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGtCQUFrQjtBQUNsRTtBQUNBO0FBQ0EsNkNBQTZDLGtDQUFrQyxrQkFBa0I7QUFDakc7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGtCQUFrQjtBQUNqRTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVCw4QkFBOEIsd0JBQXdCO0FBQ3RELGdDQUFnQywwQkFBMEI7QUFDMUQsOEJBQThCLHdCQUF3QjtBQUN0RCxxQ0FBcUMsZ0NBQWdDOztBQUVyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVEQUF1RCxhQUFhOztBQUVwRSxLQUFLO0FBQ0wsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHVGQUF1RjtBQUMzSSx1Q0FBdUMsb0NBQW9DO0FBQzNFO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixxQkFBcUI7QUFDcEQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0EsZ0RBQWdELHVCQUF1QjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxnQkFBZ0I7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9HQUFvRywwQkFBMEI7QUFDOUg7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0hBQWdIO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBLGtMQUFrTDtBQUNsTDtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdU1BQXVNO0FBQ3ZNO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsME1BQTBNO0FBQzFNO0FBQ0E7QUFDQTtBQUNBLHNNQUFzTTtBQUN0TTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUIsSUFBSTtBQUN6QjtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekIsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMseURBQXlELDBCQUEwQjtBQUNuRixrREFBa0Qsa0JBQWtCO0FBQ3BFLHFEQUFxRCx5QkFBeUI7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsc0JBQXNCO0FBQzdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssNENBQTRDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsNkJBQTZCO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxrQkFBa0I7QUFDbkg7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdHQUFnRyxrQkFBa0I7QUFDbEg7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdHQUFnRyxrQkFBa0I7QUFDbEg7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RixrQkFBa0I7QUFDaEg7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZGQUE2RixrQkFBa0I7QUFDL0c7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0EsZ0VBQWdFLHVDQUF1QztBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtREFBbUQsYUFBYTs7QUFFaEUsQ0FBQztBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jb2x5c2V1cy5qcy9kaXN0L2NvbHlzZXVzLmpzPzQ5YzMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gY29seXNldXMuanNAMC4xNS4xMSAoQGNvbHlzZXVzL3NjaGVtYSAyLjAuOSlcbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKCdjb2x5c2V1cy5qcycsIFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4gICAgKGdsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwuQ29seXNldXMgPSB7fSkpO1xufSkodGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuICAgIGZ1bmN0aW9uIF9tZXJnZU5hbWVzcGFjZXMobiwgbSkge1xuICAgICAgICBtLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUgJiYgdHlwZW9mIGUgIT09ICdzdHJpbmcnICYmICFBcnJheS5pc0FycmF5KGUpICYmIE9iamVjdC5rZXlzKGUpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgICAgICBpZiAoayAhPT0gJ2RlZmF1bHQnICYmICEoayBpbiBuKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgayk7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBrLCBkLmdldCA/IGQgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlW2tdOyB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5mcmVlemUobik7XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBQb2x5ZmlsbHMgZm9yIGxlZ2FjeSBlbnZpcm9ubWVudHNcbiAgICAvL1xuICAgIC8qXG4gICAgICogU3VwcG9ydCBBbmRyb2lkIDQuNC54XG4gICAgICovXG4gICAgaWYgKCFBcnJheUJ1ZmZlci5pc1ZpZXcpIHtcbiAgICAgICAgQXJyYXlCdWZmZXIuaXNWaWV3ID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIHJldHVybiBhICE9PSBudWxsICYmIHR5cGVvZiAoYSkgPT09ICdvYmplY3QnICYmIGEuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXI7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIERlZmluZSBnbG9iYWxUaGlzIGlmIG5vdCBhdmFpbGFibGUuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NvbHlzZXVzL2NvbHlzZXVzLmpzL2lzc3Vlcy84NlxuICAgIGlmICh0eXBlb2YgKGdsb2JhbFRoaXMpID09PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgIHR5cGVvZiAod2luZG93KSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHdpbmRvd1snZ2xvYmFsVGhpcyddID0gd2luZG93O1xuICAgIH1cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICAgIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuICAgIFBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG4gICAgcHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuICAgIFJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG4gICAgQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG4gICAgSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbiAgICBMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG4gICAgT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG4gICAgUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbiAgICAvKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XHJcbiAgICAgICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgICAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgICAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICAgICAgd2hpbGUgKGcgJiYgKGcgPSAwLCBvcFswXSAmJiAoXyA9IDApKSwgXykgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFwcGx5KHNyYywgdGFyKSB7XG4gICAgXHR0YXIuc3RhdHVzTWVzc2FnZSA9IHNyYy5zdGF0dXNUZXh0O1xuICAgIFx0dGFyLnN0YXR1c0NvZGUgPSBzcmMuc3RhdHVzO1xuICAgIFx0dGFyLmRhdGEgPSBzcmMuYm9keTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZW5kKG1ldGhvZCwgdXJpLCBvcHRzKSB7XG4gICAgXHRvcHRzID0gb3B0cyB8fCB7fTtcbiAgICBcdHZhciB0aW1lciwgY3RybCwgdG1wPW9wdHMuYm9keTtcblxuICAgIFx0b3B0cy5tZXRob2QgPSBtZXRob2Q7XG4gICAgXHRvcHRzLmhlYWRlcnMgPSBvcHRzLmhlYWRlcnMgfHwge307XG5cbiAgICBcdGlmICh0bXAgaW5zdGFuY2VvZiBGb3JtRGF0YSkgOyBlbHNlIGlmICh0bXAgJiYgdHlwZW9mIHRtcCA9PSAnb2JqZWN0Jykge1xuICAgIFx0XHRvcHRzLmhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgIFx0XHRvcHRzLmJvZHkgPSBKU09OLnN0cmluZ2lmeSh0bXApO1xuICAgIFx0fVxuXG4gICAgXHRpZiAob3B0cy53aXRoQ3JlZGVudGlhbHMpIHtcbiAgICBcdFx0b3B0cy5jcmVkZW50aWFscyA9ICdpbmNsdWRlJztcbiAgICBcdH1cblxuICAgIFx0aWYgKG9wdHMudGltZW91dCkge1xuICAgIFx0XHRjdHJsID0gbmV3IEFib3J0Q29udHJvbGxlcjtcbiAgICBcdFx0b3B0cy5zaWduYWwgPSBjdHJsLnNpZ25hbDtcbiAgICBcdFx0dGltZXIgPSBzZXRUaW1lb3V0KGN0cmwuYWJvcnQsIG9wdHMudGltZW91dCk7XG4gICAgXHR9XG5cbiAgICBcdHJldHVybiBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICBcdFx0ZmV0Y2godXJpLCBvcHRzKS50aGVuKChyciwgcmVwbHkpID0+IHtcbiAgICBcdFx0XHRjbGVhclRpbWVvdXQodGltZXIpO1xuXG4gICAgXHRcdFx0YXBwbHkocnIsIHJyKTsgLy89PiByci5oZWFkZXJzXG4gICAgXHRcdFx0cmVwbHkgPSByci5zdGF0dXMgPj0gNDAwID8gcmVqIDogcmVzO1xuXG4gICAgXHRcdFx0dG1wID0gcnIuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpO1xuICAgIFx0XHRcdGlmICghdG1wIHx8ICF+dG1wLmluZGV4T2YoJ2FwcGxpY2F0aW9uL2pzb24nKSkge1xuICAgIFx0XHRcdFx0cmVwbHkocnIpO1xuICAgIFx0XHRcdH0gZWxzZSB7XG4gICAgXHRcdFx0XHRyci50ZXh0KCkudGhlbihzdHIgPT4ge1xuICAgIFx0XHRcdFx0XHR0cnkge1xuICAgIFx0XHRcdFx0XHRcdHJyLmRhdGEgPSBKU09OLnBhcnNlKHN0ciwgb3B0cy5yZXZpdmVyKTtcbiAgICBcdFx0XHRcdFx0XHRyZXBseShycik7XG4gICAgXHRcdFx0XHRcdH0gY2F0Y2ggKGVycikge1xuICAgIFx0XHRcdFx0XHRcdGVyci5oZWFkZXJzID0gcnIuaGVhZGVycztcbiAgICBcdFx0XHRcdFx0XHRhcHBseShyciwgZXJyKTtcbiAgICBcdFx0XHRcdFx0XHRyZWooZXJyKTtcbiAgICBcdFx0XHRcdFx0fVxuICAgIFx0XHRcdFx0fSk7XG4gICAgXHRcdFx0fVxuICAgIFx0XHR9KS5jYXRjaChlcnIgPT4ge1xuICAgIFx0XHRcdGVyci50aW1lb3V0ID0gY3RybCAmJiBjdHJsLnNpZ25hbC5hYm9ydGVkO1xuICAgIFx0XHRcdHJlaihlcnIpO1xuICAgIFx0XHR9KTtcbiAgICBcdH0pO1xuICAgIH1cblxuICAgIHZhciBnZXQgPSAvKiNfX1BVUkVfXyovIHNlbmQuYmluZChzZW5kLCAnR0VUJyk7XG4gICAgdmFyIHBvc3QgPSAvKiNfX1BVUkVfXyovIHNlbmQuYmluZChzZW5kLCAnUE9TVCcpO1xuICAgIHZhciBwYXRjaCA9IC8qI19fUFVSRV9fKi8gc2VuZC5iaW5kKHNlbmQsICdQQVRDSCcpO1xuICAgIHZhciBkZWwgPSAvKiNfX1BVUkVfXyovIHNlbmQuYmluZChzZW5kLCAnREVMRVRFJyk7XG4gICAgdmFyIHB1dCA9IC8qI19fUFVSRV9fKi8gc2VuZC5iaW5kKHNlbmQsICdQVVQnKTtcblxuICAgIHZhciBkZWxfMSA9IGRlbDtcbiAgICB2YXIgZ2V0XzEgPSBnZXQ7XG4gICAgdmFyIHBhdGNoXzEgPSBwYXRjaDtcbiAgICB2YXIgcG9zdF8xID0gcG9zdDtcbiAgICB2YXIgcHV0XzEgPSBwdXQ7XG4gICAgdmFyIHNlbmRfMSA9IHNlbmQ7XG5cbiAgICB2YXIgZmV0Y2hfMSA9IHtcbiAgICBcdGRlbDogZGVsXzEsXG4gICAgXHRnZXQ6IGdldF8xLFxuICAgIFx0cGF0Y2g6IHBhdGNoXzEsXG4gICAgXHRwb3N0OiBwb3N0XzEsXG4gICAgXHRwdXQ6IHB1dF8xLFxuICAgIFx0c2VuZDogc2VuZF8xXG4gICAgfTtcblxuICAgIHZhciBodHRwID0gLyojX19QVVJFX18qL19tZXJnZU5hbWVzcGFjZXMoe1xuICAgICAgICBfX3Byb3RvX186IG51bGwsXG4gICAgICAgICdkZWZhdWx0JzogZmV0Y2hfMSxcbiAgICAgICAgZGVsOiBkZWxfMSxcbiAgICAgICAgZ2V0OiBnZXRfMSxcbiAgICAgICAgcGF0Y2g6IHBhdGNoXzEsXG4gICAgICAgIHBvc3Q6IHBvc3RfMSxcbiAgICAgICAgcHV0OiBwdXRfMSxcbiAgICAgICAgc2VuZDogc2VuZF8xXG4gICAgfSwgW2ZldGNoXzFdKTtcblxuICAgIHZhciBDbG9zZUNvZGU7XG4gICAgKGZ1bmN0aW9uIChDbG9zZUNvZGUpIHtcbiAgICAgICAgQ2xvc2VDb2RlW0Nsb3NlQ29kZVtcIkNPTlNFTlRFRFwiXSA9IDQwMDBdID0gXCJDT05TRU5URURcIjtcbiAgICAgICAgQ2xvc2VDb2RlW0Nsb3NlQ29kZVtcIkRFVk1PREVfUkVTVEFSVFwiXSA9IDQwMTBdID0gXCJERVZNT0RFX1JFU1RBUlRcIjtcbiAgICB9KShDbG9zZUNvZGUgfHwgKENsb3NlQ29kZSA9IHt9KSk7XG4gICAgdmFyIFNlcnZlckVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoU2VydmVyRXJyb3IsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFNlcnZlckVycm9yKGNvZGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1lc3NhZ2UpIHx8IHRoaXM7XG4gICAgICAgICAgICBfdGhpcy5uYW1lID0gXCJTZXJ2ZXJFcnJvclwiO1xuICAgICAgICAgICAgX3RoaXMuY29kZSA9IGNvZGU7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFNlcnZlckVycm9yO1xuICAgIH0oRXJyb3IpKTtcblxuICAgIC8qKlxuICAgICAqIENvcHlyaWdodCAoYykgMjAxNCBJb24gRHJpdmUgU29mdHdhcmUgTHRkLlxuICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9kYXJyYWNoZXF1ZXNuZS9ub3RlcGFjay9cbiAgICAgKlxuICAgICAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAgICAgKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gICAgICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICAgICAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAgICAgKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAgICAgKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICAgICAqXG4gICAgICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gICAgICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAgICAgKlxuICAgICAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAgICAgKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAgICAgKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAgICAgKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gICAgICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAgICAgKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICAgICAqIFNPRlRXQVJFLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFBhdGNoIGZvciBDb2x5c2V1czpcbiAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICogbm90ZXBhY2suaW9AMy4wLjFcbiAgICAgKlxuICAgICAqIGFkZGVkIGBvZmZzZXRgIG9uIERlY29kZXIgY29uc3RydWN0b3IsIGZvciBtZXNzYWdlcyBhcnJpdmluZyB3aXRoIGEgY29kZVxuICAgICAqIGJlZm9yZSBhY3R1YWwgbXNncGFjayBkYXRhXG4gICAgICovXG4gICAgLy9cbiAgICAvLyBERUNPREVSXG4gICAgLy9cbiAgICBmdW5jdGlvbiBEZWNvZGVyKGJ1ZmZlciwgb2Zmc2V0KSB7XG4gICAgICAgIHRoaXMuX29mZnNldCA9IG9mZnNldDtcbiAgICAgICAgaWYgKGJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9idWZmZXIgPSBidWZmZXI7XG4gICAgICAgICAgICB0aGlzLl92aWV3ID0gbmV3IERhdGFWaWV3KHRoaXMuX2J1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGJ1ZmZlcikpIHtcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlciA9IGJ1ZmZlci5idWZmZXI7XG4gICAgICAgICAgICB0aGlzLl92aWV3ID0gbmV3IERhdGFWaWV3KHRoaXMuX2J1ZmZlciwgYnVmZmVyLmJ5dGVPZmZzZXQsIGJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHV0ZjhSZWFkJDEodmlldywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHN0cmluZyA9ICcnLCBjaHIgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gb2Zmc2V0LCBlbmQgPSBvZmZzZXQgKyBsZW5ndGg7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICAgICAgdmFyIGJ5dGUgPSB2aWV3LmdldFVpbnQ4KGkpO1xuICAgICAgICAgICAgaWYgKChieXRlICYgMHg4MCkgPT09IDB4MDApIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoYnl0ZSAmIDB4ZTApID09PSAweGMwKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChieXRlICYgMHgxZikgPDwgNikgfFxuICAgICAgICAgICAgICAgICAgICAodmlldy5nZXRVaW50OCgrK2kpICYgMHgzZikpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChieXRlICYgMHhmMCkgPT09IDB4ZTApIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGJ5dGUgJiAweDBmKSA8PCAxMikgfFxuICAgICAgICAgICAgICAgICAgICAoKHZpZXcuZ2V0VWludDgoKytpKSAmIDB4M2YpIDw8IDYpIHxcbiAgICAgICAgICAgICAgICAgICAgKCh2aWV3LmdldFVpbnQ4KCsraSkgJiAweDNmKSA8PCAwKSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGJ5dGUgJiAweGY4KSA9PT0gMHhmMCkge1xuICAgICAgICAgICAgICAgIGNociA9ICgoYnl0ZSAmIDB4MDcpIDw8IDE4KSB8XG4gICAgICAgICAgICAgICAgICAgICgodmlldy5nZXRVaW50OCgrK2kpICYgMHgzZikgPDwgMTIpIHxcbiAgICAgICAgICAgICAgICAgICAgKCh2aWV3LmdldFVpbnQ4KCsraSkgJiAweDNmKSA8PCA2KSB8XG4gICAgICAgICAgICAgICAgICAgICgodmlldy5nZXRVaW50OCgrK2kpICYgMHgzZikgPDwgMCk7XG4gICAgICAgICAgICAgICAgaWYgKGNociA+PSAweDAxMDAwMCkgeyAvLyBzdXJyb2dhdGUgcGFpclxuICAgICAgICAgICAgICAgICAgICBjaHIgLT0gMHgwMTAwMDA7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjaHIgPj4+IDEwKSArIDB4RDgwMCwgKGNociAmIDB4M0ZGKSArIDB4REMwMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaHIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBieXRlICcgKyBieXRlLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICB9XG4gICAgRGVjb2Rlci5wcm90b3R5cGUuX2FycmF5ID0gZnVuY3Rpb24gKGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFsdWVbaV0gPSB0aGlzLl9wYXJzZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIERlY29kZXIucHJvdG90eXBlLl9tYXAgPSBmdW5jdGlvbiAobGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSAnJywgdmFsdWUgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAga2V5ID0gdGhpcy5fcGFyc2UoKTtcbiAgICAgICAgICAgIHZhbHVlW2tleV0gPSB0aGlzLl9wYXJzZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIERlY29kZXIucHJvdG90eXBlLl9zdHIgPSBmdW5jdGlvbiAobGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHV0ZjhSZWFkJDEodGhpcy5fdmlldywgdGhpcy5fb2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgICB0aGlzLl9vZmZzZXQgKz0gbGVuZ3RoO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBEZWNvZGVyLnByb3RvdHlwZS5fYmluID0gZnVuY3Rpb24gKGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9idWZmZXIuc2xpY2UodGhpcy5fb2Zmc2V0LCB0aGlzLl9vZmZzZXQgKyBsZW5ndGgpO1xuICAgICAgICB0aGlzLl9vZmZzZXQgKz0gbGVuZ3RoO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBEZWNvZGVyLnByb3RvdHlwZS5fcGFyc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcmVmaXggPSB0aGlzLl92aWV3LmdldFVpbnQ4KHRoaXMuX29mZnNldCsrKTtcbiAgICAgICAgdmFyIHZhbHVlLCBsZW5ndGggPSAwLCB0eXBlID0gMCwgaGkgPSAwLCBsbyA9IDA7XG4gICAgICAgIGlmIChwcmVmaXggPCAweGMwKSB7XG4gICAgICAgICAgICAvLyBwb3NpdGl2ZSBmaXhpbnRcbiAgICAgICAgICAgIGlmIChwcmVmaXggPCAweDgwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZWZpeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGZpeG1hcFxuICAgICAgICAgICAgaWYgKHByZWZpeCA8IDB4OTApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbWFwKHByZWZpeCAmIDB4MGYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZml4YXJyYXlcbiAgICAgICAgICAgIGlmIChwcmVmaXggPCAweGEwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FycmF5KHByZWZpeCAmIDB4MGYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZml4c3RyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RyKHByZWZpeCAmIDB4MWYpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5lZ2F0aXZlIGZpeGludFxuICAgICAgICBpZiAocHJlZml4ID4gMHhkZikge1xuICAgICAgICAgICAgcmV0dXJuICgweGZmIC0gcHJlZml4ICsgMSkgKiAtMTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHByZWZpeCkge1xuICAgICAgICAgICAgLy8gbmlsXG4gICAgICAgICAgICBjYXNlIDB4YzA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAvLyBmYWxzZVxuICAgICAgICAgICAgY2FzZSAweGMyOlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIC8vIHRydWVcbiAgICAgICAgICAgIGNhc2UgMHhjMzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIC8vIGJpblxuICAgICAgICAgICAgY2FzZSAweGM0OlxuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHRoaXMuX3ZpZXcuZ2V0VWludDgodGhpcy5fb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vZmZzZXQgKz0gMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYmluKGxlbmd0aCk7XG4gICAgICAgICAgICBjYXNlIDB4YzU6XG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gdGhpcy5fdmlldy5nZXRVaW50MTYodGhpcy5fb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vZmZzZXQgKz0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYmluKGxlbmd0aCk7XG4gICAgICAgICAgICBjYXNlIDB4YzY6XG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gdGhpcy5fdmlldy5nZXRVaW50MzIodGhpcy5fb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vZmZzZXQgKz0gNDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYmluKGxlbmd0aCk7XG4gICAgICAgICAgICAvLyBleHRcbiAgICAgICAgICAgIGNhc2UgMHhjNzpcbiAgICAgICAgICAgICAgICBsZW5ndGggPSB0aGlzLl92aWV3LmdldFVpbnQ4KHRoaXMuX29mZnNldCk7XG4gICAgICAgICAgICAgICAgdHlwZSA9IHRoaXMuX3ZpZXcuZ2V0SW50OCh0aGlzLl9vZmZzZXQgKyAxKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vZmZzZXQgKz0gMjtcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGltZXN0YW1wIDk2XG4gICAgICAgICAgICAgICAgICAgIHZhciBucyA9IHRoaXMuX3ZpZXcuZ2V0VWludDMyKHRoaXMuX29mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIGhpID0gdGhpcy5fdmlldy5nZXRJbnQzMih0aGlzLl9vZmZzZXQgKyA0KTtcbiAgICAgICAgICAgICAgICAgICAgbG8gPSB0aGlzLl92aWV3LmdldFVpbnQzMih0aGlzLl9vZmZzZXQgKyA4KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ICs9IDEyO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoKGhpICogMHgxMDAwMDAwMDAgKyBsbykgKiAxZTMgKyBucyAvIDFlNik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbdHlwZSwgdGhpcy5fYmluKGxlbmd0aCldO1xuICAgICAgICAgICAgY2FzZSAweGM4OlxuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHRoaXMuX3ZpZXcuZ2V0VWludDE2KHRoaXMuX29mZnNldCk7XG4gICAgICAgICAgICAgICAgdHlwZSA9IHRoaXMuX3ZpZXcuZ2V0SW50OCh0aGlzLl9vZmZzZXQgKyAyKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vZmZzZXQgKz0gMztcbiAgICAgICAgICAgICAgICByZXR1cm4gW3R5cGUsIHRoaXMuX2JpbihsZW5ndGgpXTtcbiAgICAgICAgICAgIGNhc2UgMHhjOTpcbiAgICAgICAgICAgICAgICBsZW5ndGggPSB0aGlzLl92aWV3LmdldFVpbnQzMih0aGlzLl9vZmZzZXQpO1xuICAgICAgICAgICAgICAgIHR5cGUgPSB0aGlzLl92aWV3LmdldEludDgodGhpcy5fb2Zmc2V0ICsgNCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ICs9IDU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFt0eXBlLCB0aGlzLl9iaW4obGVuZ3RoKV07XG4gICAgICAgICAgICAvLyBmbG9hdFxuICAgICAgICAgICAgY2FzZSAweGNhOlxuICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fdmlldy5nZXRGbG9hdDMyKHRoaXMuX29mZnNldCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgY2FzZSAweGNiOlxuICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fdmlldy5nZXRGbG9hdDY0KHRoaXMuX29mZnNldCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ICs9IDg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgLy8gdWludFxuICAgICAgICAgICAgY2FzZSAweGNjOlxuICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fdmlldy5nZXRVaW50OCh0aGlzLl9vZmZzZXQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX29mZnNldCArPSAxO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIGNhc2UgMHhjZDpcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX3ZpZXcuZ2V0VWludDE2KHRoaXMuX29mZnNldCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ICs9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgY2FzZSAweGNlOlxuICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fdmlldy5nZXRVaW50MzIodGhpcy5fb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vZmZzZXQgKz0gNDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICBjYXNlIDB4Y2Y6XG4gICAgICAgICAgICAgICAgaGkgPSB0aGlzLl92aWV3LmdldFVpbnQzMih0aGlzLl9vZmZzZXQpICogTWF0aC5wb3coMiwgMzIpO1xuICAgICAgICAgICAgICAgIGxvID0gdGhpcy5fdmlldy5nZXRVaW50MzIodGhpcy5fb2Zmc2V0ICsgNCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ICs9IDg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhpICsgbG87XG4gICAgICAgICAgICAvLyBpbnRcbiAgICAgICAgICAgIGNhc2UgMHhkMDpcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX3ZpZXcuZ2V0SW50OCh0aGlzLl9vZmZzZXQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX29mZnNldCArPSAxO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIGNhc2UgMHhkMTpcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX3ZpZXcuZ2V0SW50MTYodGhpcy5fb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vZmZzZXQgKz0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICBjYXNlIDB4ZDI6XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLl92aWV3LmdldEludDMyKHRoaXMuX29mZnNldCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgY2FzZSAweGQzOlxuICAgICAgICAgICAgICAgIGhpID0gdGhpcy5fdmlldy5nZXRJbnQzMih0aGlzLl9vZmZzZXQpICogTWF0aC5wb3coMiwgMzIpO1xuICAgICAgICAgICAgICAgIGxvID0gdGhpcy5fdmlldy5nZXRVaW50MzIodGhpcy5fb2Zmc2V0ICsgNCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ICs9IDg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhpICsgbG87XG4gICAgICAgICAgICAvLyBmaXhleHRcbiAgICAgICAgICAgIGNhc2UgMHhkNDpcbiAgICAgICAgICAgICAgICB0eXBlID0gdGhpcy5fdmlldy5nZXRJbnQ4KHRoaXMuX29mZnNldCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ICs9IDE7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IDB4MDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY3VzdG9tIGVuY29kaW5nIGZvciAndW5kZWZpbmVkJyAoa2VwdCBmb3IgYmFja3dhcmQtY29tcGF0aWJpbGl0eSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbdHlwZSwgdGhpcy5fYmluKDEpXTtcbiAgICAgICAgICAgIGNhc2UgMHhkNTpcbiAgICAgICAgICAgICAgICB0eXBlID0gdGhpcy5fdmlldy5nZXRJbnQ4KHRoaXMuX29mZnNldCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ICs9IDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFt0eXBlLCB0aGlzLl9iaW4oMildO1xuICAgICAgICAgICAgY2FzZSAweGQ2OlxuICAgICAgICAgICAgICAgIHR5cGUgPSB0aGlzLl92aWV3LmdldEludDgodGhpcy5fb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vZmZzZXQgKz0gMTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGltZXN0YW1wIDMyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fdmlldy5nZXRVaW50MzIodGhpcy5fb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh2YWx1ZSAqIDFlMyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbdHlwZSwgdGhpcy5fYmluKDQpXTtcbiAgICAgICAgICAgIGNhc2UgMHhkNzpcbiAgICAgICAgICAgICAgICB0eXBlID0gdGhpcy5fdmlldy5nZXRJbnQ4KHRoaXMuX29mZnNldCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ICs9IDE7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IDB4MDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY3VzdG9tIGRhdGUgZW5jb2RpbmcgKGtlcHQgZm9yIGJhY2t3YXJkLWNvbXBhdGliaWxpdHkpXG4gICAgICAgICAgICAgICAgICAgIGhpID0gdGhpcy5fdmlldy5nZXRJbnQzMih0aGlzLl9vZmZzZXQpICogTWF0aC5wb3coMiwgMzIpO1xuICAgICAgICAgICAgICAgICAgICBsbyA9IHRoaXMuX3ZpZXcuZ2V0VWludDMyKHRoaXMuX29mZnNldCArIDQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vZmZzZXQgKz0gODtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGhpICsgbG8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGltZXN0YW1wIDY0XG4gICAgICAgICAgICAgICAgICAgIGhpID0gdGhpcy5fdmlldy5nZXRVaW50MzIodGhpcy5fb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgbG8gPSB0aGlzLl92aWV3LmdldFVpbnQzMih0aGlzLl9vZmZzZXQgKyA0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ICs9IDg7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzID0gKGhpICYgMHgzKSAqIDB4MTAwMDAwMDAwICsgbG87XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShzICogMWUzICsgKGhpID4+PiAyKSAvIDFlNik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbdHlwZSwgdGhpcy5fYmluKDgpXTtcbiAgICAgICAgICAgIGNhc2UgMHhkODpcbiAgICAgICAgICAgICAgICB0eXBlID0gdGhpcy5fdmlldy5nZXRJbnQ4KHRoaXMuX29mZnNldCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ICs9IDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFt0eXBlLCB0aGlzLl9iaW4oMTYpXTtcbiAgICAgICAgICAgIC8vIHN0clxuICAgICAgICAgICAgY2FzZSAweGQ5OlxuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHRoaXMuX3ZpZXcuZ2V0VWludDgodGhpcy5fb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vZmZzZXQgKz0gMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RyKGxlbmd0aCk7XG4gICAgICAgICAgICBjYXNlIDB4ZGE6XG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gdGhpcy5fdmlldy5nZXRVaW50MTYodGhpcy5fb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vZmZzZXQgKz0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RyKGxlbmd0aCk7XG4gICAgICAgICAgICBjYXNlIDB4ZGI6XG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gdGhpcy5fdmlldy5nZXRVaW50MzIodGhpcy5fb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vZmZzZXQgKz0gNDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RyKGxlbmd0aCk7XG4gICAgICAgICAgICAvLyBhcnJheVxuICAgICAgICAgICAgY2FzZSAweGRjOlxuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHRoaXMuX3ZpZXcuZ2V0VWludDE2KHRoaXMuX29mZnNldCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ICs9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FycmF5KGxlbmd0aCk7XG4gICAgICAgICAgICBjYXNlIDB4ZGQ6XG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gdGhpcy5fdmlldy5nZXRVaW50MzIodGhpcy5fb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vZmZzZXQgKz0gNDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYXJyYXkobGVuZ3RoKTtcbiAgICAgICAgICAgIC8vIG1hcFxuICAgICAgICAgICAgY2FzZSAweGRlOlxuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHRoaXMuX3ZpZXcuZ2V0VWludDE2KHRoaXMuX29mZnNldCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ICs9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21hcChsZW5ndGgpO1xuICAgICAgICAgICAgY2FzZSAweGRmOlxuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHRoaXMuX3ZpZXcuZ2V0VWludDMyKHRoaXMuX29mZnNldCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21hcChsZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IHBhcnNlJyk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBkZWNvZGUoYnVmZmVyLCBvZmZzZXQpIHtcbiAgICAgICAgaWYgKG9mZnNldCA9PT0gdm9pZCAwKSB7IG9mZnNldCA9IDA7IH1cbiAgICAgICAgdmFyIGRlY29kZXIgPSBuZXcgRGVjb2RlcihidWZmZXIsIG9mZnNldCk7XG4gICAgICAgIHZhciB2YWx1ZSA9IGRlY29kZXIuX3BhcnNlKCk7XG4gICAgICAgIGlmIChkZWNvZGVyLl9vZmZzZXQgIT09IGJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKGJ1ZmZlci5ieXRlTGVuZ3RoIC0gZGVjb2Rlci5fb2Zmc2V0KSArICcgdHJhaWxpbmcgYnl0ZXMnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIC8vXG4gICAgLy8gRU5DT0RFUlxuICAgIC8vXG4gICAgdmFyIFRJTUVTVEFNUDMyX01BWF9TRUMgPSAweDEwMDAwMDAwMCAtIDE7IC8vIDMyLWJpdCB1bnNpZ25lZCBpbnRcbiAgICB2YXIgVElNRVNUQU1QNjRfTUFYX1NFQyA9IDB4NDAwMDAwMDAwIC0gMTsgLy8gMzQtYml0IHVuc2lnbmVkIGludFxuICAgIGZ1bmN0aW9uIHV0ZjhXcml0ZSh2aWV3LCBvZmZzZXQsIHN0cikge1xuICAgICAgICB2YXIgYyA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gc3RyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgaWYgKGMgPCAweDgwKSB7XG4gICAgICAgICAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjIDwgMHg4MDApIHtcbiAgICAgICAgICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCAweGMwIHwgKGMgPj4gNikpO1xuICAgICAgICAgICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIDB4ODAgfCAoYyAmIDB4M2YpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGMgPCAweGQ4MDAgfHwgYyA+PSAweGUwMDApIHtcbiAgICAgICAgICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCAweGUwIHwgKGMgPj4gMTIpKTtcbiAgICAgICAgICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCAweDgwIHwgKGMgPj4gNikgJiAweDNmKTtcbiAgICAgICAgICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCAweDgwIHwgKGMgJiAweDNmKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgYyA9IDB4MTAwMDAgKyAoKChjICYgMHgzZmYpIDw8IDEwKSB8IChzdHIuY2hhckNvZGVBdChpKSAmIDB4M2ZmKSk7XG4gICAgICAgICAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgMHhmMCB8IChjID4+IDE4KSk7XG4gICAgICAgICAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgMHg4MCB8IChjID4+IDEyKSAmIDB4M2YpO1xuICAgICAgICAgICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIDB4ODAgfCAoYyA+PiA2KSAmIDB4M2YpO1xuICAgICAgICAgICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIDB4ODAgfCAoYyAmIDB4M2YpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB1dGY4TGVuZ3RoJDEoc3RyKSB7XG4gICAgICAgIHZhciBjID0gMCwgbGVuZ3RoID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdHIubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgICAgICAgICAgICBsZW5ndGggKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGMgPCAweDgwMCkge1xuICAgICAgICAgICAgICAgIGxlbmd0aCArPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYyA8IDB4ZDgwMCB8fCBjID49IDB4ZTAwMCkge1xuICAgICAgICAgICAgICAgIGxlbmd0aCArPSAzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIGxlbmd0aCArPSA0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9lbmNvZGUoYnl0ZXMsIGRlZmVycywgdmFsdWUpIHtcbiAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWUsIGkgPSAwLCBsID0gMCwgaGkgPSAwLCBsbyA9IDAsIGxlbmd0aCA9IDAsIHNpemUgPSAwO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGxlbmd0aCA9IHV0ZjhMZW5ndGgkMSh2YWx1ZSk7XG4gICAgICAgICAgICAvLyBmaXhzdHJcbiAgICAgICAgICAgIGlmIChsZW5ndGggPCAweDIwKSB7XG4gICAgICAgICAgICAgICAgYnl0ZXMucHVzaChsZW5ndGggfCAweGEwKTtcbiAgICAgICAgICAgICAgICBzaXplID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHN0ciA4XG4gICAgICAgICAgICBlbHNlIGlmIChsZW5ndGggPCAweDEwMCkge1xuICAgICAgICAgICAgICAgIGJ5dGVzLnB1c2goMHhkOSwgbGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBzaXplID0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHN0ciAxNlxuICAgICAgICAgICAgZWxzZSBpZiAobGVuZ3RoIDwgMHgxMDAwMCkge1xuICAgICAgICAgICAgICAgIGJ5dGVzLnB1c2goMHhkYSwgbGVuZ3RoID4+IDgsIGxlbmd0aCk7XG4gICAgICAgICAgICAgICAgc2l6ZSA9IDM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzdHIgMzJcbiAgICAgICAgICAgIGVsc2UgaWYgKGxlbmd0aCA8IDB4MTAwMDAwMDAwKSB7XG4gICAgICAgICAgICAgICAgYnl0ZXMucHVzaCgweGRiLCBsZW5ndGggPj4gMjQsIGxlbmd0aCA+PiAxNiwgbGVuZ3RoID4+IDgsIGxlbmd0aCk7XG4gICAgICAgICAgICAgICAgc2l6ZSA9IDU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0cmluZyB0b28gbG9uZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmZXJzLnB1c2goeyBfc3RyOiB2YWx1ZSwgX2xlbmd0aDogbGVuZ3RoLCBfb2Zmc2V0OiBieXRlcy5sZW5ndGggfSk7XG4gICAgICAgICAgICByZXR1cm4gc2l6ZSArIGxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IGVuY29kZSB0byBmbG9hdCAzMj9cbiAgICAgICAgICAgIC8vIGZsb2F0IDY0XG4gICAgICAgICAgICBpZiAoTWF0aC5mbG9vcih2YWx1ZSkgIT09IHZhbHVlIHx8ICFpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBieXRlcy5wdXNoKDB4Y2IpO1xuICAgICAgICAgICAgICAgIGRlZmVycy5wdXNoKHsgX2Zsb2F0OiB2YWx1ZSwgX2xlbmd0aDogOCwgX29mZnNldDogYnl0ZXMubGVuZ3RoIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiA5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlID49IDApIHtcbiAgICAgICAgICAgICAgICAvLyBwb3NpdGl2ZSBmaXhudW1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPCAweDgwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gdWludCA4XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIDwgMHgxMDApIHtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZXMucHVzaCgweGNjLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB1aW50IDE2XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIDwgMHgxMDAwMCkge1xuICAgICAgICAgICAgICAgICAgICBieXRlcy5wdXNoKDB4Y2QsIHZhbHVlID4+IDgsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHVpbnQgMzJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPCAweDEwMDAwMDAwMCkge1xuICAgICAgICAgICAgICAgICAgICBieXRlcy5wdXNoKDB4Y2UsIHZhbHVlID4+IDI0LCB2YWx1ZSA+PiAxNiwgdmFsdWUgPj4gOCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gNTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gdWludCA2NFxuICAgICAgICAgICAgICAgIGhpID0gKHZhbHVlIC8gTWF0aC5wb3coMiwgMzIpKSA+PiAwO1xuICAgICAgICAgICAgICAgIGxvID0gdmFsdWUgPj4+IDA7XG4gICAgICAgICAgICAgICAgYnl0ZXMucHVzaCgweGNmLCBoaSA+PiAyNCwgaGkgPj4gMTYsIGhpID4+IDgsIGhpLCBsbyA+PiAyNCwgbG8gPj4gMTYsIGxvID4+IDgsIGxvKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gOTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG5lZ2F0aXZlIGZpeG51bVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA+PSAtMHgyMCkge1xuICAgICAgICAgICAgICAgICAgICBieXRlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGludCA4XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID49IC0weDgwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVzLnB1c2goMHhkMCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaW50IDE2XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID49IC0weDgwMDApIHtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZXMucHVzaCgweGQxLCB2YWx1ZSA+PiA4LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpbnQgMzJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPj0gLTB4ODAwMDAwMDApIHtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZXMucHVzaCgweGQyLCB2YWx1ZSA+PiAyNCwgdmFsdWUgPj4gMTYsIHZhbHVlID4+IDgsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGludCA2NFxuICAgICAgICAgICAgICAgIGhpID0gTWF0aC5mbG9vcih2YWx1ZSAvIE1hdGgucG93KDIsIDMyKSk7XG4gICAgICAgICAgICAgICAgbG8gPSB2YWx1ZSA+Pj4gMDtcbiAgICAgICAgICAgICAgICBieXRlcy5wdXNoKDB4ZDMsIGhpID4+IDI0LCBoaSA+PiAxNiwgaGkgPj4gOCwgaGksIGxvID4+IDI0LCBsbyA+PiAxNiwgbG8gPj4gOCwgbG8pO1xuICAgICAgICAgICAgICAgIHJldHVybiA5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgLy8gbmlsXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBieXRlcy5wdXNoKDB4YzApO1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIC8vIGZpeGFycmF5XG4gICAgICAgICAgICAgICAgaWYgKGxlbmd0aCA8IDB4MTApIHtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZXMucHVzaChsZW5ndGggfCAweDkwKTtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGFycmF5IDE2XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobGVuZ3RoIDwgMHgxMDAwMCkge1xuICAgICAgICAgICAgICAgICAgICBieXRlcy5wdXNoKDB4ZGMsIGxlbmd0aCA+PiA4LCBsZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBzaXplID0gMztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYXJyYXkgMzJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChsZW5ndGggPCAweDEwMDAwMDAwMCkge1xuICAgICAgICAgICAgICAgICAgICBieXRlcy5wdXNoKDB4ZGQsIGxlbmd0aCA+PiAyNCwgbGVuZ3RoID4+IDE2LCBsZW5ndGggPj4gOCwgbGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSA9IDU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FycmF5IHRvbyBsYXJnZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSArPSBfZW5jb2RlKGJ5dGVzLCBkZWZlcnMsIHZhbHVlW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1zID0gdmFsdWUuZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgIHZhciBzID0gTWF0aC5mbG9vcihtcyAvIDFlMyk7XG4gICAgICAgICAgICAgICAgdmFyIG5zID0gKG1zIC0gcyAqIDFlMykgKiAxZTY7XG4gICAgICAgICAgICAgICAgaWYgKHMgPj0gMCAmJiBucyA+PSAwICYmIHMgPD0gVElNRVNUQU1QNjRfTUFYX1NFQykge1xuICAgICAgICAgICAgICAgICAgICBpZiAobnMgPT09IDAgJiYgcyA8PSBUSU1FU1RBTVAzMl9NQVhfU0VDKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aW1lc3RhbXAgMzJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzLnB1c2goMHhkNiwgMHhmZiwgcyA+PiAyNCwgcyA+PiAxNiwgcyA+PiA4LCBzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA2O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGltZXN0YW1wIDY0XG4gICAgICAgICAgICAgICAgICAgICAgICBoaSA9IHMgLyAweDEwMDAwMDAwMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvID0gcyAmIDB4ZmZmZmZmZmY7XG4gICAgICAgICAgICAgICAgICAgICAgICBieXRlcy5wdXNoKDB4ZDcsIDB4ZmYsIG5zID4+IDIyLCBucyA+PiAxNCwgbnMgPj4gNiwgaGksIGxvID4+IDI0LCBsbyA+PiAxNiwgbG8gPj4gOCwgbG8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDEwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aW1lc3RhbXAgOTZcbiAgICAgICAgICAgICAgICAgICAgaGkgPSBNYXRoLmZsb29yKHMgLyAweDEwMDAwMDAwMCk7XG4gICAgICAgICAgICAgICAgICAgIGxvID0gcyA+Pj4gMDtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZXMucHVzaCgweGM3LCAweDBjLCAweGZmLCBucyA+PiAyNCwgbnMgPj4gMTYsIG5zID4+IDgsIG5zLCBoaSA+PiAyNCwgaGkgPj4gMTYsIGhpID4+IDgsIGhpLCBsbyA+PiAyNCwgbG8gPj4gMTYsIGxvID4+IDgsIGxvKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE1O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gdmFsdWUuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgICAvLyBiaW4gOFxuICAgICAgICAgICAgICAgIGlmIChsZW5ndGggPCAweDEwMCkge1xuICAgICAgICAgICAgICAgICAgICBieXRlcy5wdXNoKDB4YzQsIGxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIHNpemUgPSAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIFxuICAgICAgICAgICAgICAgIC8vIGJpbiAxNlxuICAgICAgICAgICAgICAgIGlmIChsZW5ndGggPCAweDEwMDAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVzLnB1c2goMHhjNSwgbGVuZ3RoID4+IDgsIGxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIHNpemUgPSAzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIFxuICAgICAgICAgICAgICAgIC8vIGJpbiAzMlxuICAgICAgICAgICAgICAgIGlmIChsZW5ndGggPCAweDEwMDAwMDAwMCkge1xuICAgICAgICAgICAgICAgICAgICBieXRlcy5wdXNoKDB4YzYsIGxlbmd0aCA+PiAyNCwgbGVuZ3RoID4+IDE2LCBsZW5ndGggPj4gOCwgbGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSA9IDU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0J1ZmZlciB0b28gbGFyZ2UnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmZXJzLnB1c2goeyBfYmluOiB2YWx1ZSwgX2xlbmd0aDogbGVuZ3RoLCBfb2Zmc2V0OiBieXRlcy5sZW5ndGggfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpemUgKyBsZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZW5jb2RlKGJ5dGVzLCBkZWZlcnMsIHZhbHVlLnRvSlNPTigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBrZXlzID0gW10sIGtleSA9ICcnO1xuICAgICAgICAgICAgdmFyIGFsbEtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gYWxsS2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBhbGxLZXlzW2ldO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZVtrZXldICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHZhbHVlW2tleV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgICAgICAgICAvLyBmaXhtYXBcbiAgICAgICAgICAgIGlmIChsZW5ndGggPCAweDEwKSB7XG4gICAgICAgICAgICAgICAgYnl0ZXMucHVzaChsZW5ndGggfCAweDgwKTtcbiAgICAgICAgICAgICAgICBzaXplID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG1hcCAxNlxuICAgICAgICAgICAgZWxzZSBpZiAobGVuZ3RoIDwgMHgxMDAwMCkge1xuICAgICAgICAgICAgICAgIGJ5dGVzLnB1c2goMHhkZSwgbGVuZ3RoID4+IDgsIGxlbmd0aCk7XG4gICAgICAgICAgICAgICAgc2l6ZSA9IDM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBtYXAgMzJcbiAgICAgICAgICAgIGVsc2UgaWYgKGxlbmd0aCA8IDB4MTAwMDAwMDAwKSB7XG4gICAgICAgICAgICAgICAgYnl0ZXMucHVzaCgweGRmLCBsZW5ndGggPj4gMjQsIGxlbmd0aCA+PiAxNiwgbGVuZ3RoID4+IDgsIGxlbmd0aCk7XG4gICAgICAgICAgICAgICAgc2l6ZSA9IDU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09iamVjdCB0b28gbGFyZ2UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICAgICAgc2l6ZSArPSBfZW5jb2RlKGJ5dGVzLCBkZWZlcnMsIGtleSk7XG4gICAgICAgICAgICAgICAgc2l6ZSArPSBfZW5jb2RlKGJ5dGVzLCBkZWZlcnMsIHZhbHVlW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmFsc2UvdHJ1ZVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBieXRlcy5wdXNoKHZhbHVlID8gMHhjMyA6IDB4YzIpO1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBieXRlcy5wdXNoKDB4YzApO1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY3VzdG9tIHR5cGVzIGxpa2UgQmlnSW50ICh0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnKVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIF9lbmNvZGUoYnl0ZXMsIGRlZmVycywgdmFsdWUudG9KU09OKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGVuY29kZScpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbmNvZGUodmFsdWUpIHtcbiAgICAgICAgdmFyIGJ5dGVzID0gW107XG4gICAgICAgIHZhciBkZWZlcnMgPSBbXTtcbiAgICAgICAgdmFyIHNpemUgPSBfZW5jb2RlKGJ5dGVzLCBkZWZlcnMsIHZhbHVlKTtcbiAgICAgICAgdmFyIGJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcihzaXplKTtcbiAgICAgICAgdmFyIHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmKTtcbiAgICAgICAgdmFyIGRlZmVySW5kZXggPSAwO1xuICAgICAgICB2YXIgZGVmZXJXcml0dGVuID0gMDtcbiAgICAgICAgdmFyIG5leHRPZmZzZXQgPSAtMTtcbiAgICAgICAgaWYgKGRlZmVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBuZXh0T2Zmc2V0ID0gZGVmZXJzWzBdLl9vZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlZmVyLCBkZWZlckxlbmd0aCA9IDAsIG9mZnNldCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gYnl0ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICB2aWV3LnNldFVpbnQ4KGRlZmVyV3JpdHRlbiArIGksIGJ5dGVzW2ldKTtcbiAgICAgICAgICAgIGlmIChpICsgMSAhPT0gbmV4dE9mZnNldCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmZXIgPSBkZWZlcnNbZGVmZXJJbmRleF07XG4gICAgICAgICAgICBkZWZlckxlbmd0aCA9IGRlZmVyLl9sZW5ndGg7XG4gICAgICAgICAgICBvZmZzZXQgPSBkZWZlcldyaXR0ZW4gKyBuZXh0T2Zmc2V0O1xuICAgICAgICAgICAgaWYgKGRlZmVyLl9iaW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgYmluID0gbmV3IFVpbnQ4QXJyYXkoZGVmZXIuX2Jpbik7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkZWZlckxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0ICsgaiwgYmluW2pdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkZWZlci5fc3RyKSB7XG4gICAgICAgICAgICAgICAgdXRmOFdyaXRlKHZpZXcsIG9mZnNldCwgZGVmZXIuX3N0cik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkZWZlci5fZmxvYXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZpZXcuc2V0RmxvYXQ2NChvZmZzZXQsIGRlZmVyLl9mbG9hdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZlckluZGV4Kys7XG4gICAgICAgICAgICBkZWZlcldyaXR0ZW4gKz0gZGVmZXJMZW5ndGg7XG4gICAgICAgICAgICBpZiAoZGVmZXJzW2RlZmVySW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgbmV4dE9mZnNldCA9IGRlZmVyc1tkZWZlckluZGV4XS5fb2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWY7XG4gICAgfVxuXG4gICAgdmFyIGJyb3dzZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICd3cyBkb2VzIG5vdCB3b3JrIGluIHRoZSBicm93c2VyLiBCcm93c2VyIGNsaWVudHMgbXVzdCB1c2UgdGhlIG5hdGl2ZSAnICtcbiAgICAgICAgICAnV2ViU29ja2V0IG9iamVjdCdcbiAgICAgICk7XG4gICAgfTtcblxuICAgIHZhciBXZWJTb2NrZXQgPSBnbG9iYWxUaGlzLldlYlNvY2tldCB8fCBicm93c2VyO1xuICAgIHZhciBXZWJTb2NrZXRUcmFuc3BvcnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFdlYlNvY2tldFRyYW5zcG9ydChldmVudHMpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzID0gZXZlbnRzO1xuICAgICAgICB9XG4gICAgICAgIFdlYlNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53cy5zZW5kKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgICAgIHRoaXMud3Muc2VuZCgobmV3IFVpbnQ4QXJyYXkoZGF0YSkpLmJ1ZmZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFdlYlNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgICAgIHRoaXMud3MgPSBuZXcgV2ViU29ja2V0KHVybCwgdGhpcy5wcm90b2NvbHMpO1xuICAgICAgICAgICAgdGhpcy53cy5iaW5hcnlUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICAgICAgICAgIHRoaXMud3Mub25vcGVuID0gdGhpcy5ldmVudHMub25vcGVuO1xuICAgICAgICAgICAgdGhpcy53cy5vbm1lc3NhZ2UgPSB0aGlzLmV2ZW50cy5vbm1lc3NhZ2U7XG4gICAgICAgICAgICB0aGlzLndzLm9uY2xvc2UgPSB0aGlzLmV2ZW50cy5vbmNsb3NlO1xuICAgICAgICAgICAgdGhpcy53cy5vbmVycm9yID0gdGhpcy5ldmVudHMub25lcnJvcjtcbiAgICAgICAgfTtcbiAgICAgICAgV2ViU29ja2V0VHJhbnNwb3J0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIChjb2RlLCByZWFzb24pIHtcbiAgICAgICAgICAgIHRoaXMud3MuY2xvc2UoY29kZSwgcmVhc29uKTtcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUsIFwiaXNPcGVuXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLndzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5PUEVOO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gV2ViU29ja2V0VHJhbnNwb3J0O1xuICAgIH0oKSk7XG5cbiAgICB2YXIgQ29ubmVjdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQ29ubmVjdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzID0ge307XG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IG5ldyBXZWJTb2NrZXRUcmFuc3BvcnQodGhpcy5ldmVudHMpO1xuICAgICAgICB9XG4gICAgICAgIENvbm5lY3Rpb24ucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQuc2VuZChkYXRhKTtcbiAgICAgICAgfTtcbiAgICAgICAgQ29ubmVjdGlvbi5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0LmNvbm5lY3QodXJsKTtcbiAgICAgICAgfTtcbiAgICAgICAgQ29ubmVjdGlvbi5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoY29kZSwgcmVhc29uKSB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC5jbG9zZShjb2RlLCByZWFzb24pO1xuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29ubmVjdGlvbi5wcm90b3R5cGUsIFwiaXNPcGVuXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zcG9ydC5pc09wZW47XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBDb25uZWN0aW9uO1xuICAgIH0oKSk7XG5cbiAgICAvLyBVc2UgY29kZXMgYmV0d2VlbiAwfjEyNyBmb3IgbGVzc2VyIHRocm91Z2hwdXQgKDEgYnl0ZSlcbiAgICBleHBvcnRzLlByb3RvY29sID0gdm9pZCAwO1xuICAgIChmdW5jdGlvbiAoUHJvdG9jb2wpIHtcbiAgICAgICAgLy8gUm9vbS1yZWxhdGVkICgxMH4xOSlcbiAgICAgICAgUHJvdG9jb2xbUHJvdG9jb2xbXCJIQU5EU0hBS0VcIl0gPSA5XSA9IFwiSEFORFNIQUtFXCI7XG4gICAgICAgIFByb3RvY29sW1Byb3RvY29sW1wiSk9JTl9ST09NXCJdID0gMTBdID0gXCJKT0lOX1JPT01cIjtcbiAgICAgICAgUHJvdG9jb2xbUHJvdG9jb2xbXCJFUlJPUlwiXSA9IDExXSA9IFwiRVJST1JcIjtcbiAgICAgICAgUHJvdG9jb2xbUHJvdG9jb2xbXCJMRUFWRV9ST09NXCJdID0gMTJdID0gXCJMRUFWRV9ST09NXCI7XG4gICAgICAgIFByb3RvY29sW1Byb3RvY29sW1wiUk9PTV9EQVRBXCJdID0gMTNdID0gXCJST09NX0RBVEFcIjtcbiAgICAgICAgUHJvdG9jb2xbUHJvdG9jb2xbXCJST09NX1NUQVRFXCJdID0gMTRdID0gXCJST09NX1NUQVRFXCI7XG4gICAgICAgIFByb3RvY29sW1Byb3RvY29sW1wiUk9PTV9TVEFURV9QQVRDSFwiXSA9IDE1XSA9IFwiUk9PTV9TVEFURV9QQVRDSFwiO1xuICAgICAgICBQcm90b2NvbFtQcm90b2NvbFtcIlJPT01fREFUQV9TQ0hFTUFcIl0gPSAxNl0gPSBcIlJPT01fREFUQV9TQ0hFTUFcIjtcbiAgICAgICAgUHJvdG9jb2xbUHJvdG9jb2xbXCJST09NX0RBVEFfQllURVNcIl0gPSAxN10gPSBcIlJPT01fREFUQV9CWVRFU1wiO1xuICAgIH0pKGV4cG9ydHMuUHJvdG9jb2wgfHwgKGV4cG9ydHMuUHJvdG9jb2wgPSB7fSkpO1xuICAgIGV4cG9ydHMuRXJyb3JDb2RlID0gdm9pZCAwO1xuICAgIChmdW5jdGlvbiAoRXJyb3JDb2RlKSB7XG4gICAgICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJNQVRDSE1BS0VfTk9fSEFORExFUlwiXSA9IDQyMTBdID0gXCJNQVRDSE1BS0VfTk9fSEFORExFUlwiO1xuICAgICAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiTUFUQ0hNQUtFX0lOVkFMSURfQ1JJVEVSSUFcIl0gPSA0MjExXSA9IFwiTUFUQ0hNQUtFX0lOVkFMSURfQ1JJVEVSSUFcIjtcbiAgICAgICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIk1BVENITUFLRV9JTlZBTElEX1JPT01fSURcIl0gPSA0MjEyXSA9IFwiTUFUQ0hNQUtFX0lOVkFMSURfUk9PTV9JRFwiO1xuICAgICAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiTUFUQ0hNQUtFX1VOSEFORExFRFwiXSA9IDQyMTNdID0gXCJNQVRDSE1BS0VfVU5IQU5ETEVEXCI7XG4gICAgICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJNQVRDSE1BS0VfRVhQSVJFRFwiXSA9IDQyMTRdID0gXCJNQVRDSE1BS0VfRVhQSVJFRFwiO1xuICAgICAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiQVVUSF9GQUlMRURcIl0gPSA0MjE1XSA9IFwiQVVUSF9GQUlMRURcIjtcbiAgICAgICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkFQUExJQ0FUSU9OX0VSUk9SXCJdID0gNDIxNl0gPSBcIkFQUExJQ0FUSU9OX0VSUk9SXCI7XG4gICAgfSkoZXhwb3J0cy5FcnJvckNvZGUgfHwgKGV4cG9ydHMuRXJyb3JDb2RlID0ge30pKTtcbiAgICBmdW5jdGlvbiB1dGY4UmVhZCh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHZpZXdbb2Zmc2V0KytdO1xuICAgICAgICB2YXIgc3RyaW5nID0gJycsIGNociA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSBvZmZzZXQsIGVuZCA9IG9mZnNldCArIGxlbmd0aDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYnl0ZSA9IHZpZXdbaV07XG4gICAgICAgICAgICBpZiAoKGJ5dGUgJiAweDgwKSA9PT0gMHgwMCkge1xuICAgICAgICAgICAgICAgIHN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGUpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChieXRlICYgMHhlMCkgPT09IDB4YzApIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGJ5dGUgJiAweDFmKSA8PCA2KSB8XG4gICAgICAgICAgICAgICAgICAgICh2aWV3WysraV0gJiAweDNmKSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGJ5dGUgJiAweGYwKSA9PT0gMHhlMCkge1xuICAgICAgICAgICAgICAgIHN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYnl0ZSAmIDB4MGYpIDw8IDEyKSB8XG4gICAgICAgICAgICAgICAgICAgICgodmlld1srK2ldICYgMHgzZikgPDwgNikgfFxuICAgICAgICAgICAgICAgICAgICAoKHZpZXdbKytpXSAmIDB4M2YpIDw8IDApKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoYnl0ZSAmIDB4ZjgpID09PSAweGYwKSB7XG4gICAgICAgICAgICAgICAgY2hyID0gKChieXRlICYgMHgwNykgPDwgMTgpIHxcbiAgICAgICAgICAgICAgICAgICAgKCh2aWV3WysraV0gJiAweDNmKSA8PCAxMikgfFxuICAgICAgICAgICAgICAgICAgICAoKHZpZXdbKytpXSAmIDB4M2YpIDw8IDYpIHxcbiAgICAgICAgICAgICAgICAgICAgKCh2aWV3WysraV0gJiAweDNmKSA8PCAwKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hyID49IDB4MDEwMDAwKSB7IC8vIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICAgICAgICAgICAgICAgIGNociAtPSAweDAxMDAwMDtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGNociA+Pj4gMTApICsgMHhEODAwLCAoY2hyICYgMHgzRkYpICsgMHhEQzAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJ5dGUgJyArIGJ5dGUudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgIH1cbiAgICAvLyBGYXN0ZXIgZm9yIHNob3J0IHN0cmluZ3MgdGhhbiBCdWZmZXIuYnl0ZUxlbmd0aFxuICAgIGZ1bmN0aW9uIHV0ZjhMZW5ndGgoc3RyKSB7XG4gICAgICAgIGlmIChzdHIgPT09IHZvaWQgMCkgeyBzdHIgPSAnJzsgfVxuICAgICAgICB2YXIgYyA9IDA7XG4gICAgICAgIHZhciBsZW5ndGggPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHN0ci5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgICAgICAgICAgIGxlbmd0aCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYyA8IDB4ODAwKSB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoICs9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjIDwgMHhkODAwIHx8IGMgPj0gMHhlMDAwKSB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoICs9IDM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgbGVuZ3RoICs9IDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxlbmd0aCArIDE7XG4gICAgfVxuXG4gICAgdmFyIHNlcmlhbGl6ZXJzID0ge307XG4gICAgZnVuY3Rpb24gcmVnaXN0ZXJTZXJpYWxpemVyKGlkLCBzZXJpYWxpemVyKSB7XG4gICAgICAgIHNlcmlhbGl6ZXJzW2lkXSA9IHNlcmlhbGl6ZXI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFNlcmlhbGl6ZXIoaWQpIHtcbiAgICAgICAgdmFyIHNlcmlhbGl6ZXIgPSBzZXJpYWxpemVyc1tpZF07XG4gICAgICAgIGlmICghc2VyaWFsaXplcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBzZXJpYWxpemVyOiBcIiArIGlkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VyaWFsaXplcjtcbiAgICB9XG5cbiAgICBsZXQgY3JlYXRlTmFub0V2ZW50cyA9ICgpID0+ICh7XG4gICAgICBldmVudHM6IHt9LFxuICAgICAgZW1pdChldmVudCwgLi4uYXJncykge1xuICAgICh0aGlzLmV2ZW50c1tldmVudF0gfHwgW10pLmZvckVhY2goaSA9PiBpKC4uLmFyZ3MpKTtcbiAgICAgIH0sXG4gICAgICBvbihldmVudCwgY2IpIHtcbiAgICAodGhpcy5ldmVudHNbZXZlbnRdID0gdGhpcy5ldmVudHNbZXZlbnRdIHx8IFtdKS5wdXNoKGNiKTtcbiAgICAgICAgcmV0dXJuICgpID0+XG4gICAgICAgICAgKHRoaXMuZXZlbnRzW2V2ZW50XSA9ICh0aGlzLmV2ZW50c1tldmVudF0gfHwgW10pLmZpbHRlcihpID0+IGkgIT09IGNiKSlcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciBFdmVudEVtaXR0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlcnMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGNiLCBvbmNlKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZXJzLnB1c2goY2IpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuaW52b2tlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlcikgeyByZXR1cm4gaGFuZGxlci5hcHBseShfdGhpcywgYXJncyk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmludm9rZUFzeW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbCh0aGlzLmhhbmRsZXJzLm1hcChmdW5jdGlvbiAoaGFuZGxlcikgeyByZXR1cm4gaGFuZGxlci5hcHBseShfdGhpcywgYXJncyk7IH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuaGFuZGxlcnMuaW5kZXhPZihjYik7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZXJzW2luZGV4XSA9IHRoaXMuaGFuZGxlcnNbdGhpcy5oYW5kbGVycy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlcnMucG9wKCk7XG4gICAgICAgIH07XG4gICAgICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZXJzID0gW107XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBFdmVudEVtaXR0ZXI7XG4gICAgfSgpKTtcbiAgICBmdW5jdGlvbiBjcmVhdGVTaWduYWwoKSB7XG4gICAgICAgIHZhciBlbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICBmdW5jdGlvbiByZWdpc3RlcihjYikge1xuICAgICAgICAgICAgcmV0dXJuIGVtaXR0ZXIucmVnaXN0ZXIoY2IsIHRoaXMgPT09IG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHJlZ2lzdGVyLm9uY2UgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2IuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgZW1pdHRlci5yZW1vdmUoY2FsbGJhY2spO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGVtaXR0ZXIucmVnaXN0ZXIoY2FsbGJhY2spO1xuICAgICAgICB9O1xuICAgICAgICByZWdpc3Rlci5yZW1vdmUgPSBmdW5jdGlvbiAoY2IpIHsgcmV0dXJuIGVtaXR0ZXIucmVtb3ZlKGNiKTsgfTtcbiAgICAgICAgcmVnaXN0ZXIuaW52b2tlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVtaXR0ZXIuaW52b2tlLmFwcGx5KGVtaXR0ZXIsIGFyZ3MpO1xuICAgICAgICB9O1xuICAgICAgICByZWdpc3Rlci5pbnZva2VBc3luYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlbWl0dGVyLmludm9rZUFzeW5jLmFwcGx5KGVtaXR0ZXIsIGFyZ3MpO1xuICAgICAgICB9O1xuICAgICAgICByZWdpc3Rlci5jbGVhciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVtaXR0ZXIuY2xlYXIoKTsgfTtcbiAgICAgICAgcmV0dXJuIHJlZ2lzdGVyO1xuICAgIH1cblxuICAgIHZhciBjb21tb25qc0dsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9O1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlQ29tbW9uanNNb2R1bGUoZm4pIHtcbiAgICAgIHZhciBtb2R1bGUgPSB7IGV4cG9ydHM6IHt9IH07XG4gICAgXHRyZXR1cm4gZm4obW9kdWxlLCBtb2R1bGUuZXhwb3J0cyksIG1vZHVsZS5leHBvcnRzO1xuICAgIH1cblxuICAgIHZhciB1bWQgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4gICAgKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICAgICAgZmFjdG9yeShleHBvcnRzKSA7XG4gICAgfSkoY29tbW9uanNHbG9iYWwsIChmdW5jdGlvbiAoZXhwb3J0cykge1xuICAgICAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAgICAgICAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG4gICAgICAgIFBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG4gICAgICAgIHB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcbiAgICAgICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG4gICAgICAgIFJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG4gICAgICAgIEFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuICAgICAgICBJTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuICAgICAgICBMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG4gICAgICAgIE9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuICAgICAgICBQRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4gICAgICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbiAgICAgICAgLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbiAgICAgICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcbiAgICAgICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XHJcbiAgICAgICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICAgICAgICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICAgICAgICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICAgICAgICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBfX3NwcmVhZEFycmF5KHRvLCBmcm9tLCBwYWNrKSB7XHJcbiAgICAgICAgICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcclxuICAgICAgICAgICAgICAgICAgICBhcltpXSA9IGZyb21baV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XHJcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGV4cG9ydCBjb25zdCBTV0lUQ0hfVE9fU1RSVUNUVVJFID0gMTkzOyAoZWFzaWx5IGNvbGxpZGVzIHdpdGggREVMRVRFX0FORF9BREQgKyBmaWVsZEluZGV4ID0gMilcbiAgICAgICAgdmFyIFNXSVRDSF9UT19TVFJVQ1RVUkUgPSAyNTU7IC8vIChkZWNvZGluZyBjb2xsaWRlcyB3aXRoIERFTEVURV9BTkRfQUREICsgZmllbGRJbmRleCA9IDYzKVxuICAgICAgICB2YXIgVFlQRV9JRCA9IDIxMztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuY29kaW5nIFNjaGVtYSBmaWVsZCBvcGVyYXRpb25zLlxuICAgICAgICAgKi9cbiAgICAgICAgZXhwb3J0cy5PUEVSQVRJT04gPSB2b2lkIDA7XG4gICAgICAgIChmdW5jdGlvbiAoT1BFUkFUSU9OKSB7XG4gICAgICAgICAgICAvLyBhZGQgbmV3IHN0cnVjdHVyZS9wcmltaXRpdmVcbiAgICAgICAgICAgIE9QRVJBVElPTltPUEVSQVRJT05bXCJBRERcIl0gPSAxMjhdID0gXCJBRERcIjtcbiAgICAgICAgICAgIC8vIHJlcGxhY2Ugc3RydWN0dXJlL3ByaW1pdGl2ZVxuICAgICAgICAgICAgT1BFUkFUSU9OW09QRVJBVElPTltcIlJFUExBQ0VcIl0gPSAwXSA9IFwiUkVQTEFDRVwiO1xuICAgICAgICAgICAgLy8gZGVsZXRlIGZpZWxkXG4gICAgICAgICAgICBPUEVSQVRJT05bT1BFUkFUSU9OW1wiREVMRVRFXCJdID0gNjRdID0gXCJERUxFVEVcIjtcbiAgICAgICAgICAgIC8vIERFTEVURSBmaWVsZCwgZm9sbG93ZWQgYnkgYW4gQUREXG4gICAgICAgICAgICBPUEVSQVRJT05bT1BFUkFUSU9OW1wiREVMRVRFX0FORF9BRERcIl0gPSAxOTJdID0gXCJERUxFVEVfQU5EX0FERFwiO1xuICAgICAgICAgICAgLy8gVE9VQ0ggaXMgdXNlZCB0byBkZXRlcm1pbmUgaGllcmFyY2h5IG9mIG5lc3RlZCBTY2hlbWEgc3RydWN0dXJlcyBkdXJpbmcgc2VyaWFsaXphdGlvbi5cbiAgICAgICAgICAgIC8vIHRvdWNoZXMgYXJlIE5PVCBlbmNvZGVkLlxuICAgICAgICAgICAgT1BFUkFUSU9OW09QRVJBVElPTltcIlRPVUNIXCJdID0gMV0gPSBcIlRPVUNIXCI7XG4gICAgICAgICAgICAvLyBNYXBTY2hlbWEgT3BlcmF0aW9uc1xuICAgICAgICAgICAgT1BFUkFUSU9OW09QRVJBVElPTltcIkNMRUFSXCJdID0gMTBdID0gXCJDTEVBUlwiO1xuICAgICAgICB9KShleHBvcnRzLk9QRVJBVElPTiB8fCAoZXhwb3J0cy5PUEVSQVRJT04gPSB7fSkpO1xuICAgICAgICAvLyBleHBvcnQgZW51bSBPUEVSQVRJT04ge1xuICAgICAgICAvLyAgICAgLy8gYWRkIG5ldyBzdHJ1Y3R1cmUvcHJpbWl0aXZlXG4gICAgICAgIC8vICAgICAvLyAoMTI4KVxuICAgICAgICAvLyAgICAgQUREID0gMTI4LCAvLyAxMDAwMDAwMCxcbiAgICAgICAgLy8gICAgIC8vIHJlcGxhY2Ugc3RydWN0dXJlL3ByaW1pdGl2ZVxuICAgICAgICAvLyAgICAgUkVQTEFDRSA9IDEsLy8gMDAwMDAwMDFcbiAgICAgICAgLy8gICAgIC8vIGRlbGV0ZSBmaWVsZFxuICAgICAgICAvLyAgICAgREVMRVRFID0gMTkyLCAvLyAxMTAwMDAwMFxuICAgICAgICAvLyAgICAgLy8gREVMRVRFIGZpZWxkLCBmb2xsb3dlZCBieSBhbiBBRERcbiAgICAgICAgLy8gICAgIERFTEVURV9BTkRfQUREID0gMjI0LCAvLyAxMTEwMDAwMFxuICAgICAgICAvLyAgICAgLy8gVE9VQ0ggaXMgdXNlZCB0byBkZXRlcm1pbmUgaGllcmFyY2h5IG9mIG5lc3RlZCBTY2hlbWEgc3RydWN0dXJlcyBkdXJpbmcgc2VyaWFsaXphdGlvbi5cbiAgICAgICAgLy8gICAgIC8vIHRvdWNoZXMgYXJlIE5PVCBlbmNvZGVkLlxuICAgICAgICAvLyAgICAgVE9VQ0ggPSAwLCAvLyAwMDAwMDAwMFxuICAgICAgICAvLyAgICAgLy8gTWFwU2NoZW1hIE9wZXJhdGlvbnNcbiAgICAgICAgLy8gICAgIENMRUFSID0gMTAsXG4gICAgICAgIC8vIH1cblxuICAgICAgICB2YXIgQ2hhbmdlVHJlZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIENoYW5nZVRyZWUocmVmLCBwYXJlbnQsIHJvb3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hbGxDaGFuZ2VzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgICAgIC8vIGNhY2hlZCBpbmRleGVzIGZvciBmaWx0ZXJpbmdcbiAgICAgICAgICAgICAgICB0aGlzLmNhY2hlcyA9IHt9O1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudEN1c3RvbU9wZXJhdGlvbiA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWYgPSByZWY7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRQYXJlbnQocGFyZW50LCByb290KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIENoYW5nZVRyZWUucHJvdG90eXBlLnNldFBhcmVudCA9IGZ1bmN0aW9uIChwYXJlbnQsIHJvb3QsIHBhcmVudEluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaW5kZXhlcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4ZXMgPSAodGhpcy5yZWYgaW5zdGFuY2VvZiBTY2hlbWEpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMucmVmWydfZGVmaW5pdGlvbiddLmluZGV4ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIDoge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50SW5kZXggPSBwYXJlbnRJbmRleDtcbiAgICAgICAgICAgICAgICAvLyBhdm9pZCBzZXR0aW5nIHBhcmVudHMgd2l0aCBlbXB0eSBgcm9vdGBcbiAgICAgICAgICAgICAgICBpZiAoIXJvb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnJvb3QgPSByb290O1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gYXNzaWduIHNhbWUgcGFyZW50IG9uIGNoaWxkIHN0cnVjdHVyZXNcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlZiBpbnN0YW5jZW9mIFNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVmaW5pdGlvbiA9IHRoaXMucmVmWydfZGVmaW5pdGlvbiddO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBmaWVsZCBpbiBkZWZpbml0aW9uLnNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5yZWZbZmllbGRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlWyckY2hhbmdlcyddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudEluZGV4XzEgPSBkZWZpbml0aW9uLmluZGV4ZXNbZmllbGRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlWyckY2hhbmdlcyddLnNldFBhcmVudCh0aGlzLnJlZiwgcm9vdCwgcGFyZW50SW5kZXhfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mICh0aGlzLnJlZikgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWYuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgU2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoYW5nZVRyZWVlID0gdmFsdWVbJyRjaGFuZ2VzJ107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudEluZGV4XzIgPSBfdGhpcy5yZWZbJyRjaGFuZ2VzJ10uaW5kZXhlc1trZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZVRyZWVlLnNldFBhcmVudChfdGhpcy5yZWYsIF90aGlzLnJvb3QsIHBhcmVudEluZGV4XzIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgQ2hhbmdlVHJlZS5wcm90b3R5cGUub3BlcmF0aW9uID0gZnVuY3Rpb24gKG9wKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VzLnNldCgtLXRoaXMuY3VycmVudEN1c3RvbU9wZXJhdGlvbiwgb3ApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIENoYW5nZVRyZWUucHJvdG90eXBlLmNoYW5nZSA9IGZ1bmN0aW9uIChmaWVsZE5hbWUsIG9wZXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChvcGVyYXRpb24gPT09IHZvaWQgMCkgeyBvcGVyYXRpb24gPSBleHBvcnRzLk9QRVJBVElPTi5BREQ7IH1cbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSAodHlwZW9mIChmaWVsZE5hbWUpID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgICAgICA/IGZpZWxkTmFtZVxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuaW5kZXhlc1tmaWVsZE5hbWVdO1xuICAgICAgICAgICAgICAgIHRoaXMuYXNzZXJ0VmFsaWRJbmRleChpbmRleCwgZmllbGROYW1lKTtcbiAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNDaGFuZ2UgPSB0aGlzLmNoYW5nZXMuZ2V0KGluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoIXByZXZpb3VzQ2hhbmdlIHx8XG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzQ2hhbmdlLm9wID09PSBleHBvcnRzLk9QRVJBVElPTi5ERUxFVEUgfHxcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNDaGFuZ2Uub3AgPT09IGV4cG9ydHMuT1BFUkFUSU9OLlRPVUNIIC8vIChtYXptb3JyYS5pbydzIEJhdHRsZUFjdGlvbiBpc3N1ZSlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VzLnNldChpbmRleCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3A6ICghcHJldmlvdXNDaGFuZ2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBvcGVyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IChwcmV2aW91c0NoYW5nZS5vcCA9PT0gZXhwb3J0cy5PUEVSQVRJT04uREVMRVRFKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGV4cG9ydHMuT1BFUkFUSU9OLkRFTEVURV9BTkRfQUREXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogb3BlcmF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gOiBPUEVSQVRJT04uUkVQTEFDRSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5hbGxDaGFuZ2VzLmFkZChpbmRleCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnRvdWNoUGFyZW50cygpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIENoYW5nZVRyZWUucHJvdG90eXBlLnRvdWNoID0gZnVuY3Rpb24gKGZpZWxkTmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9ICh0eXBlb2YgKGZpZWxkTmFtZSkgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgICAgID8gZmllbGROYW1lXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5pbmRleGVzW2ZpZWxkTmFtZV07XG4gICAgICAgICAgICAgICAgdGhpcy5hc3NlcnRWYWxpZEluZGV4KGluZGV4LCBmaWVsZE5hbWUpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5jaGFuZ2VzLmhhcyhpbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VzLnNldChpbmRleCwgeyBvcDogZXhwb3J0cy5PUEVSQVRJT04uVE9VQ0gsIGluZGV4OiBpbmRleCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5hbGxDaGFuZ2VzLmFkZChpbmRleCk7XG4gICAgICAgICAgICAgICAgLy8gZW5zdXJlIHRvdWNoIGlzIHBsYWNlZCB1bnRpbCB0aGUgJHJvb3QgaXMgZm91bmQuXG4gICAgICAgICAgICAgICAgdGhpcy50b3VjaFBhcmVudHMoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBDaGFuZ2VUcmVlLnByb3RvdHlwZS50b3VjaFBhcmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50WyckY2hhbmdlcyddLnRvdWNoKHRoaXMucGFyZW50SW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBDaGFuZ2VUcmVlLnByb3RvdHlwZS5nZXRUeXBlID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVmWydfZGVmaW5pdGlvbiddKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWZpbml0aW9uID0gdGhpcy5yZWZbJ19kZWZpbml0aW9uJ107XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWZpbml0aW9uLnNjaGVtYVtkZWZpbml0aW9uLmZpZWxkc0J5SW5kZXhbaW5kZXhdXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWZpbml0aW9uID0gdGhpcy5wYXJlbnRbJ19kZWZpbml0aW9uJ107XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRUeXBlID0gZGVmaW5pdGlvbi5zY2hlbWFbZGVmaW5pdGlvbi5maWVsZHNCeUluZGV4W3RoaXMucGFyZW50SW5kZXhdXTtcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBjaGlsZCB0eXBlIGZyb20gcGFyZW50IHN0cnVjdHVyZS5cbiAgICAgICAgICAgICAgICAgICAgLy8gLSBbXCJzdHJpbmdcIl0gPT4gXCJzdHJpbmdcIlxuICAgICAgICAgICAgICAgICAgICAvLyAtIHsgbWFwOiBcInN0cmluZ1wiIH0gPT4gXCJzdHJpbmdcIlxuICAgICAgICAgICAgICAgICAgICAvLyAtIHsgc2V0OiBcInN0cmluZ1wiIH0gPT4gXCJzdHJpbmdcIlxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhwYXJlbnRUeXBlKVswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgQ2hhbmdlVHJlZS5wcm90b3R5cGUuZ2V0Q2hpbGRyZW5GaWx0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkRmlsdGVycyA9IHRoaXMucGFyZW50WydfZGVmaW5pdGlvbiddLmNoaWxkRmlsdGVycztcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRGaWx0ZXJzICYmIGNoaWxkRmlsdGVyc1t0aGlzLnBhcmVudEluZGV4XTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gdXNlZCBkdXJpbmcgYC5lbmNvZGUoKWBcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBDaGFuZ2VUcmVlLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZlsnZ2V0QnlJbmRleCddKGluZGV4KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBDaGFuZ2VUcmVlLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoZmllbGROYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gKHR5cGVvZiAoZmllbGROYW1lKSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICAgICAgPyBmaWVsZE5hbWVcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLmluZGV4ZXNbZmllbGROYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJAY29seXNldXMvc2NoZW1hIFwiLmNvbmNhdCh0aGlzLnJlZi5jb25zdHJ1Y3Rvci5uYW1lLCBcIjogdHJ5aW5nIHRvIGRlbGV0ZSBub24tZXhpc3RpbmcgaW5kZXg6IFwiKS5jb25jYXQoZmllbGROYW1lLCBcIiAoXCIpLmNvbmNhdChpbmRleCwgXCIpXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNWYWx1ZSA9IHRoaXMuZ2V0VmFsdWUoaW5kZXgpO1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiJGNoYW5nZXMuZGVsZXRlID0+XCIsIHsgZmllbGROYW1lLCBpbmRleCwgcHJldmlvdXNWYWx1ZSB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZXMuc2V0KGluZGV4LCB7IG9wOiBleHBvcnRzLk9QRVJBVElPTi5ERUxFVEUsIGluZGV4OiBpbmRleCB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmFsbENoYW5nZXMuZGVsZXRlKGluZGV4KTtcbiAgICAgICAgICAgICAgICAvLyBkZWxldGUgY2FjaGVcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5jYWNoZXNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBgcm9vdGAgcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzVmFsdWUgJiYgcHJldmlvdXNWYWx1ZVsnJGNoYW5nZXMnXSkge1xuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1ZhbHVlWyckY2hhbmdlcyddLnBhcmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnRvdWNoUGFyZW50cygpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIENoYW5nZVRyZWUucHJvdG90eXBlLmRpc2NhcmQgPSBmdW5jdGlvbiAoY2hhbmdlZCwgZGlzY2FyZEFsbCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZWQgPT09IHZvaWQgMCkgeyBjaGFuZ2VkID0gZmFsc2U7IH1cbiAgICAgICAgICAgICAgICBpZiAoZGlzY2FyZEFsbCA9PT0gdm9pZCAwKSB7IGRpc2NhcmRBbGwgPSBmYWxzZTsgfVxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gTWFwLCBBcnJheSwgZXRjOlxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBjYWNoZWQga2V5IHRvIGVuc3VyZSBBREQgb3BlcmF0aW9ucyBpcyB1bnNlZCBpbnN0ZWFkIG9mXG4gICAgICAgICAgICAgICAgLy8gUkVQTEFDRSBpbiBjYXNlIHNhbWUga2V5IGlzIHVzZWQgb24gbmV4dCBwYXRjaGVzLlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogcmVmYWN0b3IgdGhpcy4gdGhpcyBpcyBub3QgcmVsZXZhbnQgZm9yIENvbGxlY3Rpb24gYW5kIFNldC5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIGlmICghKHRoaXMucmVmIGluc3RhbmNlb2YgU2NoZW1hKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZXMuZm9yRWFjaChmdW5jdGlvbiAoY2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlLm9wID09PSBleHBvcnRzLk9QRVJBVElPTi5ERUxFVEUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBfdGhpcy5yZWZbJ2dldEluZGV4J10oY2hhbmdlLmluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgX3RoaXMuaW5kZXhlc1tpbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZXMuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZWQgPSBjaGFuZ2VkO1xuICAgICAgICAgICAgICAgIGlmIChkaXNjYXJkQWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWxsQ2hhbmdlcy5jbGVhcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyByZS1zZXQgYGN1cnJlbnRDdXN0b21PcGVyYXRpb25gXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50Q3VzdG9tT3BlcmF0aW9uID0gMDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJlY3Vyc2l2ZWx5IGRpc2NhcmQgYWxsIGNoYW5nZXMgZnJvbSB0aGlzLCBhbmQgY2hpbGQgc3RydWN0dXJlcy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgQ2hhbmdlVHJlZS5wcm90b3R5cGUuZGlzY2FyZEFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlcy5mb3JFYWNoKGZ1bmN0aW9uIChjaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gX3RoaXMuZ2V0VmFsdWUoY2hhbmdlLmluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlWyckY2hhbmdlcyddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVsnJGNoYW5nZXMnXS5kaXNjYXJkQWxsKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc2NhcmQoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBjYWNoZShmaWVsZDogbnVtYmVyLCBiZWdpbkluZGV4OiBudW1iZXIsIGVuZEluZGV4OiBudW1iZXIpIHtcbiAgICAgICAgICAgIENoYW5nZVRyZWUucHJvdG90eXBlLmNhY2hlID0gZnVuY3Rpb24gKGZpZWxkLCBjYWNoZWRCeXRlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVzW2ZpZWxkXSA9IGNhY2hlZEJ5dGVzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIENoYW5nZVRyZWUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ2hhbmdlVHJlZSh0aGlzLnJlZiwgdGhpcy5wYXJlbnQsIHRoaXMucm9vdCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgQ2hhbmdlVHJlZS5wcm90b3R5cGUuZW5zdXJlUmVmSWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gc2tpcCBpZiByZWZJZCBpcyBhbHJlYWR5IHNldC5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWZJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZJZCA9IHRoaXMucm9vdC5nZXROZXh0VW5pcXVlSWQoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBDaGFuZ2VUcmVlLnByb3RvdHlwZS5hc3NlcnRWYWxpZEluZGV4ID0gZnVuY3Rpb24gKGluZGV4LCBmaWVsZE5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDaGFuZ2VUcmVlOiBtaXNzaW5nIGluZGV4IGZvciBmaWVsZCBcXFwiXCIuY29uY2F0KGZpZWxkTmFtZSwgXCJcXFwiXCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIENoYW5nZVRyZWU7XG4gICAgICAgIH0oKSk7XG5cbiAgICAgICAgZnVuY3Rpb24gYWRkQ2FsbGJhY2soJGNhbGxiYWNrcywgb3AsIGNhbGxiYWNrLCBleGlzdGluZykge1xuICAgICAgICAgICAgLy8gaW5pdGlhbGl6ZSBsaXN0IG9mIGNhbGxiYWNrc1xuICAgICAgICAgICAgaWYgKCEkY2FsbGJhY2tzW29wXSkge1xuICAgICAgICAgICAgICAgICRjYWxsYmFja3Nbb3BdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkY2FsbGJhY2tzW29wXS5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBUcmlnZ2VyIGNhbGxiYWNrIGZvciBleGlzdGluZyBlbGVtZW50c1xuICAgICAgICAgICAgLy8gLSBPUEVSQVRJT04uQUREXG4gICAgICAgICAgICAvLyAtIE9QRVJBVElPTi5SRVBMQUNFXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgZXhpc3RpbmcgPT09IG51bGwgfHwgZXhpc3RpbmcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV4aXN0aW5nLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGtleSkgeyByZXR1cm4gY2FsbGJhY2soaXRlbSwga2V5KTsgfSk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gc3BsaWNlT25lKCRjYWxsYmFja3Nbb3BdLCAkY2FsbGJhY2tzW29wXS5pbmRleE9mKGNhbGxiYWNrKSk7IH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmVtb3ZlQ2hpbGRSZWZzKGNoYW5nZXMpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgbmVlZFJlbW92ZVJlZiA9ICh0eXBlb2YgKHRoaXMuJGNoYW5nZXMuZ2V0VHlwZSgpKSAhPT0gXCJzdHJpbmdcIik7XG4gICAgICAgICAgICB0aGlzLiRpdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBrZXkpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICByZWZJZDogX3RoaXMuJGNoYW5nZXMucmVmSWQsXG4gICAgICAgICAgICAgICAgICAgIG9wOiBleHBvcnRzLk9QRVJBVElPTi5ERUxFVEUsXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiBrZXksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzVmFsdWU6IGl0ZW1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAobmVlZFJlbW92ZVJlZikge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy4kY2hhbmdlcy5yb290LnJlbW92ZVJlZihpdGVtWyckY2hhbmdlcyddLnJlZklkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzcGxpY2VPbmUoYXJyLCBpbmRleCkge1xuICAgICAgICAgICAgLy8gbWFudWFsbHkgc3BsaWNlIGFuIGFycmF5XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xIHx8IGluZGV4ID49IGFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbGVuID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gaW5kZXg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGFycltpXSA9IGFycltpICsgMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhcnIubGVuZ3RoID0gbGVuO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgREVGQVVMVF9TT1JUID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHZhciBBID0gYS50b1N0cmluZygpO1xuICAgICAgICAgICAgdmFyIEIgPSBiLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBpZiAoQSA8IEIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgZWxzZSBpZiAoQSA+IEIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIGdldEFycmF5UHJveHkodmFsdWUpIHtcbiAgICAgICAgICAgIHZhbHVlWyckcHJveHknXSA9IHRydWU7XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gY29tcGF0aWJpbGl0eSB3aXRoIEBjb2x5c2V1cy9zY2hlbWEgMC41LnhcbiAgICAgICAgICAgIC8vIC0gYWxsb3cgYG1hcFtcImtleVwiXWBcbiAgICAgICAgICAgIC8vIC0gYWxsb3cgYG1hcFtcImtleVwiXSA9IFwieHh4XCJgXG4gICAgICAgICAgICAvLyAtIGFsbG93IGBkZWxldGUgbWFwW1wia2V5XCJdYFxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIHZhbHVlID0gbmV3IFByb3h5KHZhbHVlLCB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAob2JqLCBwcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHByb3ApICE9PSBcInN5bWJvbFwiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhaXNOYU4ocHJvcCkgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE3NTc4Ny84OTI2OThcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqLmF0KHByb3ApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9ialtwcm9wXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAob2JqLCBwcm9wLCBzZXRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChwcm9wKSAhPT0gXCJzeW1ib2xcIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIWlzTmFOKHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXhlcyA9IEFycmF5LmZyb20ob2JqWyckaXRlbXMnXS5rZXlzKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IHBhcnNlSW50KGluZGV4ZXNbcHJvcF0gfHwgcHJvcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0VmFsdWUgPT09IHVuZGVmaW5lZCB8fCBzZXRWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5kZWxldGVBdChrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqLnNldEF0KGtleSwgc2V0VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqW3Byb3BdID0gc2V0VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkZWxldGVQcm9wZXJ0eTogZnVuY3Rpb24gKG9iaiwgcHJvcCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChwcm9wKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqLmRlbGV0ZUF0KHByb3ApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9ialtwcm9wXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIEFycmF5U2NoZW1hID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gQXJyYXlTY2hlbWEoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW1zID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy4kY2hhbmdlcyA9IG5ldyBDaGFuZ2VUcmVlKHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGl0ZW1zID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGluZGV4ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgICAgdGhpcy4kcmVmSWQgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMucHVzaC5hcHBseSh0aGlzLCBpdGVtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBBcnJheVNjaGVtYS5wcm90b3R5cGUub25BZGQgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIHRyaWdnZXJBbGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodHJpZ2dlckFsbCA9PT0gdm9pZCAwKSB7IHRyaWdnZXJBbGwgPSB0cnVlOyB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFkZENhbGxiYWNrKCh0aGlzLiRjYWxsYmFja3MgfHwgKHRoaXMuJGNhbGxiYWNrcyA9IFtdKSksIGV4cG9ydHMuT1BFUkFUSU9OLkFERCwgY2FsbGJhY2ssICh0cmlnZ2VyQWxsKVxuICAgICAgICAgICAgICAgICAgICA/IHRoaXMuJGl0ZW1zXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBBcnJheVNjaGVtYS5wcm90b3R5cGUub25SZW1vdmUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHsgcmV0dXJuIGFkZENhbGxiYWNrKHRoaXMuJGNhbGxiYWNrcyB8fCAodGhpcy4kY2FsbGJhY2tzID0gW10pLCBleHBvcnRzLk9QRVJBVElPTi5ERUxFVEUsIGNhbGxiYWNrKTsgfTtcbiAgICAgICAgICAgIEFycmF5U2NoZW1hLnByb3RvdHlwZS5vbkNoYW5nZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykgeyByZXR1cm4gYWRkQ2FsbGJhY2sodGhpcy4kY2FsbGJhY2tzIHx8ICh0aGlzLiRjYWxsYmFja3MgPSBbXSksIGV4cG9ydHMuT1BFUkFUSU9OLlJFUExBQ0UsIGNhbGxiYWNrKTsgfTtcbiAgICAgICAgICAgIEFycmF5U2NoZW1hLmlzID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIC8vIHR5cGUgZm9ybWF0OiBbXCJzdHJpbmdcIl1cbiAgICAgICAgICAgICAgICBBcnJheS5pc0FycmF5KHR5cGUpIHx8XG4gICAgICAgICAgICAgICAgICAgIC8vIHR5cGUgZm9ybWF0OiB7IGFycmF5OiBcInN0cmluZ1wiIH1cbiAgICAgICAgICAgICAgICAgICAgKHR5cGVbJ2FycmF5J10gIT09IHVuZGVmaW5lZCkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcnJheVNjaGVtYS5wcm90b3R5cGUsIFwibGVuZ3RoXCIsIHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGl0ZW1zLnNpemU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3BsaWNlKHZhbHVlLCB0aGlzLmxlbmd0aCAtIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIEFycmF5U2NoZW1hLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbGFzdEluZGV4O1xuICAgICAgICAgICAgICAgIHZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBzZXQgXCJpbmRleFwiIGZvciByZWZlcmVuY2UuXG4gICAgICAgICAgICAgICAgICAgIGxhc3RJbmRleCA9IF90aGlzLiRyZWZJZCsrO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXRBdChsYXN0SW5kZXgsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGFzdEluZGV4O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmVtb3ZlcyB0aGUgbGFzdCBlbGVtZW50IGZyb20gYW4gYXJyYXkgYW5kIHJldHVybnMgaXQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEFycmF5U2NoZW1hLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IEFycmF5LmZyb20odGhpcy4kaW5kZXhlcy52YWx1ZXMoKSkucG9wKCk7XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuJGNoYW5nZXMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgdGhpcy4kaW5kZXhlcy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLiRpdGVtcy5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICB0aGlzLiRpdGVtcy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgQXJyYXlTY2hlbWEucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBGSVhNRTogdGhpcyBzaG91bGQgYmUgTygxKVxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IEFycmF5LmZyb20odGhpcy4kaXRlbXMua2V5cygpKVtpbmRleF07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGl0ZW1zLmdldChrZXkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIEFycmF5U2NoZW1hLnByb3RvdHlwZS5zZXRBdCA9IGZ1bmN0aW9uIChpbmRleCwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZVsnJGNoYW5nZXMnXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlWyckY2hhbmdlcyddLnNldFBhcmVudCh0aGlzLCB0aGlzLiRjaGFuZ2VzLnJvb3QsIGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIG9wZXJhdGlvbiA9IChfYiA9IChfYSA9IHRoaXMuJGNoYW5nZXMuaW5kZXhlc1tpbmRleF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZXhwb3J0cy5PUEVSQVRJT04uQUREO1xuICAgICAgICAgICAgICAgIHRoaXMuJGNoYW5nZXMuaW5kZXhlc1tpbmRleF0gPSBpbmRleDtcbiAgICAgICAgICAgICAgICB0aGlzLiRpbmRleGVzLnNldChpbmRleCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGl0ZW1zLnNldChpbmRleCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGNoYW5nZXMuY2hhbmdlKGluZGV4LCBvcGVyYXRpb24pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIEFycmF5U2NoZW1hLnByb3RvdHlwZS5kZWxldGVBdCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBBcnJheS5mcm9tKHRoaXMuJGl0ZW1zLmtleXMoKSlbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRkZWxldGVBdChrZXkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIEFycmF5U2NoZW1hLnByb3RvdHlwZS4kZGVsZXRlQXQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAvLyBkZWxldGUgYXQgaW50ZXJuYWwgaW5kZXhcbiAgICAgICAgICAgICAgICB0aGlzLiRjaGFuZ2VzLmRlbGV0ZShpbmRleCk7XG4gICAgICAgICAgICAgICAgdGhpcy4kaW5kZXhlcy5kZWxldGUoaW5kZXgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRpdGVtcy5kZWxldGUoaW5kZXgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIEFycmF5U2NoZW1hLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgLy8gZGlzY2FyZCBwcmV2aW91cyBvcGVyYXRpb25zLlxuICAgICAgICAgICAgICAgIHRoaXMuJGNoYW5nZXMuZGlzY2FyZCh0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRjaGFuZ2VzLmluZGV4ZXMgPSB7fTtcbiAgICAgICAgICAgICAgICAvLyBjbGVhciBwcmV2aW91cyBpbmRleGVzXG4gICAgICAgICAgICAgICAgdGhpcy4kaW5kZXhlcy5jbGVhcigpO1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gV2hlbiBkZWNvZGluZzpcbiAgICAgICAgICAgICAgICAvLyAtIGVucXVldWUgaXRlbXMgZm9yIERFTEVURSBjYWxsYmFjay5cbiAgICAgICAgICAgICAgICAvLyAtIGZsYWcgY2hpbGQgaXRlbXMgZm9yIGdhcmJhZ2UgY29sbGVjdGlvbi5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUNoaWxkUmVmcy5jYWxsKHRoaXMsIGNoYW5nZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBjbGVhciBpdGVtc1xuICAgICAgICAgICAgICAgIHRoaXMuJGl0ZW1zLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy4kY2hhbmdlcy5vcGVyYXRpb24oeyBpbmRleDogMCwgb3A6IGV4cG9ydHMuT1BFUkFUSU9OLkNMRUFSIH0pO1xuICAgICAgICAgICAgICAgIC8vIHRvdWNoIGFsbCBzdHJ1Y3R1cmVzIHVudGlsIHJlYWNoIHJvb3RcbiAgICAgICAgICAgICAgICB0aGlzLiRjaGFuZ2VzLnRvdWNoUGFyZW50cygpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ29tYmluZXMgdHdvIG9yIG1vcmUgYXJyYXlzLlxuICAgICAgICAgICAgICogQHBhcmFtIGl0ZW1zIEFkZGl0aW9uYWwgaXRlbXMgdG8gYWRkIHRvIHRoZSBlbmQgb2YgYXJyYXkxLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBBcnJheVNjaGVtYS5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICBpdGVtc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IChBcnJheVNjaGVtYS5iaW5kLmFwcGx5KEFycmF5U2NoZW1hLCBfX3NwcmVhZEFycmF5KFt2b2lkIDBdLCAoX2EgPSBBcnJheS5mcm9tKHRoaXMuJGl0ZW1zLnZhbHVlcygpKSkuY29uY2F0LmFwcGx5KF9hLCBpdGVtcyksIGZhbHNlKSkpKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBZGRzIGFsbCB0aGUgZWxlbWVudHMgb2YgYW4gYXJyYXkgc2VwYXJhdGVkIGJ5IHRoZSBzcGVjaWZpZWQgc2VwYXJhdG9yIHN0cmluZy5cbiAgICAgICAgICAgICAqIEBwYXJhbSBzZXBhcmF0b3IgQSBzdHJpbmcgdXNlZCB0byBzZXBhcmF0ZSBvbmUgZWxlbWVudCBvZiBhbiBhcnJheSBmcm9tIHRoZSBuZXh0IGluIHRoZSByZXN1bHRpbmcgU3RyaW5nLiBJZiBvbWl0dGVkLCB0aGUgYXJyYXkgZWxlbWVudHMgYXJlIHNlcGFyYXRlZCB3aXRoIGEgY29tbWEuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEFycmF5U2NoZW1hLnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gKHNlcGFyYXRvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuJGl0ZW1zLnZhbHVlcygpKS5qb2luKHNlcGFyYXRvcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXZlcnNlcyB0aGUgZWxlbWVudHMgaW4gYW4gQXJyYXkuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIEFycmF5U2NoZW1hLnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ZXMgPSBBcnJheS5mcm9tKHRoaXMuJGl0ZW1zLmtleXMoKSk7XG4gICAgICAgICAgICAgICAgdmFyIHJldmVyc2VkSXRlbXMgPSBBcnJheS5mcm9tKHRoaXMuJGl0ZW1zLnZhbHVlcygpKS5yZXZlcnNlKCk7XG4gICAgICAgICAgICAgICAgcmV2ZXJzZWRJdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNldEF0KGluZGV4ZXNbaV0sIGl0ZW0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmVtb3ZlcyB0aGUgZmlyc3QgZWxlbWVudCBmcm9tIGFuIGFycmF5IGFuZCByZXR1cm5zIGl0LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBBcnJheVNjaGVtYS5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ZXMgPSBBcnJheS5mcm9tKHRoaXMuJGl0ZW1zLmtleXMoKSk7XG4gICAgICAgICAgICAgICAgdmFyIHNoaWZ0QXQgPSBpbmRleGVzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgaWYgKHNoaWZ0QXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLiRpdGVtcy5nZXQoc2hpZnRBdCk7XG4gICAgICAgICAgICAgICAgdGhpcy4kZGVsZXRlQXQoc2hpZnRBdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmV0dXJucyBhIHNlY3Rpb24gb2YgYW4gYXJyYXkuXG4gICAgICAgICAgICAgKiBAcGFyYW0gc3RhcnQgVGhlIGJlZ2lubmluZyBvZiB0aGUgc3BlY2lmaWVkIHBvcnRpb24gb2YgdGhlIGFycmF5LlxuICAgICAgICAgICAgICogQHBhcmFtIGVuZCBUaGUgZW5kIG9mIHRoZSBzcGVjaWZpZWQgcG9ydGlvbiBvZiB0aGUgYXJyYXkuIFRoaXMgaXMgZXhjbHVzaXZlIG9mIHRoZSBlbGVtZW50IGF0IHRoZSBpbmRleCAnZW5kJy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgQXJyYXlTY2hlbWEucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2xpY2VkID0gbmV3IEFycmF5U2NoZW1hKCk7XG4gICAgICAgICAgICAgICAgc2xpY2VkLnB1c2guYXBwbHkoc2xpY2VkLCBBcnJheS5mcm9tKHRoaXMuJGl0ZW1zLnZhbHVlcygpKS5zbGljZShzdGFydCwgZW5kKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNsaWNlZDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNvcnRzIGFuIGFycmF5LlxuICAgICAgICAgICAgICogQHBhcmFtIGNvbXBhcmVGbiBGdW5jdGlvbiB1c2VkIHRvIGRldGVybWluZSB0aGUgb3JkZXIgb2YgdGhlIGVsZW1lbnRzLiBJdCBpcyBleHBlY3RlZCB0byByZXR1cm5cbiAgICAgICAgICAgICAqIGEgbmVnYXRpdmUgdmFsdWUgaWYgZmlyc3QgYXJndW1lbnQgaXMgbGVzcyB0aGFuIHNlY29uZCBhcmd1bWVudCwgemVybyBpZiB0aGV5J3JlIGVxdWFsIGFuZCBhIHBvc2l0aXZlXG4gICAgICAgICAgICAgKiB2YWx1ZSBvdGhlcndpc2UuIElmIG9taXR0ZWQsIHRoZSBlbGVtZW50cyBhcmUgc29ydGVkIGluIGFzY2VuZGluZywgQVNDSUkgY2hhcmFjdGVyIG9yZGVyLlxuICAgICAgICAgICAgICogYGBgdHNcbiAgICAgICAgICAgICAqIFsxMSwyLDIyLDFdLnNvcnQoKGEsIGIpID0+IGEgLSBiKVxuICAgICAgICAgICAgICogYGBgXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEFycmF5U2NoZW1hLnByb3RvdHlwZS5zb3J0ID0gZnVuY3Rpb24gKGNvbXBhcmVGbikge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBhcmVGbiA9PT0gdm9pZCAwKSB7IGNvbXBhcmVGbiA9IERFRkFVTFRfU09SVDsgfVxuICAgICAgICAgICAgICAgIHZhciBpbmRleGVzID0gQXJyYXkuZnJvbSh0aGlzLiRpdGVtcy5rZXlzKCkpO1xuICAgICAgICAgICAgICAgIHZhciBzb3J0ZWRJdGVtcyA9IEFycmF5LmZyb20odGhpcy4kaXRlbXMudmFsdWVzKCkpLnNvcnQoY29tcGFyZUZuKTtcbiAgICAgICAgICAgICAgICBzb3J0ZWRJdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNldEF0KGluZGV4ZXNbaV0sIGl0ZW0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmVtb3ZlcyBlbGVtZW50cyBmcm9tIGFuIGFycmF5IGFuZCwgaWYgbmVjZXNzYXJ5LCBpbnNlcnRzIG5ldyBlbGVtZW50cyBpbiB0aGVpciBwbGFjZSwgcmV0dXJuaW5nIHRoZSBkZWxldGVkIGVsZW1lbnRzLlxuICAgICAgICAgICAgICogQHBhcmFtIHN0YXJ0IFRoZSB6ZXJvLWJhc2VkIGxvY2F0aW9uIGluIHRoZSBhcnJheSBmcm9tIHdoaWNoIHRvIHN0YXJ0IHJlbW92aW5nIGVsZW1lbnRzLlxuICAgICAgICAgICAgICogQHBhcmFtIGRlbGV0ZUNvdW50IFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gcmVtb3ZlLlxuICAgICAgICAgICAgICogQHBhcmFtIGl0ZW1zIEVsZW1lbnRzIHRvIGluc2VydCBpbnRvIHRoZSBhcnJheSBpbiBwbGFjZSBvZiB0aGUgZGVsZXRlZCBlbGVtZW50cy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgQXJyYXlTY2hlbWEucHJvdG90eXBlLnNwbGljZSA9IGZ1bmN0aW9uIChzdGFydCwgZGVsZXRlQ291bnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVsZXRlQ291bnQgPT09IHZvaWQgMCkgeyBkZWxldGVDb3VudCA9IHRoaXMubGVuZ3RoIC0gc3RhcnQ7IH1cbiAgICAgICAgICAgICAgICB2YXIgaW5kZXhlcyA9IEFycmF5LmZyb20odGhpcy4kaXRlbXMua2V5cygpKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVtb3ZlZEl0ZW1zID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBkZWxldGVDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZWRJdGVtcy5wdXNoKHRoaXMuJGl0ZW1zLmdldChpbmRleGVzW2ldKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGRlbGV0ZUF0KGluZGV4ZXNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVtb3ZlZEl0ZW1zO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSW5zZXJ0cyBuZXcgZWxlbWVudHMgYXQgdGhlIHN0YXJ0IG9mIGFuIGFycmF5LlxuICAgICAgICAgICAgICogQHBhcmFtIGl0ZW1zICBFbGVtZW50cyB0byBpbnNlcnQgYXQgdGhlIHN0YXJ0IG9mIHRoZSBBcnJheS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgQXJyYXlTY2hlbWEucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICBpdGVtc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdmFyIGFkZGVkTGVuZ3RoID0gaXRlbXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIC8vIGNvbnN0IGluZGV4ZXMgPSBBcnJheS5mcm9tKHRoaXMuJGl0ZW1zLmtleXMoKSk7XG4gICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzVmFsdWVzID0gQXJyYXkuZnJvbSh0aGlzLiRpdGVtcy52YWx1ZXMoKSk7XG4gICAgICAgICAgICAgICAgaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSwgaSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXRBdChpLCBpdGVtKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBwcmV2aW91c1ZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uIChwcmV2aW91c1ZhbHVlLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNldEF0KGFkZGVkTGVuZ3RoICsgaSwgcHJldmlvdXNWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlbmd0aCArIGFkZGVkTGVuZ3RoO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYSB2YWx1ZSBpbiBhbiBhcnJheS5cbiAgICAgICAgICAgICAqIEBwYXJhbSBzZWFyY2hFbGVtZW50IFRoZSB2YWx1ZSB0byBsb2NhdGUgaW4gdGhlIGFycmF5LlxuICAgICAgICAgICAgICogQHBhcmFtIGZyb21JbmRleCBUaGUgYXJyYXkgaW5kZXggYXQgd2hpY2ggdG8gYmVnaW4gdGhlIHNlYXJjaC4gSWYgZnJvbUluZGV4IGlzIG9taXR0ZWQsIHRoZSBzZWFyY2ggc3RhcnRzIGF0IGluZGV4IDAuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEFycmF5U2NoZW1hLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gKHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuJGl0ZW1zLnZhbHVlcygpKS5pbmRleE9mKHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbGFzdCBvY2N1cnJlbmNlIG9mIGEgc3BlY2lmaWVkIHZhbHVlIGluIGFuIGFycmF5LlxuICAgICAgICAgICAgICogQHBhcmFtIHNlYXJjaEVsZW1lbnQgVGhlIHZhbHVlIHRvIGxvY2F0ZSBpbiB0aGUgYXJyYXkuXG4gICAgICAgICAgICAgKiBAcGFyYW0gZnJvbUluZGV4IFRoZSBhcnJheSBpbmRleCBhdCB3aGljaCB0byBiZWdpbiB0aGUgc2VhcmNoLiBJZiBmcm9tSW5kZXggaXMgb21pdHRlZCwgdGhlIHNlYXJjaCBzdGFydHMgYXQgdGhlIGxhc3QgaW5kZXggaW4gdGhlIGFycmF5LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBBcnJheVNjaGVtYS5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiAoc2VhcmNoRWxlbWVudCwgZnJvbUluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGZyb21JbmRleCA9PT0gdm9pZCAwKSB7IGZyb21JbmRleCA9IHRoaXMubGVuZ3RoIC0gMTsgfVxuICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuJGl0ZW1zLnZhbHVlcygpKS5sYXN0SW5kZXhPZihzZWFyY2hFbGVtZW50LCBmcm9tSW5kZXgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIGFsbCB0aGUgbWVtYmVycyBvZiBhbiBhcnJheSBzYXRpc2Z5IHRoZSBzcGVjaWZpZWQgdGVzdC5cbiAgICAgICAgICAgICAqIEBwYXJhbSBjYWxsYmFja2ZuIEEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIHVwIHRvIHRocmVlIGFyZ3VtZW50cy4gVGhlIGV2ZXJ5IG1ldGhvZCBjYWxsc1xuICAgICAgICAgICAgICogdGhlIGNhbGxiYWNrZm4gZnVuY3Rpb24gZm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgYXJyYXkgdW50aWwgdGhlIGNhbGxiYWNrZm4gcmV0dXJucyBhIHZhbHVlXG4gICAgICAgICAgICAgKiB3aGljaCBpcyBjb2VyY2libGUgdG8gdGhlIEJvb2xlYW4gdmFsdWUgZmFsc2UsIG9yIHVudGlsIHRoZSBlbmQgb2YgdGhlIGFycmF5LlxuICAgICAgICAgICAgICogQHBhcmFtIHRoaXNBcmcgQW4gb2JqZWN0IHRvIHdoaWNoIHRoZSB0aGlzIGtleXdvcmQgY2FuIHJlZmVyIGluIHRoZSBjYWxsYmFja2ZuIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICogSWYgdGhpc0FyZyBpcyBvbWl0dGVkLCB1bmRlZmluZWQgaXMgdXNlZCBhcyB0aGUgdGhpcyB2YWx1ZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgQXJyYXlTY2hlbWEucHJvdG90eXBlLmV2ZXJ5ID0gZnVuY3Rpb24gKGNhbGxiYWNrZm4sIHRoaXNBcmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLiRpdGVtcy52YWx1ZXMoKSkuZXZlcnkoY2FsbGJhY2tmbiwgdGhpc0FyZyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBjYWxsYmFjayBmdW5jdGlvbiByZXR1cm5zIHRydWUgZm9yIGFueSBlbGVtZW50IG9mIGFuIGFycmF5LlxuICAgICAgICAgICAgICogQHBhcmFtIGNhbGxiYWNrZm4gQSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgdXAgdG8gdGhyZWUgYXJndW1lbnRzLiBUaGUgc29tZSBtZXRob2QgY2FsbHNcbiAgICAgICAgICAgICAqIHRoZSBjYWxsYmFja2ZuIGZ1bmN0aW9uIGZvciBlYWNoIGVsZW1lbnQgaW4gdGhlIGFycmF5IHVudGlsIHRoZSBjYWxsYmFja2ZuIHJldHVybnMgYSB2YWx1ZVxuICAgICAgICAgICAgICogd2hpY2ggaXMgY29lcmNpYmxlIHRvIHRoZSBCb29sZWFuIHZhbHVlIHRydWUsIG9yIHVudGlsIHRoZSBlbmQgb2YgdGhlIGFycmF5LlxuICAgICAgICAgICAgICogQHBhcmFtIHRoaXNBcmcgQW4gb2JqZWN0IHRvIHdoaWNoIHRoZSB0aGlzIGtleXdvcmQgY2FuIHJlZmVyIGluIHRoZSBjYWxsYmFja2ZuIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICogSWYgdGhpc0FyZyBpcyBvbWl0dGVkLCB1bmRlZmluZWQgaXMgdXNlZCBhcyB0aGUgdGhpcyB2YWx1ZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgQXJyYXlTY2hlbWEucHJvdG90eXBlLnNvbWUgPSBmdW5jdGlvbiAoY2FsbGJhY2tmbiwgdGhpc0FyZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuJGl0ZW1zLnZhbHVlcygpKS5zb21lKGNhbGxiYWNrZm4sIHRoaXNBcmcpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUGVyZm9ybXMgdGhlIHNwZWNpZmllZCBhY3Rpb24gZm9yIGVhY2ggZWxlbWVudCBpbiBhbiBhcnJheS5cbiAgICAgICAgICAgICAqIEBwYXJhbSBjYWxsYmFja2ZuICBBIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyB1cCB0byB0aHJlZSBhcmd1bWVudHMuIGZvckVhY2ggY2FsbHMgdGhlIGNhbGxiYWNrZm4gZnVuY3Rpb24gb25lIHRpbWUgZm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgYXJyYXkuXG4gICAgICAgICAgICAgKiBAcGFyYW0gdGhpc0FyZyAgQW4gb2JqZWN0IHRvIHdoaWNoIHRoZSB0aGlzIGtleXdvcmQgY2FuIHJlZmVyIGluIHRoZSBjYWxsYmFja2ZuIGZ1bmN0aW9uLiBJZiB0aGlzQXJnIGlzIG9taXR0ZWQsIHVuZGVmaW5lZCBpcyB1c2VkIGFzIHRoZSB0aGlzIHZhbHVlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBBcnJheVNjaGVtYS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFja2ZuLCB0aGlzQXJnKSB7XG4gICAgICAgICAgICAgICAgQXJyYXkuZnJvbSh0aGlzLiRpdGVtcy52YWx1ZXMoKSkuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENhbGxzIGEgZGVmaW5lZCBjYWxsYmFjayBmdW5jdGlvbiBvbiBlYWNoIGVsZW1lbnQgb2YgYW4gYXJyYXksIGFuZCByZXR1cm5zIGFuIGFycmF5IHRoYXQgY29udGFpbnMgdGhlIHJlc3VsdHMuXG4gICAgICAgICAgICAgKiBAcGFyYW0gY2FsbGJhY2tmbiBBIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyB1cCB0byB0aHJlZSBhcmd1bWVudHMuIFRoZSBtYXAgbWV0aG9kIGNhbGxzIHRoZSBjYWxsYmFja2ZuIGZ1bmN0aW9uIG9uZSB0aW1lIGZvciBlYWNoIGVsZW1lbnQgaW4gdGhlIGFycmF5LlxuICAgICAgICAgICAgICogQHBhcmFtIHRoaXNBcmcgQW4gb2JqZWN0IHRvIHdoaWNoIHRoZSB0aGlzIGtleXdvcmQgY2FuIHJlZmVyIGluIHRoZSBjYWxsYmFja2ZuIGZ1bmN0aW9uLiBJZiB0aGlzQXJnIGlzIG9taXR0ZWQsIHVuZGVmaW5lZCBpcyB1c2VkIGFzIHRoZSB0aGlzIHZhbHVlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBBcnJheVNjaGVtYS5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gKGNhbGxiYWNrZm4sIHRoaXNBcmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLiRpdGVtcy52YWx1ZXMoKSkubWFwKGNhbGxiYWNrZm4sIHRoaXNBcmcpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIEFycmF5U2NoZW1hLnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbiAoY2FsbGJhY2tmbiwgdGhpc0FyZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuJGl0ZW1zLnZhbHVlcygpKS5maWx0ZXIoY2FsbGJhY2tmbiwgdGhpc0FyZyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDYWxscyB0aGUgc3BlY2lmaWVkIGNhbGxiYWNrIGZ1bmN0aW9uIGZvciBhbGwgdGhlIGVsZW1lbnRzIGluIGFuIGFycmF5LiBUaGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBpcyB0aGUgYWNjdW11bGF0ZWQgcmVzdWx0LCBhbmQgaXMgcHJvdmlkZWQgYXMgYW4gYXJndW1lbnQgaW4gdGhlIG5leHQgY2FsbCB0byB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICAgICAgICAgKiBAcGFyYW0gY2FsbGJhY2tmbiBBIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyB1cCB0byBmb3VyIGFyZ3VtZW50cy4gVGhlIHJlZHVjZSBtZXRob2QgY2FsbHMgdGhlIGNhbGxiYWNrZm4gZnVuY3Rpb24gb25lIHRpbWUgZm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgYXJyYXkuXG4gICAgICAgICAgICAgKiBAcGFyYW0gaW5pdGlhbFZhbHVlIElmIGluaXRpYWxWYWx1ZSBpcyBzcGVjaWZpZWQsIGl0IGlzIHVzZWQgYXMgdGhlIGluaXRpYWwgdmFsdWUgdG8gc3RhcnQgdGhlIGFjY3VtdWxhdGlvbi4gVGhlIGZpcnN0IGNhbGwgdG8gdGhlIGNhbGxiYWNrZm4gZnVuY3Rpb24gcHJvdmlkZXMgdGhpcyB2YWx1ZSBhcyBhbiBhcmd1bWVudCBpbnN0ZWFkIG9mIGFuIGFycmF5IHZhbHVlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBBcnJheVNjaGVtYS5wcm90b3R5cGUucmVkdWNlID0gZnVuY3Rpb24gKGNhbGxiYWNrZm4sIGluaXRpYWxWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUucmVkdWNlLmFwcGx5KEFycmF5LmZyb20odGhpcy4kaXRlbXMudmFsdWVzKCkpLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ2FsbHMgdGhlIHNwZWNpZmllZCBjYWxsYmFjayBmdW5jdGlvbiBmb3IgYWxsIHRoZSBlbGVtZW50cyBpbiBhbiBhcnJheSwgaW4gZGVzY2VuZGluZyBvcmRlci4gVGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gaXMgdGhlIGFjY3VtdWxhdGVkIHJlc3VsdCwgYW5kIGlzIHByb3ZpZGVkIGFzIGFuIGFyZ3VtZW50IGluIHRoZSBuZXh0IGNhbGwgdG8gdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICogQHBhcmFtIGNhbGxiYWNrZm4gQSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgdXAgdG8gZm91ciBhcmd1bWVudHMuIFRoZSByZWR1Y2VSaWdodCBtZXRob2QgY2FsbHMgdGhlIGNhbGxiYWNrZm4gZnVuY3Rpb24gb25lIHRpbWUgZm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgYXJyYXkuXG4gICAgICAgICAgICAgKiBAcGFyYW0gaW5pdGlhbFZhbHVlIElmIGluaXRpYWxWYWx1ZSBpcyBzcGVjaWZpZWQsIGl0IGlzIHVzZWQgYXMgdGhlIGluaXRpYWwgdmFsdWUgdG8gc3RhcnQgdGhlIGFjY3VtdWxhdGlvbi4gVGhlIGZpcnN0IGNhbGwgdG8gdGhlIGNhbGxiYWNrZm4gZnVuY3Rpb24gcHJvdmlkZXMgdGhpcyB2YWx1ZSBhcyBhbiBhcmd1bWVudCBpbnN0ZWFkIG9mIGFuIGFycmF5IHZhbHVlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBBcnJheVNjaGVtYS5wcm90b3R5cGUucmVkdWNlUmlnaHQgPSBmdW5jdGlvbiAoY2FsbGJhY2tmbiwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5yZWR1Y2VSaWdodC5hcHBseShBcnJheS5mcm9tKHRoaXMuJGl0ZW1zLnZhbHVlcygpKSwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBhcnJheSB3aGVyZSBwcmVkaWNhdGUgaXMgdHJ1ZSwgYW5kIHVuZGVmaW5lZFxuICAgICAgICAgICAgICogb3RoZXJ3aXNlLlxuICAgICAgICAgICAgICogQHBhcmFtIHByZWRpY2F0ZSBmaW5kIGNhbGxzIHByZWRpY2F0ZSBvbmNlIGZvciBlYWNoIGVsZW1lbnQgb2YgdGhlIGFycmF5LCBpbiBhc2NlbmRpbmdcbiAgICAgICAgICAgICAqIG9yZGVyLCB1bnRpbCBpdCBmaW5kcyBvbmUgd2hlcmUgcHJlZGljYXRlIHJldHVybnMgdHJ1ZS4gSWYgc3VjaCBhbiBlbGVtZW50IGlzIGZvdW5kLCBmaW5kXG4gICAgICAgICAgICAgKiBpbW1lZGlhdGVseSByZXR1cm5zIHRoYXQgZWxlbWVudCB2YWx1ZS4gT3RoZXJ3aXNlLCBmaW5kIHJldHVybnMgdW5kZWZpbmVkLlxuICAgICAgICAgICAgICogQHBhcmFtIHRoaXNBcmcgSWYgcHJvdmlkZWQsIGl0IHdpbGwgYmUgdXNlZCBhcyB0aGUgdGhpcyB2YWx1ZSBmb3IgZWFjaCBpbnZvY2F0aW9uIG9mXG4gICAgICAgICAgICAgKiBwcmVkaWNhdGUuIElmIGl0IGlzIG5vdCBwcm92aWRlZCwgdW5kZWZpbmVkIGlzIHVzZWQgaW5zdGVhZC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgQXJyYXlTY2hlbWEucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiAocHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy4kaXRlbXMudmFsdWVzKCkpLmZpbmQocHJlZGljYXRlLCB0aGlzQXJnKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBhcnJheSB3aGVyZSBwcmVkaWNhdGUgaXMgdHJ1ZSwgYW5kIC0xXG4gICAgICAgICAgICAgKiBvdGhlcndpc2UuXG4gICAgICAgICAgICAgKiBAcGFyYW0gcHJlZGljYXRlIGZpbmQgY2FsbHMgcHJlZGljYXRlIG9uY2UgZm9yIGVhY2ggZWxlbWVudCBvZiB0aGUgYXJyYXksIGluIGFzY2VuZGluZ1xuICAgICAgICAgICAgICogb3JkZXIsIHVudGlsIGl0IGZpbmRzIG9uZSB3aGVyZSBwcmVkaWNhdGUgcmV0dXJucyB0cnVlLiBJZiBzdWNoIGFuIGVsZW1lbnQgaXMgZm91bmQsXG4gICAgICAgICAgICAgKiBmaW5kSW5kZXggaW1tZWRpYXRlbHkgcmV0dXJucyB0aGF0IGVsZW1lbnQgaW5kZXguIE90aGVyd2lzZSwgZmluZEluZGV4IHJldHVybnMgLTEuXG4gICAgICAgICAgICAgKiBAcGFyYW0gdGhpc0FyZyBJZiBwcm92aWRlZCwgaXQgd2lsbCBiZSB1c2VkIGFzIHRoZSB0aGlzIHZhbHVlIGZvciBlYWNoIGludm9jYXRpb24gb2ZcbiAgICAgICAgICAgICAqIHByZWRpY2F0ZS4gSWYgaXQgaXMgbm90IHByb3ZpZGVkLCB1bmRlZmluZWQgaXMgdXNlZCBpbnN0ZWFkLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBBcnJheVNjaGVtYS5wcm90b3R5cGUuZmluZEluZGV4ID0gZnVuY3Rpb24gKHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuJGl0ZW1zLnZhbHVlcygpKS5maW5kSW5kZXgocHJlZGljYXRlLCB0aGlzQXJnKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldHVybnMgdGhlIHRoaXMgb2JqZWN0IGFmdGVyIGZpbGxpbmcgdGhlIHNlY3Rpb24gaWRlbnRpZmllZCBieSBzdGFydCBhbmQgZW5kIHdpdGggdmFsdWVcbiAgICAgICAgICAgICAqIEBwYXJhbSB2YWx1ZSB2YWx1ZSB0byBmaWxsIGFycmF5IHNlY3Rpb24gd2l0aFxuICAgICAgICAgICAgICogQHBhcmFtIHN0YXJ0IGluZGV4IHRvIHN0YXJ0IGZpbGxpbmcgdGhlIGFycmF5IGF0LiBJZiBzdGFydCBpcyBuZWdhdGl2ZSwgaXQgaXMgdHJlYXRlZCBhc1xuICAgICAgICAgICAgICogbGVuZ3RoK3N0YXJ0IHdoZXJlIGxlbmd0aCBpcyB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheS5cbiAgICAgICAgICAgICAqIEBwYXJhbSBlbmQgaW5kZXggdG8gc3RvcCBmaWxsaW5nIHRoZSBhcnJheSBhdC4gSWYgZW5kIGlzIG5lZ2F0aXZlLCBpdCBpcyB0cmVhdGVkIGFzXG4gICAgICAgICAgICAgKiBsZW5ndGgrZW5kLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBBcnJheVNjaGVtYS5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uICh2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gVE9ET1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXJyYXlTY2hlbWEjZmlsbCgpIG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldHVybnMgdGhlIHRoaXMgb2JqZWN0IGFmdGVyIGNvcHlpbmcgYSBzZWN0aW9uIG9mIHRoZSBhcnJheSBpZGVudGlmaWVkIGJ5IHN0YXJ0IGFuZCBlbmRcbiAgICAgICAgICAgICAqIHRvIHRoZSBzYW1lIGFycmF5IHN0YXJ0aW5nIGF0IHBvc2l0aW9uIHRhcmdldFxuICAgICAgICAgICAgICogQHBhcmFtIHRhcmdldCBJZiB0YXJnZXQgaXMgbmVnYXRpdmUsIGl0IGlzIHRyZWF0ZWQgYXMgbGVuZ3RoK3RhcmdldCB3aGVyZSBsZW5ndGggaXMgdGhlXG4gICAgICAgICAgICAgKiBsZW5ndGggb2YgdGhlIGFycmF5LlxuICAgICAgICAgICAgICogQHBhcmFtIHN0YXJ0IElmIHN0YXJ0IGlzIG5lZ2F0aXZlLCBpdCBpcyB0cmVhdGVkIGFzIGxlbmd0aCtzdGFydC4gSWYgZW5kIGlzIG5lZ2F0aXZlLCBpdFxuICAgICAgICAgICAgICogaXMgdHJlYXRlZCBhcyBsZW5ndGgrZW5kLlxuICAgICAgICAgICAgICogQHBhcmFtIGVuZCBJZiBub3Qgc3BlY2lmaWVkLCBsZW5ndGggb2YgdGhlIHRoaXMgb2JqZWN0IGlzIHVzZWQgYXMgaXRzIGRlZmF1bHQgdmFsdWUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEFycmF5U2NoZW1hLnByb3RvdHlwZS5jb3B5V2l0aGluID0gZnVuY3Rpb24gKHRhcmdldCwgc3RhcnQsIGVuZCkge1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gVE9ET1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXJyYXlTY2hlbWEjY29weVdpdGhpbigpIG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYW4gYXJyYXkuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEFycmF5U2NoZW1hLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuJGl0ZW1zLnRvU3RyaW5nKCk7IH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYW4gYXJyYXkuIFRoZSBlbGVtZW50cyBhcmUgY29udmVydGVkIHRvIHN0cmluZyB1c2luZyB0aGVpciB0b0xvY2FsU3RyaW5nIG1ldGhvZHMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEFycmF5U2NoZW1hLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuJGl0ZW1zLnRvTG9jYWxlU3RyaW5nKCk7IH07XG4gICAgICAgICAgICAvKiogSXRlcmF0b3IgKi9cbiAgICAgICAgICAgIEFycmF5U2NoZW1hLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuJGl0ZW1zLnZhbHVlcygpKVtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXR1cm5zIGFuIGl0ZXJhYmxlIG9mIGtleSwgdmFsdWUgcGFpcnMgZm9yIGV2ZXJ5IGVudHJ5IGluIHRoZSBhcnJheVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBBcnJheVNjaGVtYS5wcm90b3R5cGUuZW50cmllcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuJGl0ZW1zLmVudHJpZXMoKTsgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmV0dXJucyBhbiBpdGVyYWJsZSBvZiBrZXlzIGluIHRoZSBhcnJheVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBBcnJheVNjaGVtYS5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuJGl0ZW1zLmtleXMoKTsgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmV0dXJucyBhbiBpdGVyYWJsZSBvZiB2YWx1ZXMgaW4gdGhlIGFycmF5XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEFycmF5U2NoZW1hLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLiRpdGVtcy52YWx1ZXMoKTsgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIGFuIGFycmF5IGluY2x1ZGVzIGEgY2VydGFpbiBlbGVtZW50LCByZXR1cm5pbmcgdHJ1ZSBvciBmYWxzZSBhcyBhcHByb3ByaWF0ZS5cbiAgICAgICAgICAgICAqIEBwYXJhbSBzZWFyY2hFbGVtZW50IFRoZSBlbGVtZW50IHRvIHNlYXJjaCBmb3IuXG4gICAgICAgICAgICAgKiBAcGFyYW0gZnJvbUluZGV4IFRoZSBwb3NpdGlvbiBpbiB0aGlzIGFycmF5IGF0IHdoaWNoIHRvIGJlZ2luIHNlYXJjaGluZyBmb3Igc2VhcmNoRWxlbWVudC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgQXJyYXlTY2hlbWEucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gKHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuJGl0ZW1zLnZhbHVlcygpKS5pbmNsdWRlcyhzZWFyY2hFbGVtZW50LCBmcm9tSW5kZXgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ2FsbHMgYSBkZWZpbmVkIGNhbGxiYWNrIGZ1bmN0aW9uIG9uIGVhY2ggZWxlbWVudCBvZiBhbiBhcnJheS4gVGhlbiwgZmxhdHRlbnMgdGhlIHJlc3VsdCBpbnRvXG4gICAgICAgICAgICAgKiBhIG5ldyBhcnJheS5cbiAgICAgICAgICAgICAqIFRoaXMgaXMgaWRlbnRpY2FsIHRvIGEgbWFwIGZvbGxvd2VkIGJ5IGZsYXQgd2l0aCBkZXB0aCAxLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSBjYWxsYmFjayBBIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyB1cCB0byB0aHJlZSBhcmd1bWVudHMuIFRoZSBmbGF0TWFwIG1ldGhvZCBjYWxscyB0aGVcbiAgICAgICAgICAgICAqIGNhbGxiYWNrIGZ1bmN0aW9uIG9uZSB0aW1lIGZvciBlYWNoIGVsZW1lbnQgaW4gdGhlIGFycmF5LlxuICAgICAgICAgICAgICogQHBhcmFtIHRoaXNBcmcgQW4gb2JqZWN0IHRvIHdoaWNoIHRoZSB0aGlzIGtleXdvcmQgY2FuIHJlZmVyIGluIHRoZSBjYWxsYmFjayBmdW5jdGlvbi4gSWZcbiAgICAgICAgICAgICAqIHRoaXNBcmcgaXMgb21pdHRlZCwgdW5kZWZpbmVkIGlzIHVzZWQgYXMgdGhlIHRoaXMgdmFsdWUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIEFycmF5U2NoZW1hLnByb3RvdHlwZS5mbGF0TWFwID0gZnVuY3Rpb24gKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFycmF5U2NoZW1hI2ZsYXRNYXAoKSBpcyBub3Qgc3VwcG9ydGVkLlwiKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldHVybnMgYSBuZXcgYXJyYXkgd2l0aCBhbGwgc3ViLWFycmF5IGVsZW1lbnRzIGNvbmNhdGVuYXRlZCBpbnRvIGl0IHJlY3Vyc2l2ZWx5IHVwIHRvIHRoZVxuICAgICAgICAgICAgICogc3BlY2lmaWVkIGRlcHRoLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSBkZXB0aCBUaGUgbWF4aW11bSByZWN1cnNpb24gZGVwdGhcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgQXJyYXlTY2hlbWEucHJvdG90eXBlLmZsYXQgPSBmdW5jdGlvbiAoZGVwdGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBcnJheVNjaGVtYSNmbGF0KCkgaXMgbm90IHN1cHBvcnRlZC5cIik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgQXJyYXlTY2hlbWEucHJvdG90eXBlLmZpbmRMYXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBhcnIgPSBBcnJheS5mcm9tKHRoaXMuJGl0ZW1zLnZhbHVlcygpKTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyci5maW5kTGFzdC5hcHBseShhcnIsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgQXJyYXlTY2hlbWEucHJvdG90eXBlLmZpbmRMYXN0SW5kZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyciA9IEFycmF5LmZyb20odGhpcy4kaXRlbXMudmFsdWVzKCkpO1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyLmZpbmRMYXN0SW5kZXguYXBwbHkoYXJyLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIGdldCBzaXplICgpIHtcbiAgICAgICAgICAgIC8vICAgICByZXR1cm4gdGhpcy4kaXRlbXMuc2l6ZTtcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIEFycmF5U2NoZW1hLnByb3RvdHlwZS5zZXRJbmRleCA9IGZ1bmN0aW9uIChpbmRleCwga2V5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kaW5kZXhlcy5zZXQoaW5kZXgsIGtleSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgQXJyYXlTY2hlbWEucHJvdG90eXBlLmdldEluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGluZGV4ZXMuZ2V0KGluZGV4KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBBcnJheVNjaGVtYS5wcm90b3R5cGUuZ2V0QnlJbmRleCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRpdGVtcy5nZXQodGhpcy4kaW5kZXhlcy5nZXQoaW5kZXgpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBBcnJheVNjaGVtYS5wcm90b3R5cGUuZGVsZXRlQnlJbmRleCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSB0aGlzLiRpbmRleGVzLmdldChpbmRleCk7XG4gICAgICAgICAgICAgICAgdGhpcy4kaXRlbXMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgdGhpcy4kaW5kZXhlcy5kZWxldGUoaW5kZXgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIEFycmF5U2NoZW1hLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuJGl0ZW1zLnZhbHVlcygpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBBcnJheVNjaGVtYS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAodHlwZW9mICh2YWx1ZVsndG9KU09OJ10pID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHZhbHVlWyd0b0pTT04nXSgpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHZhbHVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBEZWNvZGluZyB1dGlsaXRpZXNcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBBcnJheVNjaGVtYS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoaXNEZWNvZGluZykge1xuICAgICAgICAgICAgICAgIHZhciBjbG9uZWQ7XG4gICAgICAgICAgICAgICAgaWYgKGlzRGVjb2RpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvbmVkID0gbmV3IChBcnJheVNjaGVtYS5iaW5kLmFwcGx5KEFycmF5U2NoZW1hLCBfX3NwcmVhZEFycmF5KFt2b2lkIDBdLCBBcnJheS5mcm9tKHRoaXMuJGl0ZW1zLnZhbHVlcygpKSwgZmFsc2UpKSkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb25lZCA9IG5ldyAoQXJyYXlTY2hlbWEuYmluZC5hcHBseShBcnJheVNjaGVtYSwgX19zcHJlYWRBcnJheShbdm9pZCAwXSwgdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuICgoaXRlbVsnJGNoYW5nZXMnXSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gaXRlbS5jbG9uZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGl0ZW0pOyB9KSwgZmFsc2UpKSkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsb25lZDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gQXJyYXlTY2hlbWE7XG4gICAgICAgIH0oKSk7XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0TWFwUHJveHkodmFsdWUpIHtcbiAgICAgICAgICAgIHZhbHVlWyckcHJveHknXSA9IHRydWU7XG4gICAgICAgICAgICB2YWx1ZSA9IG5ldyBQcm94eSh2YWx1ZSwge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKG9iaiwgcHJvcCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChwcm9wKSAhPT0gXCJzeW1ib2xcIiAmJiAvLyBhY2Nlc3NpbmcgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIChvYmpbcHJvcF0pID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqLmdldChwcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmpbcHJvcF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKG9iaiwgcHJvcCwgc2V0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAocHJvcCkgIT09IFwic3ltYm9sXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChwcm9wLmluZGV4T2YoXCIkXCIpID09PSAtMSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3AgIT09IFwib25BZGRcIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3AgIT09IFwib25SZW1vdmVcIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3AgIT09IFwib25DaGFuZ2VcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iai5zZXQocHJvcCwgc2V0VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqW3Byb3BdID0gc2V0VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkZWxldGVQcm9wZXJ0eTogZnVuY3Rpb24gKG9iaiwgcHJvcCkge1xuICAgICAgICAgICAgICAgICAgICBvYmouZGVsZXRlKHByb3ApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIE1hcFNjaGVtYSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIE1hcFNjaGVtYShpbml0aWFsVmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICB0aGlzLiRjaGFuZ2VzID0gbmV3IENoYW5nZVRyZWUodGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy4kaXRlbXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgICAgdGhpcy4kaW5kZXhlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRyZWZJZCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKGluaXRpYWxWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluaXRpYWxWYWx1ZXMgaW5zdGFuY2VvZiBNYXAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxWYWx1ZXMgaW5zdGFuY2VvZiBNYXBTY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxWYWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAodiwgaykgeyByZXR1cm4gX3RoaXMuc2V0KGssIHYpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgaW4gaW5pdGlhbFZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0KGssIGluaXRpYWxWYWx1ZXNba10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgTWFwU2NoZW1hLnByb3RvdHlwZS5vbkFkZCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgdHJpZ2dlckFsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0cmlnZ2VyQWxsID09PSB2b2lkIDApIHsgdHJpZ2dlckFsbCA9IHRydWU7IH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYWRkQ2FsbGJhY2soKHRoaXMuJGNhbGxiYWNrcyB8fCAodGhpcy4kY2FsbGJhY2tzID0gW10pKSwgZXhwb3J0cy5PUEVSQVRJT04uQURELCBjYWxsYmFjaywgKHRyaWdnZXJBbGwpXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy4kaXRlbXNcbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIE1hcFNjaGVtYS5wcm90b3R5cGUub25SZW1vdmUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHsgcmV0dXJuIGFkZENhbGxiYWNrKHRoaXMuJGNhbGxiYWNrcyB8fCAodGhpcy4kY2FsbGJhY2tzID0gW10pLCBleHBvcnRzLk9QRVJBVElPTi5ERUxFVEUsIGNhbGxiYWNrKTsgfTtcbiAgICAgICAgICAgIE1hcFNjaGVtYS5wcm90b3R5cGUub25DaGFuZ2UgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHsgcmV0dXJuIGFkZENhbGxiYWNrKHRoaXMuJGNhbGxiYWNrcyB8fCAodGhpcy4kY2FsbGJhY2tzID0gW10pLCBleHBvcnRzLk9QRVJBVElPTi5SRVBMQUNFLCBjYWxsYmFjayk7IH07XG4gICAgICAgICAgICBNYXBTY2hlbWEuaXMgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlWydtYXAnXSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKiBJdGVyYXRvciAqL1xuICAgICAgICAgICAgTWFwU2NoZW1hLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy4kaXRlbXNbU3ltYm9sLml0ZXJhdG9yXSgpOyB9O1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hcFNjaGVtYS5wcm90b3R5cGUsIFN5bWJvbC50b1N0cmluZ1RhZywge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy4kaXRlbXNbU3ltYm9sLnRvU3RyaW5nVGFnXTsgfSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgTWFwU2NoZW1hLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1hcFNjaGVtYSNzZXQoJ1wiLmNvbmNhdChrZXksIFwiJywgXCIpLmNvbmNhdCh2YWx1ZSwgXCIpOiB0cnlpbmcgdG8gc2V0IFwiKS5jb25jYXQodmFsdWUsIFwiIHZhbHVlIG9uICdcIikuY29uY2F0KGtleSwgXCInLlwiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGdldCBcImluZGV4XCIgZm9yIHRoaXMgdmFsdWUuXG4gICAgICAgICAgICAgICAgdmFyIGhhc0luZGV4ID0gdHlwZW9mICh0aGlzLiRjaGFuZ2VzLmluZGV4ZXNba2V5XSkgIT09IFwidW5kZWZpbmVkXCI7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gKGhhc0luZGV4KVxuICAgICAgICAgICAgICAgICAgICA/IHRoaXMuJGNoYW5nZXMuaW5kZXhlc1trZXldXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy4kcmVmSWQrKztcbiAgICAgICAgICAgICAgICB2YXIgb3BlcmF0aW9uID0gKGhhc0luZGV4KVxuICAgICAgICAgICAgICAgICAgICA/IGV4cG9ydHMuT1BFUkFUSU9OLlJFUExBQ0VcbiAgICAgICAgICAgICAgICAgICAgOiBleHBvcnRzLk9QRVJBVElPTi5BREQ7XG4gICAgICAgICAgICAgICAgdmFyIGlzUmVmID0gKHZhbHVlWyckY2hhbmdlcyddKSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmIChpc1JlZikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZVsnJGNoYW5nZXMnXS5zZXRQYXJlbnQodGhpcywgdGhpcy4kY2hhbmdlcy5yb290LCBpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gKGVuY29kaW5nKVxuICAgICAgICAgICAgICAgIC8vIHNldCBhIHVuaXF1ZSBpZCB0byByZWxhdGUgZGlyZWN0bHkgd2l0aCB0aGlzIGtleS92YWx1ZS5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIGlmICghaGFzSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kY2hhbmdlcy5pbmRleGVzW2tleV0gPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kaW5kZXhlcy5zZXQoaW5kZXgsIGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzUmVmICYmIC8vIGlmIGlzIHNjaGVtYSwgZm9yY2UgQUREIG9wZXJhdGlvbiBpZiB2YWx1ZSBkaWZmZXIgZnJvbSBwcmV2aW91cyBvbmUuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGl0ZW1zLmdldChrZXkpICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb24gPSBleHBvcnRzLk9QRVJBVElPTi5BREQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuJGl0ZW1zLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRjaGFuZ2VzLmNoYW5nZShrZXksIG9wZXJhdGlvbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgTWFwU2NoZW1hLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGl0ZW1zLmdldChrZXkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIE1hcFNjaGVtYS5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogYWRkIGEgXCJwdXJnZVwiIG1ldGhvZCBhZnRlciAuZW5jb2RlKCkgcnVucywgdG8gY2xlYW51cCByZW1vdmVkIGAkaW5kZXhlc2BcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IHJlbW92ZSAkaW5kZXhlcyB0byBhbGxvdyBzZXR0aW5nIHRoZSBzYW1lIGtleSBpbiB0aGUgc2FtZSBwYXRjaFxuICAgICAgICAgICAgICAgIC8vIChTZWUgXCJzaG91bGQgYWxsb3cgdG8gcmVtb3ZlIGFuZCBzZXQgYW4gaXRlbSBpbiB0aGUgc2FtZSBwbGFjZVwiIHRlc3QpXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyAvLyBjb25zdCBpbmRleCA9IHRoaXMuJGNoYW5nZXMuaW5kZXhlc1trZXldO1xuICAgICAgICAgICAgICAgIC8vIC8vIHRoaXMuJGluZGV4ZXMuZGVsZXRlKGluZGV4KTtcbiAgICAgICAgICAgICAgICB0aGlzLiRjaGFuZ2VzLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRpdGVtcy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBNYXBTY2hlbWEucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBkaXNjYXJkIHByZXZpb3VzIG9wZXJhdGlvbnMuXG4gICAgICAgICAgICAgICAgdGhpcy4kY2hhbmdlcy5kaXNjYXJkKHRydWUsIHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGNoYW5nZXMuaW5kZXhlcyA9IHt9O1xuICAgICAgICAgICAgICAgIC8vIGNsZWFyIHByZXZpb3VzIGluZGV4ZXNcbiAgICAgICAgICAgICAgICB0aGlzLiRpbmRleGVzLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBXaGVuIGRlY29kaW5nOlxuICAgICAgICAgICAgICAgIC8vIC0gZW5xdWV1ZSBpdGVtcyBmb3IgREVMRVRFIGNhbGxiYWNrLlxuICAgICAgICAgICAgICAgIC8vIC0gZmxhZyBjaGlsZCBpdGVtcyBmb3IgZ2FyYmFnZSBjb2xsZWN0aW9uLlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQ2hpbGRSZWZzLmNhbGwodGhpcywgY2hhbmdlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGNsZWFyIGl0ZW1zXG4gICAgICAgICAgICAgICAgdGhpcy4kaXRlbXMuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRjaGFuZ2VzLm9wZXJhdGlvbih7IGluZGV4OiAwLCBvcDogZXhwb3J0cy5PUEVSQVRJT04uQ0xFQVIgfSk7XG4gICAgICAgICAgICAgICAgLy8gdG91Y2ggYWxsIHN0cnVjdHVyZXMgdW50aWwgcmVhY2ggcm9vdFxuICAgICAgICAgICAgICAgIHRoaXMuJGNoYW5nZXMudG91Y2hQYXJlbnRzKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgTWFwU2NoZW1hLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGl0ZW1zLmhhcyhrZXkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIE1hcFNjaGVtYS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFja2ZuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kaXRlbXMuZm9yRWFjaChjYWxsYmFja2ZuKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBNYXBTY2hlbWEucHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGl0ZW1zLmVudHJpZXMoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBNYXBTY2hlbWEucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGl0ZW1zLmtleXMoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBNYXBTY2hlbWEucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kaXRlbXMudmFsdWVzKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hcFNjaGVtYS5wcm90b3R5cGUsIFwic2l6ZVwiLCB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRpdGVtcy5zaXplO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIE1hcFNjaGVtYS5wcm90b3R5cGUuc2V0SW5kZXggPSBmdW5jdGlvbiAoaW5kZXgsIGtleSkge1xuICAgICAgICAgICAgICAgIHRoaXMuJGluZGV4ZXMuc2V0KGluZGV4LCBrZXkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIE1hcFNjaGVtYS5wcm90b3R5cGUuZ2V0SW5kZXggPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kaW5kZXhlcy5nZXQoaW5kZXgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIE1hcFNjaGVtYS5wcm90b3R5cGUuZ2V0QnlJbmRleCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRpdGVtcy5nZXQodGhpcy4kaW5kZXhlcy5nZXQoaW5kZXgpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBNYXBTY2hlbWEucHJvdG90eXBlLmRlbGV0ZUJ5SW5kZXggPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gdGhpcy4kaW5kZXhlcy5nZXQoaW5kZXgpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGl0ZW1zLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGluZGV4ZXMuZGVsZXRlKGluZGV4KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBNYXBTY2hlbWEucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWFwID0ge307XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcFtrZXldID0gKHR5cGVvZiAodmFsdWVbJ3RvSlNPTiddKSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyB2YWx1ZVsndG9KU09OJ10oKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFwO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBEZWNvZGluZyB1dGlsaXRpZXNcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBNYXBTY2hlbWEucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKGlzRGVjb2RpbmcpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2xvbmVkO1xuICAgICAgICAgICAgICAgIGlmIChpc0RlY29kaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNsaWVudC1zaWRlXG4gICAgICAgICAgICAgICAgICAgIGNsb25lZCA9IE9iamVjdC5hc3NpZ24obmV3IE1hcFNjaGVtYSgpLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNlcnZlci1zaWRlXG4gICAgICAgICAgICAgICAgICAgIGNsb25lZCA9IG5ldyBNYXBTY2hlbWEoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVbJyRjaGFuZ2VzJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9uZWQuc2V0KGtleSwgdmFsdWVbJ2Nsb25lJ10oKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9uZWQuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsb25lZDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gTWFwU2NoZW1hO1xuICAgICAgICB9KCkpO1xuXG4gICAgICAgIHZhciByZWdpc3RlcmVkVHlwZXMgPSB7fTtcbiAgICAgICAgZnVuY3Rpb24gcmVnaXN0ZXJUeXBlKGlkZW50aWZpZXIsIGRlZmluaXRpb24pIHtcbiAgICAgICAgICAgIHJlZ2lzdGVyZWRUeXBlc1tpZGVudGlmaWVyXSA9IGRlZmluaXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0VHlwZShpZGVudGlmaWVyKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVnaXN0ZXJlZFR5cGVzW2lkZW50aWZpZXJdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIFNjaGVtYURlZmluaXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBTY2hlbWFEZWZpbml0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogdXNlIGEgXCJmaWVsZFwiIHN0cnVjdHVyZSBjb21iaW5pbmcgYWxsIHRoZXNlIHByb3BlcnRpZXMgcGVyLWZpZWxkLlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleGVzID0ge307XG4gICAgICAgICAgICAgICAgdGhpcy5maWVsZHNCeUluZGV4ID0ge307XG4gICAgICAgICAgICAgICAgdGhpcy5kZXByZWNhdGVkID0ge307XG4gICAgICAgICAgICAgICAgdGhpcy5kZXNjcmlwdG9ycyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgU2NoZW1hRGVmaW5pdGlvbi5jcmVhdGUgPSBmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlZmluaXRpb24gPSBuZXcgU2NoZW1hRGVmaW5pdGlvbigpO1xuICAgICAgICAgICAgICAgIC8vIHN1cHBvcnQgaW5oZXJpdGFuY2VcbiAgICAgICAgICAgICAgICBkZWZpbml0aW9uLnNjaGVtYSA9IE9iamVjdC5hc3NpZ24oe30sIHBhcmVudCAmJiBwYXJlbnQuc2NoZW1hIHx8IHt9KTtcbiAgICAgICAgICAgICAgICBkZWZpbml0aW9uLmluZGV4ZXMgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJlbnQgJiYgcGFyZW50LmluZGV4ZXMgfHwge30pO1xuICAgICAgICAgICAgICAgIGRlZmluaXRpb24uZmllbGRzQnlJbmRleCA9IE9iamVjdC5hc3NpZ24oe30sIHBhcmVudCAmJiBwYXJlbnQuZmllbGRzQnlJbmRleCB8fCB7fSk7XG4gICAgICAgICAgICAgICAgZGVmaW5pdGlvbi5kZXNjcmlwdG9ycyA9IE9iamVjdC5hc3NpZ24oe30sIHBhcmVudCAmJiBwYXJlbnQuZGVzY3JpcHRvcnMgfHwge30pO1xuICAgICAgICAgICAgICAgIGRlZmluaXRpb24uZGVwcmVjYXRlZCA9IE9iamVjdC5hc3NpZ24oe30sIHBhcmVudCAmJiBwYXJlbnQuZGVwcmVjYXRlZCB8fCB7fSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmluaXRpb247XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgU2NoZW1hRGVmaW5pdGlvbi5wcm90b3R5cGUuYWRkRmllbGQgPSBmdW5jdGlvbiAoZmllbGQsIHR5cGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmdldE5leHRGaWVsZEluZGV4KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5maWVsZHNCeUluZGV4W2luZGV4XSA9IGZpZWxkO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhlc1tmaWVsZF0gPSBpbmRleDtcbiAgICAgICAgICAgICAgICB0aGlzLnNjaGVtYVtmaWVsZF0gPSAoQXJyYXkuaXNBcnJheSh0eXBlKSlcbiAgICAgICAgICAgICAgICAgICAgPyB7IGFycmF5OiB0eXBlWzBdIH1cbiAgICAgICAgICAgICAgICAgICAgOiB0eXBlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFNjaGVtYURlZmluaXRpb24ucHJvdG90eXBlLmhhc0ZpZWxkID0gZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhlc1tmaWVsZF0gIT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBTY2hlbWFEZWZpbml0aW9uLnByb3RvdHlwZS5hZGRGaWx0ZXIgPSBmdW5jdGlvbiAoZmllbGQsIGNiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmZpbHRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJzID0ge307XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhlc1dpdGhGaWx0ZXJzID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyc1t0aGlzLmluZGV4ZXNbZmllbGRdXSA9IGNiO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhlc1dpdGhGaWx0ZXJzLnB1c2godGhpcy5pbmRleGVzW2ZpZWxkXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgU2NoZW1hRGVmaW5pdGlvbi5wcm90b3R5cGUuYWRkQ2hpbGRyZW5GaWx0ZXIgPSBmdW5jdGlvbiAoZmllbGQsIGNiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleGVzW2ZpZWxkXTtcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IHRoaXMuc2NoZW1hW2ZpZWxkXTtcbiAgICAgICAgICAgICAgICBpZiAoZ2V0VHlwZShPYmplY3Qua2V5cyh0eXBlKVswXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNoaWxkRmlsdGVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZEZpbHRlcnMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoaWxkRmlsdGVyc1tpbmRleF0gPSBjYjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJAZmlsdGVyQ2hpbGRyZW46IGZpZWxkICdcIi5jb25jYXQoZmllbGQsIFwiJyBjYW4ndCBoYXZlIGNoaWxkcmVuLiBJZ25vcmluZyBmaWx0ZXIuXCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgU2NoZW1hRGVmaW5pdGlvbi5wcm90b3R5cGUuZ2V0Q2hpbGRyZW5GaWx0ZXIgPSBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZEZpbHRlcnMgJiYgdGhpcy5jaGlsZEZpbHRlcnNbdGhpcy5pbmRleGVzW2ZpZWxkXV07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgU2NoZW1hRGVmaW5pdGlvbi5wcm90b3R5cGUuZ2V0TmV4dEZpZWxkSW5kZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuc2NoZW1hIHx8IHt9KS5sZW5ndGg7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIFNjaGVtYURlZmluaXRpb247XG4gICAgICAgIH0oKSk7XG4gICAgICAgIGZ1bmN0aW9uIGhhc0ZpbHRlcihrbGFzcykge1xuICAgICAgICAgICAgcmV0dXJuIGtsYXNzLl9jb250ZXh0ICYmIGtsYXNzLl9jb250ZXh0LnVzZUZpbHRlcnM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIENvbnRleHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBDb250ZXh0KCkge1xuICAgICAgICAgICAgICAgIHRoaXMudHlwZXMgPSB7fTtcbiAgICAgICAgICAgICAgICB0aGlzLnNjaGVtYXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgICAgdGhpcy51c2VGaWx0ZXJzID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBDb250ZXh0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAoc2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NoZW1hcy5oYXMoc2NoZW1hKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBDb250ZXh0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodHlwZWlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudHlwZXNbdHlwZWlkXTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBDb250ZXh0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoc2NoZW1hLCB0eXBlaWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZWlkID09PSB2b2lkIDApIHsgdHlwZWlkID0gdGhpcy5zY2hlbWFzLnNpemU7IH1cbiAgICAgICAgICAgICAgICAvLyBGSVhNRTogbW92ZSB0aGlzIHRvIHNvbWV3aGVyZSBlbHNlP1xuICAgICAgICAgICAgICAgIC8vIHN1cHBvcnQgaW5oZXJpdGFuY2VcbiAgICAgICAgICAgICAgICBzY2hlbWEuX2RlZmluaXRpb24gPSBTY2hlbWFEZWZpbml0aW9uLmNyZWF0ZShzY2hlbWEuX2RlZmluaXRpb24pO1xuICAgICAgICAgICAgICAgIHNjaGVtYS5fdHlwZWlkID0gdHlwZWlkO1xuICAgICAgICAgICAgICAgIHRoaXMudHlwZXNbdHlwZWlkXSA9IHNjaGVtYTtcbiAgICAgICAgICAgICAgICB0aGlzLnNjaGVtYXMuc2V0KHNjaGVtYSwgdHlwZWlkKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBDb250ZXh0LmNyZWF0ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRlZmluaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLmNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuY29udGV4dCA9IG5ldyBDb250ZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGUoZGVmaW5pdGlvbiwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gQ29udGV4dDtcbiAgICAgICAgfSgpKTtcbiAgICAgICAgdmFyIGdsb2JhbENvbnRleHQgPSBuZXcgQ29udGV4dCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogW1NlZSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MuY29seXNldXMuaW8vc3RhdGUvc2NoZW1hLylcbiAgICAgICAgICpcbiAgICAgICAgICogQW5ub3RhdGUgYSBTY2hlbWEgcHJvcGVydHkgdG8gYmUgc2VyaWFsaXplYWJsZS5cbiAgICAgICAgICogXFxAdHlwZSgpJ2QgZmllbGRzIGFyZSBhdXRvbWF0aWNhbGx5IGZsYWdnZWQgYXMgXCJkaXJ0eVwiIGZvciB0aGUgbmV4dCBwYXRjaC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgU3RhbmRhcmQgdXNhZ2UsIHdpdGggYXV0b21hdGljIGNoYW5nZSB0cmFja2luZy5cbiAgICAgICAgICogYGBgXG4gICAgICAgICAqIFxcQHR5cGUoXCJzdHJpbmdcIikgcHJvcGVydHlOYW1lOiBzdHJpbmc7XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSBZb3UgY2FuIHByb3ZpZGUgdGhlIFwibWFudWFsXCIgb3B0aW9uIGlmIHlvdSdkIGxpa2UgdG8gbWFudWFsbHkgY29udHJvbCB5b3VyIHBhdGNoZXMgdmlhIC5zZXREaXJ0eSgpLlxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICogXFxAdHlwZShcInN0cmluZ1wiLCB7IG1hbnVhbDogdHJ1ZSB9KVxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIHR5cGUodHlwZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBmaWVsZCkge1xuICAgICAgICAgICAgICAgIHZhciBjb250ZXh0ID0gb3B0aW9ucy5jb250ZXh0IHx8IGdsb2JhbENvbnRleHQ7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnN0cnVjdG9yID0gdGFyZ2V0LmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIuY29uY2F0KGNvbnN0cnVjdG9yLm5hbWUsIFwiOiBAdHlwZSgpIHJlZmVyZW5jZSBwcm92aWRlZCBmb3IgXFxcIlwiKS5jb25jYXQoZmllbGQsIFwiXFxcIiBpcyB1bmRlZmluZWQuIE1ha2Ugc3VyZSB5b3UgZG9uJ3QgaGF2ZSBhbnkgY2lyY3VsYXIgZGVwZW5kZW5jaWVzLlwiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogc3RhdGljIHNjaGVtYVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmICghY29udGV4dC5oYXMoY29uc3RydWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuYWRkKGNvbnN0cnVjdG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGRlZmluaXRpb24gPSBjb25zdHJ1Y3Rvci5fZGVmaW5pdGlvbjtcbiAgICAgICAgICAgICAgICBkZWZpbml0aW9uLmFkZEZpZWxkKGZpZWxkLCB0eXBlKTtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBza2lwIGlmIGRlc2NyaXB0b3IgYWxyZWFkeSBleGlzdHMgZm9yIHRoaXMgZmllbGQgKGBAZGVwcmVjYXRlZCgpYClcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpZiAoZGVmaW5pdGlvbi5kZXNjcmlwdG9yc1tmaWVsZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlZmluaXRpb24uZGVwcmVjYXRlZFtmaWVsZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvIG5vdCBjcmVhdGUgYWNjZXNzb3JzIGZvciBkZXByZWNhdGVkIHByb3BlcnRpZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0cnlpbmcgdG8gZGVmaW5lIHNhbWUgcHJvcGVydHkgbXVsdGlwbGUgdGltZXMgYWNyb3NzIGluaGVyaXRhbmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NvbHlzZXVzL2NvbHlzZXVzLXVuaXR5M2QvaXNzdWVzLzEzMSNpc3N1ZWNvbW1lbnQtODE0MzA4NTcyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkBjb2x5c2V1cy9zY2hlbWE6IER1cGxpY2F0ZSAnXCIuY29uY2F0KGZpZWxkLCBcIicgZGVmaW5pdGlvbiBvbiAnXCIpLmNvbmNhdChjb25zdHJ1Y3Rvci5uYW1lLCBcIicuXFxuQ2hlY2sgQHR5cGUoKSBhbm5vdGF0aW9uXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlZmluaXRpb25BdExpbmUgPSBlLnN0YWNrLnNwbGl0KFwiXFxuXCIpWzRdLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIi5jb25jYXQoZS5tZXNzYWdlLCBcIiBcIikuY29uY2F0KGRlZmluaXRpb25BdExpbmUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgaXNBcnJheSA9IEFycmF5U2NoZW1hLmlzKHR5cGUpO1xuICAgICAgICAgICAgICAgIHZhciBpc01hcCA9ICFpc0FycmF5ICYmIE1hcFNjaGVtYS5pcyh0eXBlKTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiByZWZhY3RvciBtZS5cbiAgICAgICAgICAgICAgICAvLyBBbGxvdyBhYnN0cmFjdCBpbnRlcm1lZGlhcnkgY2xhc3NlcyB3aXRoIG5vIGZpZWxkcyB0byBiZSBzZXJpYWxpemVkXG4gICAgICAgICAgICAgICAgLy8gKFNlZSBcInNob3VsZCBzdXBwb3J0IGFuIGluaGVyaXRhbmNlIHdpdGggYSBTY2hlbWEgdHlwZSB3aXRob3V0IGZpZWxkc1wiIHRlc3QpXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAodHlwZSkgIT09IFwic3RyaW5nXCIgJiYgIVNjaGVtYS5pcyh0eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGRUeXBlID0gT2JqZWN0LnZhbHVlcyh0eXBlKVswXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAoY2hpbGRUeXBlKSAhPT0gXCJzdHJpbmdcIiAmJiAhY29udGV4dC5oYXMoY2hpbGRUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5hZGQoY2hpbGRUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5tYW51YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZG8gbm90IGRlY2xhcmUgZ2V0dGVyL3NldHRlciBkZXNjcmlwdG9yXG4gICAgICAgICAgICAgICAgICAgIGRlZmluaXRpb24uZGVzY3JpcHRvcnNbZmllbGRdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBmaWVsZENhY2hlZCA9IFwiX1wiLmNvbmNhdChmaWVsZCk7XG4gICAgICAgICAgICAgICAgZGVmaW5pdGlvbi5kZXNjcmlwdG9yc1tmaWVsZENhY2hlZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGRlZmluaXRpb24uZGVzY3JpcHRvcnNbZmllbGRdID0ge1xuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW2ZpZWxkQ2FjaGVkXTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogQ3JlYXRlIFByb3h5IGZvciBhcnJheSBvciBtYXAgaXRlbXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2tpcCBpZiB2YWx1ZSBpcyB0aGUgc2FtZSBhcyBjYWNoZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHRoaXNbZmllbGRDYWNoZWRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGF1dG9tYXRpY2FsbHR5IHRyYW5zZm9ybSBBcnJheSBpbnRvIEFycmF5U2NoZW1hXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5U2NoZW1hKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyAoQXJyYXlTY2hlbWEuYmluZC5hcHBseShBcnJheVNjaGVtYSwgX19zcHJlYWRBcnJheShbdm9pZCAwXSwgdmFsdWUsIGZhbHNlKSkpKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGF1dG9tYXRpY2FsbHR5IHRyYW5zZm9ybSBNYXAgaW50byBNYXBTY2hlbWFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNNYXAgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIE1hcFNjaGVtYSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgTWFwU2NoZW1hKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ5IHRvIHR1cm4gcHJvdmlkZWQgc3RydWN0dXJlIGludG8gYSBQcm94eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZVsnJHByb3h5J10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZ2V0TWFwUHJveHkodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZ2V0QXJyYXlQcm94eSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmxhZyB0aGUgY2hhbmdlIGZvciBlbmNvZGluZy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRjaGFuZ2VzLmNoYW5nZShmaWVsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjYWxsIHNldFBhcmVudCgpIHJlY3Vyc2l2ZWx5IGZvciB0aGlzIGFuZCBpdHMgY2hpbGRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdHJ1Y3R1cmVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlWyckY2hhbmdlcyddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlWyckY2hhbmdlcyddLnNldFBhcmVudCh0aGlzLCB0aGlzLiRjaGFuZ2VzLnJvb3QsIHRoaXMuX2RlZmluaXRpb24uaW5kZXhlc1tmaWVsZF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXNbZmllbGRDYWNoZWRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXR0aW5nIGEgZmllbGQgdG8gYG51bGxgIG9yIGB1bmRlZmluZWRgIHdpbGwgZGVsZXRlIGl0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kY2hhbmdlcy5kZWxldGUoZmllbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tmaWVsZENhY2hlZF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGBAZmlsdGVyKClgIGRlY29yYXRvciBmb3IgZGVmaW5pbmcgZGF0YSBmaWx0ZXJzIHBlciBjbGllbnRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGZpbHRlcihjYikge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGZpZWxkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnN0cnVjdG9yID0gdGFyZ2V0LmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgICAgIHZhciBkZWZpbml0aW9uID0gY29uc3RydWN0b3IuX2RlZmluaXRpb247XG4gICAgICAgICAgICAgICAgaWYgKGRlZmluaXRpb24uYWRkRmlsdGVyKGZpZWxkLCBjYikpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3RydWN0b3IuX2NvbnRleHQudXNlRmlsdGVycyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBmaWx0ZXJDaGlsZHJlbihjYikge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGZpZWxkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnN0cnVjdG9yID0gdGFyZ2V0LmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgICAgIHZhciBkZWZpbml0aW9uID0gY29uc3RydWN0b3IuX2RlZmluaXRpb247XG4gICAgICAgICAgICAgICAgaWYgKGRlZmluaXRpb24uYWRkQ2hpbGRyZW5GaWx0ZXIoZmllbGQsIGNiKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdHJ1Y3Rvci5fY29udGV4dC51c2VGaWx0ZXJzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBgQGRlcHJlY2F0ZWQoKWAgZmxhZyBhIGZpZWxkIGFzIGRlcHJlY2F0ZWQuXG4gICAgICAgICAqIFRoZSBwcmV2aW91cyBgQHR5cGUoKWAgYW5ub3RhdGlvbiBzaG91bGQgcmVtYWluIGFsb25nIHdpdGggdGhpcyBvbmUuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBkZXByZWNhdGVkKHRocm93cykge1xuICAgICAgICAgICAgaWYgKHRocm93cyA9PT0gdm9pZCAwKSB7IHRocm93cyA9IHRydWU7IH1cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBmaWVsZCkge1xuICAgICAgICAgICAgICAgIHZhciBjb25zdHJ1Y3RvciA9IHRhcmdldC5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgICAgICB2YXIgZGVmaW5pdGlvbiA9IGNvbnN0cnVjdG9yLl9kZWZpbml0aW9uO1xuICAgICAgICAgICAgICAgIGRlZmluaXRpb24uZGVwcmVjYXRlZFtmaWVsZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICh0aHJvd3MpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5pdGlvbi5kZXNjcmlwdG9yc1tmaWVsZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgdGhyb3cgbmV3IEVycm9yKFwiXCIuY29uY2F0KGZpZWxkLCBcIiBpcyBkZXByZWNhdGVkLlwiKSk7IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGRlZmluZVR5cGVzKHRhcmdldCwgZmllbGRzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmNvbnRleHQgPSB0YXJnZXQuX2NvbnRleHQgfHwgb3B0aW9ucy5jb250ZXh0IHx8IGdsb2JhbENvbnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBmaWVsZCBpbiBmaWVsZHMpIHtcbiAgICAgICAgICAgICAgICB0eXBlKGZpZWxkc1tmaWVsZF0sIG9wdGlvbnMpKHRhcmdldC5wcm90b3R5cGUsIGZpZWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29weXJpZ2h0IChjKSAyMDE4IEVuZGVsIERyZXllclxuICAgICAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMTQgSW9uIERyaXZlIFNvZnR3YXJlIEx0ZC5cbiAgICAgICAgICpcbiAgICAgICAgICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICAgICAgICAgKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gICAgICAgICAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAgICAgICAgICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICAgICAgICAgKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAgICAgICAgICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gICAgICAgICAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAgICAgICAgICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gICAgICAgICAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICAgICAgICAgKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gICAgICAgICAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gICAgICAgICAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gICAgICAgICAqIFNPRlRXQVJFXG4gICAgICAgICAqL1xuICAgICAgICAvKipcbiAgICAgICAgICogbXNncGFjayBpbXBsZW1lbnRhdGlvbiBoaWdobHkgYmFzZWQgb24gbm90ZXBhY2suaW9cbiAgICAgICAgICogaHR0cHM6Ly9naXRodWIuY29tL2RhcnJhY2hlcXVlc25lL25vdGVwYWNrXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiB1dGY4TGVuZ3RoKHN0cikge1xuICAgICAgICAgICAgdmFyIGMgPSAwLCBsZW5ndGggPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdHIubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgICAgICAgICAgICAgICBsZW5ndGggKz0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYyA8IDB4ODAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCArPSAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjIDwgMHhkODAwIHx8IGMgPj0gMHhlMDAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCArPSAzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICBsZW5ndGggKz0gNDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHV0ZjhXcml0ZSh2aWV3LCBvZmZzZXQsIHN0cikge1xuICAgICAgICAgICAgdmFyIGMgPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdHIubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgICAgICAgICAgICAgICB2aWV3W29mZnNldCsrXSA9IGM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGMgPCAweDgwMCkge1xuICAgICAgICAgICAgICAgICAgICB2aWV3W29mZnNldCsrXSA9IDB4YzAgfCAoYyA+PiA2KTtcbiAgICAgICAgICAgICAgICAgICAgdmlld1tvZmZzZXQrK10gPSAweDgwIHwgKGMgJiAweDNmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYyA8IDB4ZDgwMCB8fCBjID49IDB4ZTAwMCkge1xuICAgICAgICAgICAgICAgICAgICB2aWV3W29mZnNldCsrXSA9IDB4ZTAgfCAoYyA+PiAxMik7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdbb2Zmc2V0KytdID0gMHg4MCB8IChjID4+IDYgJiAweDNmKTtcbiAgICAgICAgICAgICAgICAgICAgdmlld1tvZmZzZXQrK10gPSAweDgwIHwgKGMgJiAweDNmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgYyA9IDB4MTAwMDAgKyAoKChjICYgMHgzZmYpIDw8IDEwKSB8IChzdHIuY2hhckNvZGVBdChpKSAmIDB4M2ZmKSk7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdbb2Zmc2V0KytdID0gMHhmMCB8IChjID4+IDE4KTtcbiAgICAgICAgICAgICAgICAgICAgdmlld1tvZmZzZXQrK10gPSAweDgwIHwgKGMgPj4gMTIgJiAweDNmKTtcbiAgICAgICAgICAgICAgICAgICAgdmlld1tvZmZzZXQrK10gPSAweDgwIHwgKGMgPj4gNiAmIDB4M2YpO1xuICAgICAgICAgICAgICAgICAgICB2aWV3W29mZnNldCsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpbnQ4JDEoYnl0ZXMsIHZhbHVlKSB7XG4gICAgICAgICAgICBieXRlcy5wdXNoKHZhbHVlICYgMjU1KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB1aW50OCQxKGJ5dGVzLCB2YWx1ZSkge1xuICAgICAgICAgICAgYnl0ZXMucHVzaCh2YWx1ZSAmIDI1NSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaW50MTYkMShieXRlcywgdmFsdWUpIHtcbiAgICAgICAgICAgIGJ5dGVzLnB1c2godmFsdWUgJiAyNTUpO1xuICAgICAgICAgICAgYnl0ZXMucHVzaCgodmFsdWUgPj4gOCkgJiAyNTUpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHVpbnQxNiQxKGJ5dGVzLCB2YWx1ZSkge1xuICAgICAgICAgICAgYnl0ZXMucHVzaCh2YWx1ZSAmIDI1NSk7XG4gICAgICAgICAgICBieXRlcy5wdXNoKCh2YWx1ZSA+PiA4KSAmIDI1NSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaW50MzIkMShieXRlcywgdmFsdWUpIHtcbiAgICAgICAgICAgIGJ5dGVzLnB1c2godmFsdWUgJiAyNTUpO1xuICAgICAgICAgICAgYnl0ZXMucHVzaCgodmFsdWUgPj4gOCkgJiAyNTUpO1xuICAgICAgICAgICAgYnl0ZXMucHVzaCgodmFsdWUgPj4gMTYpICYgMjU1KTtcbiAgICAgICAgICAgIGJ5dGVzLnB1c2goKHZhbHVlID4+IDI0KSAmIDI1NSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdWludDMyJDEoYnl0ZXMsIHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgYjQgPSB2YWx1ZSA+PiAyNDtcbiAgICAgICAgICAgIHZhciBiMyA9IHZhbHVlID4+IDE2O1xuICAgICAgICAgICAgdmFyIGIyID0gdmFsdWUgPj4gODtcbiAgICAgICAgICAgIHZhciBiMSA9IHZhbHVlO1xuICAgICAgICAgICAgYnl0ZXMucHVzaChiMSAmIDI1NSk7XG4gICAgICAgICAgICBieXRlcy5wdXNoKGIyICYgMjU1KTtcbiAgICAgICAgICAgIGJ5dGVzLnB1c2goYjMgJiAyNTUpO1xuICAgICAgICAgICAgYnl0ZXMucHVzaChiNCAmIDI1NSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaW50NjQkMShieXRlcywgdmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBoaWdoID0gTWF0aC5mbG9vcih2YWx1ZSAvIE1hdGgucG93KDIsIDMyKSk7XG4gICAgICAgICAgICB2YXIgbG93ID0gdmFsdWUgPj4+IDA7XG4gICAgICAgICAgICB1aW50MzIkMShieXRlcywgbG93KTtcbiAgICAgICAgICAgIHVpbnQzMiQxKGJ5dGVzLCBoaWdoKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB1aW50NjQkMShieXRlcywgdmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBoaWdoID0gKHZhbHVlIC8gTWF0aC5wb3coMiwgMzIpKSA+PiAwO1xuICAgICAgICAgICAgdmFyIGxvdyA9IHZhbHVlID4+PiAwO1xuICAgICAgICAgICAgdWludDMyJDEoYnl0ZXMsIGxvdyk7XG4gICAgICAgICAgICB1aW50MzIkMShieXRlcywgaGlnaCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZmxvYXQzMiQxKGJ5dGVzLCB2YWx1ZSkge1xuICAgICAgICAgICAgd3JpdGVGbG9hdDMyKGJ5dGVzLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZmxvYXQ2NCQxKGJ5dGVzLCB2YWx1ZSkge1xuICAgICAgICAgICAgd3JpdGVGbG9hdDY0KGJ5dGVzLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9pbnQzMiQxID0gbmV3IEludDMyQXJyYXkoMik7XG4gICAgICAgIHZhciBfZmxvYXQzMiQxID0gbmV3IEZsb2F0MzJBcnJheShfaW50MzIkMS5idWZmZXIpO1xuICAgICAgICB2YXIgX2Zsb2F0NjQkMSA9IG5ldyBGbG9hdDY0QXJyYXkoX2ludDMyJDEuYnVmZmVyKTtcbiAgICAgICAgZnVuY3Rpb24gd3JpdGVGbG9hdDMyKGJ5dGVzLCB2YWx1ZSkge1xuICAgICAgICAgICAgX2Zsb2F0MzIkMVswXSA9IHZhbHVlO1xuICAgICAgICAgICAgaW50MzIkMShieXRlcywgX2ludDMyJDFbMF0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlRmxvYXQ2NChieXRlcywgdmFsdWUpIHtcbiAgICAgICAgICAgIF9mbG9hdDY0JDFbMF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIGludDMyJDEoYnl0ZXMsIF9pbnQzMiQxWzAgXSk7XG4gICAgICAgICAgICBpbnQzMiQxKGJ5dGVzLCBfaW50MzIkMVsxIF0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJvb2xlYW4kMShieXRlcywgdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB1aW50OCQxKGJ5dGVzLCB2YWx1ZSA/IDEgOiAwKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzdHJpbmckMShieXRlcywgdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIGVuY29kZSBgbnVsbGAgc3RyaW5ncyBhcyBlbXB0eS5cbiAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gdXRmOExlbmd0aCh2YWx1ZSk7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IDA7XG4gICAgICAgICAgICAvLyBmaXhzdHJcbiAgICAgICAgICAgIGlmIChsZW5ndGggPCAweDIwKSB7XG4gICAgICAgICAgICAgICAgYnl0ZXMucHVzaChsZW5ndGggfCAweGEwKTtcbiAgICAgICAgICAgICAgICBzaXplID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHN0ciA4XG4gICAgICAgICAgICBlbHNlIGlmIChsZW5ndGggPCAweDEwMCkge1xuICAgICAgICAgICAgICAgIGJ5dGVzLnB1c2goMHhkOSk7XG4gICAgICAgICAgICAgICAgdWludDgkMShieXRlcywgbGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBzaXplID0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHN0ciAxNlxuICAgICAgICAgICAgZWxzZSBpZiAobGVuZ3RoIDwgMHgxMDAwMCkge1xuICAgICAgICAgICAgICAgIGJ5dGVzLnB1c2goMHhkYSk7XG4gICAgICAgICAgICAgICAgdWludDE2JDEoYnl0ZXMsIGxlbmd0aCk7XG4gICAgICAgICAgICAgICAgc2l6ZSA9IDM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzdHIgMzJcbiAgICAgICAgICAgIGVsc2UgaWYgKGxlbmd0aCA8IDB4MTAwMDAwMDAwKSB7XG4gICAgICAgICAgICAgICAgYnl0ZXMucHVzaCgweGRiKTtcbiAgICAgICAgICAgICAgICB1aW50MzIkMShieXRlcywgbGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBzaXplID0gNTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU3RyaW5nIHRvbyBsb25nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1dGY4V3JpdGUoYnl0ZXMsIGJ5dGVzLmxlbmd0aCwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHNpemUgKyBsZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbnVtYmVyJDEoYnl0ZXMsIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlciQxKGJ5dGVzLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyJDEoYnl0ZXMsICh2YWx1ZSA+IDApID8gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgOiAtTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgIT09ICh2YWx1ZSB8IDApKSB7XG4gICAgICAgICAgICAgICAgYnl0ZXMucHVzaCgweGNiKTtcbiAgICAgICAgICAgICAgICB3cml0ZUZsb2F0NjQoYnl0ZXMsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gOTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBlbmNvZGUgZmxvYXQgMzI/XG4gICAgICAgICAgICAgICAgLy8gaXMgaXQgcG9zc2libGUgdG8gZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIGZsb2F0MzIgLyBmbG9hdDY0IGhlcmU/XG4gICAgICAgICAgICAgICAgLy8gLy8gZmxvYXQgMzJcbiAgICAgICAgICAgICAgICAvLyBieXRlcy5wdXNoKDB4Y2EpO1xuICAgICAgICAgICAgICAgIC8vIHdyaXRlRmxvYXQzMihieXRlcywgdmFsdWUpO1xuICAgICAgICAgICAgICAgIC8vIHJldHVybiA1O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlID49IDApIHtcbiAgICAgICAgICAgICAgICAvLyBwb3NpdGl2ZSBmaXhudW1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPCAweDgwKSB7XG4gICAgICAgICAgICAgICAgICAgIHVpbnQ4JDEoYnl0ZXMsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHVpbnQgOFxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA8IDB4MTAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVzLnB1c2goMHhjYyk7XG4gICAgICAgICAgICAgICAgICAgIHVpbnQ4JDEoYnl0ZXMsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHVpbnQgMTZcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPCAweDEwMDAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVzLnB1c2goMHhjZCk7XG4gICAgICAgICAgICAgICAgICAgIHVpbnQxNiQxKGJ5dGVzLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB1aW50IDMyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIDwgMHgxMDAwMDAwMDApIHtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZXMucHVzaCgweGNlKTtcbiAgICAgICAgICAgICAgICAgICAgdWludDMyJDEoYnl0ZXMsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHVpbnQgNjRcbiAgICAgICAgICAgICAgICBieXRlcy5wdXNoKDB4Y2YpO1xuICAgICAgICAgICAgICAgIHVpbnQ2NCQxKGJ5dGVzLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBuZWdhdGl2ZSBmaXhudW1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPj0gLTB4MjApIHtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZXMucHVzaCgweGUwIHwgKHZhbHVlICsgMHgyMCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaW50IDhcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPj0gLTB4ODApIHtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZXMucHVzaCgweGQwKTtcbiAgICAgICAgICAgICAgICAgICAgaW50OCQxKGJ5dGVzLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpbnQgMTZcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPj0gLTB4ODAwMCkge1xuICAgICAgICAgICAgICAgICAgICBieXRlcy5wdXNoKDB4ZDEpO1xuICAgICAgICAgICAgICAgICAgICBpbnQxNiQxKGJ5dGVzLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpbnQgMzJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPj0gLTB4ODAwMDAwMDApIHtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZXMucHVzaCgweGQyKTtcbiAgICAgICAgICAgICAgICAgICAgaW50MzIkMShieXRlcywgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gNTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaW50IDY0XG4gICAgICAgICAgICAgICAgYnl0ZXMucHVzaCgweGQzKTtcbiAgICAgICAgICAgICAgICBpbnQ2NCQxKGJ5dGVzLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZW5jb2RlID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgICAgICAgICAgX19wcm90b19fOiBudWxsLFxuICAgICAgICAgICAgdXRmOFdyaXRlOiB1dGY4V3JpdGUsXG4gICAgICAgICAgICBpbnQ4OiBpbnQ4JDEsXG4gICAgICAgICAgICB1aW50ODogdWludDgkMSxcbiAgICAgICAgICAgIGludDE2OiBpbnQxNiQxLFxuICAgICAgICAgICAgdWludDE2OiB1aW50MTYkMSxcbiAgICAgICAgICAgIGludDMyOiBpbnQzMiQxLFxuICAgICAgICAgICAgdWludDMyOiB1aW50MzIkMSxcbiAgICAgICAgICAgIGludDY0OiBpbnQ2NCQxLFxuICAgICAgICAgICAgdWludDY0OiB1aW50NjQkMSxcbiAgICAgICAgICAgIGZsb2F0MzI6IGZsb2F0MzIkMSxcbiAgICAgICAgICAgIGZsb2F0NjQ6IGZsb2F0NjQkMSxcbiAgICAgICAgICAgIHdyaXRlRmxvYXQzMjogd3JpdGVGbG9hdDMyLFxuICAgICAgICAgICAgd3JpdGVGbG9hdDY0OiB3cml0ZUZsb2F0NjQsXG4gICAgICAgICAgICBib29sZWFuOiBib29sZWFuJDEsXG4gICAgICAgICAgICBzdHJpbmc6IHN0cmluZyQxLFxuICAgICAgICAgICAgbnVtYmVyOiBudW1iZXIkMVxuICAgICAgICB9KTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29weXJpZ2h0IChjKSAyMDE4IEVuZGVsIERyZXllclxuICAgICAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMTQgSW9uIERyaXZlIFNvZnR3YXJlIEx0ZC5cbiAgICAgICAgICpcbiAgICAgICAgICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICAgICAgICAgKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gICAgICAgICAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAgICAgICAgICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICAgICAgICAgKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAgICAgICAgICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gICAgICAgICAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAgICAgICAgICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gICAgICAgICAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICAgICAgICAgKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gICAgICAgICAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gICAgICAgICAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gICAgICAgICAqIFNPRlRXQVJFXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiB1dGY4UmVhZChieXRlcywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBzdHJpbmcgPSAnJywgY2hyID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBvZmZzZXQsIGVuZCA9IG9mZnNldCArIGxlbmd0aDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJ5dGUgPSBieXRlc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoKGJ5dGUgJiAweDgwKSA9PT0gMHgwMCkge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgoYnl0ZSAmIDB4ZTApID09PSAweGMwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYnl0ZSAmIDB4MWYpIDw8IDYpIHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChieXRlc1srK2ldICYgMHgzZikpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKChieXRlICYgMHhmMCkgPT09IDB4ZTApIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChieXRlICYgMHgwZikgPDwgMTIpIHxcbiAgICAgICAgICAgICAgICAgICAgICAgICgoYnl0ZXNbKytpXSAmIDB4M2YpIDw8IDYpIHxcbiAgICAgICAgICAgICAgICAgICAgICAgICgoYnl0ZXNbKytpXSAmIDB4M2YpIDw8IDApKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgoYnl0ZSAmIDB4ZjgpID09PSAweGYwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNociA9ICgoYnl0ZSAmIDB4MDcpIDw8IDE4KSB8XG4gICAgICAgICAgICAgICAgICAgICAgICAoKGJ5dGVzWysraV0gJiAweDNmKSA8PCAxMikgfFxuICAgICAgICAgICAgICAgICAgICAgICAgKChieXRlc1srK2ldICYgMHgzZikgPDwgNikgfFxuICAgICAgICAgICAgICAgICAgICAgICAgKChieXRlc1srK2ldICYgMHgzZikgPDwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaHIgPj0gMHgwMTAwMDApIHsgLy8gc3Vycm9nYXRlIHBhaXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNociAtPSAweDAxMDAwMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjaHIgPj4+IDEwKSArIDB4RDgwMCwgKGNociAmIDB4M0ZGKSArIDB4REMwMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaHIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdJbnZhbGlkIGJ5dGUgJyArIGJ5dGUudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgICAgICAgICAvLyAoZG8gbm90IHRocm93IGVycm9yIHRvIGF2b2lkIHNlcnZlci9jbGllbnQgZnJvbSBjcmFzaGluZyBkdWUgdG8gaGFjayBhdHRlbXBzKVxuICAgICAgICAgICAgICAgIC8vIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBieXRlICcgKyBieXRlLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGludDgoYnl0ZXMsIGl0KSB7XG4gICAgICAgICAgICByZXR1cm4gdWludDgoYnl0ZXMsIGl0KSA8PCAyNCA+PiAyNDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB1aW50OChieXRlcywgaXQpIHtcbiAgICAgICAgICAgIHJldHVybiBieXRlc1tpdC5vZmZzZXQrK107XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaW50MTYoYnl0ZXMsIGl0KSB7XG4gICAgICAgICAgICByZXR1cm4gdWludDE2KGJ5dGVzLCBpdCkgPDwgMTYgPj4gMTY7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdWludDE2KGJ5dGVzLCBpdCkge1xuICAgICAgICAgICAgcmV0dXJuIGJ5dGVzW2l0Lm9mZnNldCsrXSB8IGJ5dGVzW2l0Lm9mZnNldCsrXSA8PCA4O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGludDMyKGJ5dGVzLCBpdCkge1xuICAgICAgICAgICAgcmV0dXJuIGJ5dGVzW2l0Lm9mZnNldCsrXSB8IGJ5dGVzW2l0Lm9mZnNldCsrXSA8PCA4IHwgYnl0ZXNbaXQub2Zmc2V0KytdIDw8IDE2IHwgYnl0ZXNbaXQub2Zmc2V0KytdIDw8IDI0O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHVpbnQzMihieXRlcywgaXQpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnQzMihieXRlcywgaXQpID4+PiAwO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGZsb2F0MzIoYnl0ZXMsIGl0KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVhZEZsb2F0MzIoYnl0ZXMsIGl0KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBmbG9hdDY0KGJ5dGVzLCBpdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlYWRGbG9hdDY0KGJ5dGVzLCBpdCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaW50NjQoYnl0ZXMsIGl0KSB7XG4gICAgICAgICAgICB2YXIgbG93ID0gdWludDMyKGJ5dGVzLCBpdCk7XG4gICAgICAgICAgICB2YXIgaGlnaCA9IGludDMyKGJ5dGVzLCBpdCkgKiBNYXRoLnBvdygyLCAzMik7XG4gICAgICAgICAgICByZXR1cm4gaGlnaCArIGxvdztcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB1aW50NjQoYnl0ZXMsIGl0KSB7XG4gICAgICAgICAgICB2YXIgbG93ID0gdWludDMyKGJ5dGVzLCBpdCk7XG4gICAgICAgICAgICB2YXIgaGlnaCA9IHVpbnQzMihieXRlcywgaXQpICogTWF0aC5wb3coMiwgMzIpO1xuICAgICAgICAgICAgcmV0dXJuIGhpZ2ggKyBsb3c7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9pbnQzMiA9IG5ldyBJbnQzMkFycmF5KDIpO1xuICAgICAgICB2YXIgX2Zsb2F0MzIgPSBuZXcgRmxvYXQzMkFycmF5KF9pbnQzMi5idWZmZXIpO1xuICAgICAgICB2YXIgX2Zsb2F0NjQgPSBuZXcgRmxvYXQ2NEFycmF5KF9pbnQzMi5idWZmZXIpO1xuICAgICAgICBmdW5jdGlvbiByZWFkRmxvYXQzMihieXRlcywgaXQpIHtcbiAgICAgICAgICAgIF9pbnQzMlswXSA9IGludDMyKGJ5dGVzLCBpdCk7XG4gICAgICAgICAgICByZXR1cm4gX2Zsb2F0MzJbMF07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmVhZEZsb2F0NjQoYnl0ZXMsIGl0KSB7XG4gICAgICAgICAgICBfaW50MzJbMCBdID0gaW50MzIoYnl0ZXMsIGl0KTtcbiAgICAgICAgICAgIF9pbnQzMlsxIF0gPSBpbnQzMihieXRlcywgaXQpO1xuICAgICAgICAgICAgcmV0dXJuIF9mbG9hdDY0WzBdO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJvb2xlYW4oYnl0ZXMsIGl0KSB7XG4gICAgICAgICAgICByZXR1cm4gdWludDgoYnl0ZXMsIGl0KSA+IDA7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc3RyaW5nKGJ5dGVzLCBpdCkge1xuICAgICAgICAgICAgdmFyIHByZWZpeCA9IGJ5dGVzW2l0Lm9mZnNldCsrXTtcbiAgICAgICAgICAgIHZhciBsZW5ndGg7XG4gICAgICAgICAgICBpZiAocHJlZml4IDwgMHhjMCkge1xuICAgICAgICAgICAgICAgIC8vIGZpeHN0clxuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHByZWZpeCAmIDB4MWY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwcmVmaXggPT09IDB4ZDkpIHtcbiAgICAgICAgICAgICAgICBsZW5ndGggPSB1aW50OChieXRlcywgaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJlZml4ID09PSAweGRhKSB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gdWludDE2KGJ5dGVzLCBpdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwcmVmaXggPT09IDB4ZGIpIHtcbiAgICAgICAgICAgICAgICBsZW5ndGggPSB1aW50MzIoYnl0ZXMsIGl0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHV0ZjhSZWFkKGJ5dGVzLCBpdC5vZmZzZXQsIGxlbmd0aCk7XG4gICAgICAgICAgICBpdC5vZmZzZXQgKz0gbGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHN0cmluZ0NoZWNrKGJ5dGVzLCBpdCkge1xuICAgICAgICAgICAgdmFyIHByZWZpeCA9IGJ5dGVzW2l0Lm9mZnNldF07XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgLy8gZml4c3RyXG4gICAgICAgICAgICAocHJlZml4IDwgMHhjMCAmJiBwcmVmaXggPiAweGEwKSB8fFxuICAgICAgICAgICAgICAgIC8vIHN0ciA4XG4gICAgICAgICAgICAgICAgcHJlZml4ID09PSAweGQ5IHx8XG4gICAgICAgICAgICAgICAgLy8gc3RyIDE2XG4gICAgICAgICAgICAgICAgcHJlZml4ID09PSAweGRhIHx8XG4gICAgICAgICAgICAgICAgLy8gc3RyIDMyXG4gICAgICAgICAgICAgICAgcHJlZml4ID09PSAweGRiKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBudW1iZXIoYnl0ZXMsIGl0KSB7XG4gICAgICAgICAgICB2YXIgcHJlZml4ID0gYnl0ZXNbaXQub2Zmc2V0KytdO1xuICAgICAgICAgICAgaWYgKHByZWZpeCA8IDB4ODApIHtcbiAgICAgICAgICAgICAgICAvLyBwb3NpdGl2ZSBmaXhpbnRcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJlZml4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJlZml4ID09PSAweGNhKSB7XG4gICAgICAgICAgICAgICAgLy8gZmxvYXQgMzJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVhZEZsb2F0MzIoYnl0ZXMsIGl0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByZWZpeCA9PT0gMHhjYikge1xuICAgICAgICAgICAgICAgIC8vIGZsb2F0IDY0XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRGbG9hdDY0KGJ5dGVzLCBpdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwcmVmaXggPT09IDB4Y2MpIHtcbiAgICAgICAgICAgICAgICAvLyB1aW50IDhcbiAgICAgICAgICAgICAgICByZXR1cm4gdWludDgoYnl0ZXMsIGl0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByZWZpeCA9PT0gMHhjZCkge1xuICAgICAgICAgICAgICAgIC8vIHVpbnQgMTZcbiAgICAgICAgICAgICAgICByZXR1cm4gdWludDE2KGJ5dGVzLCBpdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwcmVmaXggPT09IDB4Y2UpIHtcbiAgICAgICAgICAgICAgICAvLyB1aW50IDMyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVpbnQzMihieXRlcywgaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJlZml4ID09PSAweGNmKSB7XG4gICAgICAgICAgICAgICAgLy8gdWludCA2NFxuICAgICAgICAgICAgICAgIHJldHVybiB1aW50NjQoYnl0ZXMsIGl0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByZWZpeCA9PT0gMHhkMCkge1xuICAgICAgICAgICAgICAgIC8vIGludCA4XG4gICAgICAgICAgICAgICAgcmV0dXJuIGludDgoYnl0ZXMsIGl0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByZWZpeCA9PT0gMHhkMSkge1xuICAgICAgICAgICAgICAgIC8vIGludCAxNlxuICAgICAgICAgICAgICAgIHJldHVybiBpbnQxNihieXRlcywgaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJlZml4ID09PSAweGQyKSB7XG4gICAgICAgICAgICAgICAgLy8gaW50IDMyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGludDMyKGJ5dGVzLCBpdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwcmVmaXggPT09IDB4ZDMpIHtcbiAgICAgICAgICAgICAgICAvLyBpbnQgNjRcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50NjQoYnl0ZXMsIGl0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByZWZpeCA+IDB4ZGYpIHtcbiAgICAgICAgICAgICAgICAvLyBuZWdhdGl2ZSBmaXhpbnRcbiAgICAgICAgICAgICAgICByZXR1cm4gKDB4ZmYgLSBwcmVmaXggKyAxKSAqIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG51bWJlckNoZWNrKGJ5dGVzLCBpdCkge1xuICAgICAgICAgICAgdmFyIHByZWZpeCA9IGJ5dGVzW2l0Lm9mZnNldF07XG4gICAgICAgICAgICAvLyBwb3NpdGl2ZSBmaXhpbnQgLSAweDAwIC0gMHg3ZlxuICAgICAgICAgICAgLy8gZmxvYXQgMzIgICAgICAgIC0gMHhjYVxuICAgICAgICAgICAgLy8gZmxvYXQgNjQgICAgICAgIC0gMHhjYlxuICAgICAgICAgICAgLy8gdWludCA4ICAgICAgICAgIC0gMHhjY1xuICAgICAgICAgICAgLy8gdWludCAxNiAgICAgICAgIC0gMHhjZFxuICAgICAgICAgICAgLy8gdWludCAzMiAgICAgICAgIC0gMHhjZVxuICAgICAgICAgICAgLy8gdWludCA2NCAgICAgICAgIC0gMHhjZlxuICAgICAgICAgICAgLy8gaW50IDggICAgICAgICAgIC0gMHhkMFxuICAgICAgICAgICAgLy8gaW50IDE2ICAgICAgICAgIC0gMHhkMVxuICAgICAgICAgICAgLy8gaW50IDMyICAgICAgICAgIC0gMHhkMlxuICAgICAgICAgICAgLy8gaW50IDY0ICAgICAgICAgIC0gMHhkM1xuICAgICAgICAgICAgcmV0dXJuIChwcmVmaXggPCAweDgwIHx8XG4gICAgICAgICAgICAgICAgKHByZWZpeCA+PSAweGNhICYmIHByZWZpeCA8PSAweGQzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYXJyYXlDaGVjayhieXRlcywgaXQpIHtcbiAgICAgICAgICAgIHJldHVybiBieXRlc1tpdC5vZmZzZXRdIDwgMHhhMDtcbiAgICAgICAgICAgIC8vIGNvbnN0IHByZWZpeCA9IGJ5dGVzW2l0Lm9mZnNldF0gO1xuICAgICAgICAgICAgLy8gaWYgKHByZWZpeCA8IDB4YTApIHtcbiAgICAgICAgICAgIC8vICAgcmV0dXJuIHByZWZpeDtcbiAgICAgICAgICAgIC8vIC8vIGFycmF5XG4gICAgICAgICAgICAvLyB9IGVsc2UgaWYgKHByZWZpeCA9PT0gMHhkYykge1xuICAgICAgICAgICAgLy8gICBpdC5vZmZzZXQgKz0gMjtcbiAgICAgICAgICAgIC8vIH0gZWxzZSBpZiAoMHhkZCkge1xuICAgICAgICAgICAgLy8gICBpdC5vZmZzZXQgKz0gNDtcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIC8vIHJldHVybiBwcmVmaXg7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc3dpdGNoU3RydWN0dXJlQ2hlY2soYnl0ZXMsIGl0KSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgLy8gcHJldmlvdXMgYnl0ZSBzaG91bGQgYmUgYFNXSVRDSF9UT19TVFJVQ1RVUkVgXG4gICAgICAgICAgICBieXRlc1tpdC5vZmZzZXQgLSAxXSA9PT0gU1dJVENIX1RPX1NUUlVDVFVSRSAmJlxuICAgICAgICAgICAgICAgIC8vIG5leHQgYnl0ZSBzaG91bGQgYmUgYSBudW1iZXJcbiAgICAgICAgICAgICAgICAoYnl0ZXNbaXQub2Zmc2V0XSA8IDB4ODAgfHwgKGJ5dGVzW2l0Lm9mZnNldF0gPj0gMHhjYSAmJiBieXRlc1tpdC5vZmZzZXRdIDw9IDB4ZDMpKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGVjb2RlID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgICAgICAgICAgX19wcm90b19fOiBudWxsLFxuICAgICAgICAgICAgaW50ODogaW50OCxcbiAgICAgICAgICAgIHVpbnQ4OiB1aW50OCxcbiAgICAgICAgICAgIGludDE2OiBpbnQxNixcbiAgICAgICAgICAgIHVpbnQxNjogdWludDE2LFxuICAgICAgICAgICAgaW50MzI6IGludDMyLFxuICAgICAgICAgICAgdWludDMyOiB1aW50MzIsXG4gICAgICAgICAgICBmbG9hdDMyOiBmbG9hdDMyLFxuICAgICAgICAgICAgZmxvYXQ2NDogZmxvYXQ2NCxcbiAgICAgICAgICAgIGludDY0OiBpbnQ2NCxcbiAgICAgICAgICAgIHVpbnQ2NDogdWludDY0LFxuICAgICAgICAgICAgcmVhZEZsb2F0MzI6IHJlYWRGbG9hdDMyLFxuICAgICAgICAgICAgcmVhZEZsb2F0NjQ6IHJlYWRGbG9hdDY0LFxuICAgICAgICAgICAgYm9vbGVhbjogYm9vbGVhbixcbiAgICAgICAgICAgIHN0cmluZzogc3RyaW5nLFxuICAgICAgICAgICAgc3RyaW5nQ2hlY2s6IHN0cmluZ0NoZWNrLFxuICAgICAgICAgICAgbnVtYmVyOiBudW1iZXIsXG4gICAgICAgICAgICBudW1iZXJDaGVjazogbnVtYmVyQ2hlY2ssXG4gICAgICAgICAgICBhcnJheUNoZWNrOiBhcnJheUNoZWNrLFxuICAgICAgICAgICAgc3dpdGNoU3RydWN0dXJlQ2hlY2s6IHN3aXRjaFN0cnVjdHVyZUNoZWNrXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBDb2xsZWN0aW9uU2NoZW1hID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gQ29sbGVjdGlvblNjaGVtYShpbml0aWFsVmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICB0aGlzLiRjaGFuZ2VzID0gbmV3IENoYW5nZVRyZWUodGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy4kaXRlbXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgICAgdGhpcy4kaW5kZXhlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRyZWZJZCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKGluaXRpYWxWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbFZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7IHJldHVybiBfdGhpcy5hZGQodik7IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIENvbGxlY3Rpb25TY2hlbWEucHJvdG90eXBlLm9uQWRkID0gZnVuY3Rpb24gKGNhbGxiYWNrLCB0cmlnZ2VyQWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRyaWdnZXJBbGwgPT09IHZvaWQgMCkgeyB0cmlnZ2VyQWxsID0gdHJ1ZTsgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhZGRDYWxsYmFjaygodGhpcy4kY2FsbGJhY2tzIHx8ICh0aGlzLiRjYWxsYmFja3MgPSBbXSkpLCBleHBvcnRzLk9QRVJBVElPTi5BREQsIGNhbGxiYWNrLCAodHJpZ2dlckFsbClcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLiRpdGVtc1xuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgQ29sbGVjdGlvblNjaGVtYS5wcm90b3R5cGUub25SZW1vdmUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHsgcmV0dXJuIGFkZENhbGxiYWNrKHRoaXMuJGNhbGxiYWNrcyB8fCAodGhpcy4kY2FsbGJhY2tzID0gW10pLCBleHBvcnRzLk9QRVJBVElPTi5ERUxFVEUsIGNhbGxiYWNrKTsgfTtcbiAgICAgICAgICAgIENvbGxlY3Rpb25TY2hlbWEucHJvdG90eXBlLm9uQ2hhbmdlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7IHJldHVybiBhZGRDYWxsYmFjayh0aGlzLiRjYWxsYmFja3MgfHwgKHRoaXMuJGNhbGxiYWNrcyA9IFtdKSwgZXhwb3J0cy5PUEVSQVRJT04uUkVQTEFDRSwgY2FsbGJhY2spOyB9O1xuICAgICAgICAgICAgQ29sbGVjdGlvblNjaGVtYS5pcyA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVbJ2NvbGxlY3Rpb24nXSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIENvbGxlY3Rpb25TY2hlbWEucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIC8vIHNldCBcImluZGV4XCIgZm9yIHJlZmVyZW5jZS5cbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLiRyZWZJZCsrO1xuICAgICAgICAgICAgICAgIHZhciBpc1JlZiA9ICh2YWx1ZVsnJGNoYW5nZXMnXSkgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBpZiAoaXNSZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVbJyRjaGFuZ2VzJ10uc2V0UGFyZW50KHRoaXMsIHRoaXMuJGNoYW5nZXMucm9vdCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLiRjaGFuZ2VzLmluZGV4ZXNbaW5kZXhdID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgdGhpcy4kaW5kZXhlcy5zZXQoaW5kZXgsIGluZGV4KTtcbiAgICAgICAgICAgICAgICB0aGlzLiRpdGVtcy5zZXQoaW5kZXgsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRjaGFuZ2VzLmNoYW5nZShpbmRleCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIENvbGxlY3Rpb25TY2hlbWEucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IEFycmF5LmZyb20odGhpcy4kaXRlbXMua2V5cygpKVtpbmRleF07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGl0ZW1zLmdldChrZXkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIENvbGxlY3Rpb25TY2hlbWEucHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGl0ZW1zLmVudHJpZXMoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBDb2xsZWN0aW9uU2NoZW1hLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIHZhciBlbnRyaWVzID0gdGhpcy4kaXRlbXMuZW50cmllcygpO1xuICAgICAgICAgICAgICAgIHZhciBpbmRleDtcbiAgICAgICAgICAgICAgICB2YXIgZW50cnk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGVudHJ5ID0gZW50cmllcy5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5LmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtID09PSBlbnRyeS52YWx1ZVsxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBlbnRyeS52YWx1ZVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy4kY2hhbmdlcy5kZWxldGUoaW5kZXgpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGluZGV4ZXMuZGVsZXRlKGluZGV4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kaXRlbXMuZGVsZXRlKGluZGV4KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBDb2xsZWN0aW9uU2NoZW1hLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgLy8gZGlzY2FyZCBwcmV2aW91cyBvcGVyYXRpb25zLlxuICAgICAgICAgICAgICAgIHRoaXMuJGNoYW5nZXMuZGlzY2FyZCh0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRjaGFuZ2VzLmluZGV4ZXMgPSB7fTtcbiAgICAgICAgICAgICAgICAvLyBjbGVhciBwcmV2aW91cyBpbmRleGVzXG4gICAgICAgICAgICAgICAgdGhpcy4kaW5kZXhlcy5jbGVhcigpO1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gV2hlbiBkZWNvZGluZzpcbiAgICAgICAgICAgICAgICAvLyAtIGVucXVldWUgaXRlbXMgZm9yIERFTEVURSBjYWxsYmFjay5cbiAgICAgICAgICAgICAgICAvLyAtIGZsYWcgY2hpbGQgaXRlbXMgZm9yIGdhcmJhZ2UgY29sbGVjdGlvbi5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUNoaWxkUmVmcy5jYWxsKHRoaXMsIGNoYW5nZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBjbGVhciBpdGVtc1xuICAgICAgICAgICAgICAgIHRoaXMuJGl0ZW1zLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy4kY2hhbmdlcy5vcGVyYXRpb24oeyBpbmRleDogMCwgb3A6IGV4cG9ydHMuT1BFUkFUSU9OLkNMRUFSIH0pO1xuICAgICAgICAgICAgICAgIC8vIHRvdWNoIGFsbCBzdHJ1Y3R1cmVzIHVudGlsIHJlYWNoIHJvb3RcbiAgICAgICAgICAgICAgICB0aGlzLiRjaGFuZ2VzLnRvdWNoUGFyZW50cygpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIENvbGxlY3Rpb25TY2hlbWEucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuJGl0ZW1zLnZhbHVlcygpKS5zb21lKGZ1bmN0aW9uICh2KSB7IHJldHVybiB2ID09PSB2YWx1ZTsgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgQ29sbGVjdGlvblNjaGVtYS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFja2ZuKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICB0aGlzLiRpdGVtcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5LCBfKSB7IHJldHVybiBjYWxsYmFja2ZuKHZhbHVlLCBrZXksIF90aGlzKTsgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgQ29sbGVjdGlvblNjaGVtYS5wcm90b3R5cGUudmFsdWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRpdGVtcy52YWx1ZXMoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29sbGVjdGlvblNjaGVtYS5wcm90b3R5cGUsIFwic2l6ZVwiLCB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRpdGVtcy5zaXplO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIENvbGxlY3Rpb25TY2hlbWEucHJvdG90eXBlLnNldEluZGV4ID0gZnVuY3Rpb24gKGluZGV4LCBrZXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRpbmRleGVzLnNldChpbmRleCwga2V5KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBDb2xsZWN0aW9uU2NoZW1hLnByb3RvdHlwZS5nZXRJbmRleCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRpbmRleGVzLmdldChpbmRleCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgQ29sbGVjdGlvblNjaGVtYS5wcm90b3R5cGUuZ2V0QnlJbmRleCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRpdGVtcy5nZXQodGhpcy4kaW5kZXhlcy5nZXQoaW5kZXgpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBDb2xsZWN0aW9uU2NoZW1hLnByb3RvdHlwZS5kZWxldGVCeUluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IHRoaXMuJGluZGV4ZXMuZ2V0KGluZGV4KTtcbiAgICAgICAgICAgICAgICB0aGlzLiRpdGVtcy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICB0aGlzLiRpbmRleGVzLmRlbGV0ZShpbmRleCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgQ29sbGVjdGlvblNjaGVtYS5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLiRpdGVtcy52YWx1ZXMoKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgQ29sbGVjdGlvblNjaGVtYS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2goKHR5cGVvZiAodmFsdWVbJ3RvSlNPTiddKSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyB2YWx1ZVsndG9KU09OJ10oKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gRGVjb2RpbmcgdXRpbGl0aWVzXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgQ29sbGVjdGlvblNjaGVtYS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoaXNEZWNvZGluZykge1xuICAgICAgICAgICAgICAgIHZhciBjbG9uZWQ7XG4gICAgICAgICAgICAgICAgaWYgKGlzRGVjb2RpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2xpZW50LXNpZGVcbiAgICAgICAgICAgICAgICAgICAgY2xvbmVkID0gT2JqZWN0LmFzc2lnbihuZXcgQ29sbGVjdGlvblNjaGVtYSgpLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNlcnZlci1zaWRlXG4gICAgICAgICAgICAgICAgICAgIGNsb25lZCA9IG5ldyBDb2xsZWN0aW9uU2NoZW1hKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZVsnJGNoYW5nZXMnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lZC5hZGQodmFsdWVbJ2Nsb25lJ10oKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9uZWQuYWRkKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjbG9uZWQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIENvbGxlY3Rpb25TY2hlbWE7XG4gICAgICAgIH0oKSk7XG5cbiAgICAgICAgdmFyIFNldFNjaGVtYSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIFNldFNjaGVtYShpbml0aWFsVmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICB0aGlzLiRjaGFuZ2VzID0gbmV3IENoYW5nZVRyZWUodGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy4kaXRlbXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgICAgdGhpcy4kaW5kZXhlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRyZWZJZCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKGluaXRpYWxWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbFZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7IHJldHVybiBfdGhpcy5hZGQodik7IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFNldFNjaGVtYS5wcm90b3R5cGUub25BZGQgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIHRyaWdnZXJBbGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodHJpZ2dlckFsbCA9PT0gdm9pZCAwKSB7IHRyaWdnZXJBbGwgPSB0cnVlOyB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFkZENhbGxiYWNrKCh0aGlzLiRjYWxsYmFja3MgfHwgKHRoaXMuJGNhbGxiYWNrcyA9IFtdKSksIGV4cG9ydHMuT1BFUkFUSU9OLkFERCwgY2FsbGJhY2ssICh0cmlnZ2VyQWxsKVxuICAgICAgICAgICAgICAgICAgICA/IHRoaXMuJGl0ZW1zXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBTZXRTY2hlbWEucHJvdG90eXBlLm9uUmVtb3ZlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7IHJldHVybiBhZGRDYWxsYmFjayh0aGlzLiRjYWxsYmFja3MgfHwgKHRoaXMuJGNhbGxiYWNrcyA9IFtdKSwgZXhwb3J0cy5PUEVSQVRJT04uREVMRVRFLCBjYWxsYmFjayk7IH07XG4gICAgICAgICAgICBTZXRTY2hlbWEucHJvdG90eXBlLm9uQ2hhbmdlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7IHJldHVybiBhZGRDYWxsYmFjayh0aGlzLiRjYWxsYmFja3MgfHwgKHRoaXMuJGNhbGxiYWNrcyA9IFtdKSwgZXhwb3J0cy5PUEVSQVRJT04uUkVQTEFDRSwgY2FsbGJhY2spOyB9O1xuICAgICAgICAgICAgU2V0U2NoZW1hLmlzID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZVsnc2V0J10gIT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBTZXRTY2hlbWEucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgLy8gaW1tZWRpYXRlbGx5IHJldHVybiBmYWxzZSBpZiB2YWx1ZSBhbHJlYWR5IGFkZGVkLlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBzZXQgXCJpbmRleFwiIGZvciByZWZlcmVuY2UuXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy4kcmVmSWQrKztcbiAgICAgICAgICAgICAgICBpZiAoKHZhbHVlWyckY2hhbmdlcyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlWyckY2hhbmdlcyddLnNldFBhcmVudCh0aGlzLCB0aGlzLiRjaGFuZ2VzLnJvb3QsIGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIG9wZXJhdGlvbiA9IChfYiA9IChfYSA9IHRoaXMuJGNoYW5nZXMuaW5kZXhlc1tpbmRleF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZXhwb3J0cy5PUEVSQVRJT04uQUREO1xuICAgICAgICAgICAgICAgIHRoaXMuJGNoYW5nZXMuaW5kZXhlc1tpbmRleF0gPSBpbmRleDtcbiAgICAgICAgICAgICAgICB0aGlzLiRpbmRleGVzLnNldChpbmRleCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGl0ZW1zLnNldChpbmRleCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGNoYW5nZXMuY2hhbmdlKGluZGV4LCBvcGVyYXRpb24pO1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBTZXRTY2hlbWEucHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGl0ZW1zLmVudHJpZXMoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBTZXRTY2hlbWEucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVudHJpZXMgPSB0aGlzLiRpdGVtcy5lbnRyaWVzKCk7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4O1xuICAgICAgICAgICAgICAgIHZhciBlbnRyeTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoZW50cnkgPSBlbnRyaWVzLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW50cnkuZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0gPT09IGVudHJ5LnZhbHVlWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGVudHJ5LnZhbHVlWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLiRjaGFuZ2VzLmRlbGV0ZShpbmRleCk7XG4gICAgICAgICAgICAgICAgdGhpcy4kaW5kZXhlcy5kZWxldGUoaW5kZXgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRpdGVtcy5kZWxldGUoaW5kZXgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFNldFNjaGVtYS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICAgICAgICAgIC8vIGRpc2NhcmQgcHJldmlvdXMgb3BlcmF0aW9ucy5cbiAgICAgICAgICAgICAgICB0aGlzLiRjaGFuZ2VzLmRpc2NhcmQodHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy4kY2hhbmdlcy5pbmRleGVzID0ge307XG4gICAgICAgICAgICAgICAgLy8gY2xlYXIgcHJldmlvdXMgaW5kZXhlc1xuICAgICAgICAgICAgICAgIHRoaXMuJGluZGV4ZXMuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gZGVjb2Rpbmc6XG4gICAgICAgICAgICAgICAgLy8gLSBlbnF1ZXVlIGl0ZW1zIGZvciBERUxFVEUgY2FsbGJhY2suXG4gICAgICAgICAgICAgICAgLy8gLSBmbGFnIGNoaWxkIGl0ZW1zIGZvciBnYXJiYWdlIGNvbGxlY3Rpb24uXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlcykge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVDaGlsZFJlZnMuY2FsbCh0aGlzLCBjaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gY2xlYXIgaXRlbXNcbiAgICAgICAgICAgICAgICB0aGlzLiRpdGVtcy5jbGVhcigpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGNoYW5nZXMub3BlcmF0aW9uKHsgaW5kZXg6IDAsIG9wOiBleHBvcnRzLk9QRVJBVElPTi5DTEVBUiB9KTtcbiAgICAgICAgICAgICAgICAvLyB0b3VjaCBhbGwgc3RydWN0dXJlcyB1bnRpbCByZWFjaCByb290XG4gICAgICAgICAgICAgICAgdGhpcy4kY2hhbmdlcy50b3VjaFBhcmVudHMoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBTZXRTY2hlbWEucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZXMgPSB0aGlzLiRpdGVtcy52YWx1ZXMoKTtcbiAgICAgICAgICAgICAgICB2YXIgaGFzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdmFyIGVudHJ5O1xuICAgICAgICAgICAgICAgIHdoaWxlIChlbnRyeSA9IHZhbHVlcy5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5LmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gZW50cnkudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaGFzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFNldFNjaGVtYS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFja2ZuKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICB0aGlzLiRpdGVtcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5LCBfKSB7IHJldHVybiBjYWxsYmFja2ZuKHZhbHVlLCBrZXksIF90aGlzKTsgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgU2V0U2NoZW1hLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGl0ZW1zLnZhbHVlcygpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZXRTY2hlbWEucHJvdG90eXBlLCBcInNpemVcIiwge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kaXRlbXMuc2l6ZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBTZXRTY2hlbWEucHJvdG90eXBlLnNldEluZGV4ID0gZnVuY3Rpb24gKGluZGV4LCBrZXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRpbmRleGVzLnNldChpbmRleCwga2V5KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBTZXRTY2hlbWEucHJvdG90eXBlLmdldEluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGluZGV4ZXMuZ2V0KGluZGV4KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBTZXRTY2hlbWEucHJvdG90eXBlLmdldEJ5SW5kZXggPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kaXRlbXMuZ2V0KHRoaXMuJGluZGV4ZXMuZ2V0KGluZGV4KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgU2V0U2NoZW1hLnByb3RvdHlwZS5kZWxldGVCeUluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IHRoaXMuJGluZGV4ZXMuZ2V0KGluZGV4KTtcbiAgICAgICAgICAgICAgICB0aGlzLiRpdGVtcy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICB0aGlzLiRpbmRleGVzLmRlbGV0ZShpbmRleCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgU2V0U2NoZW1hLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuJGl0ZW1zLnZhbHVlcygpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBTZXRTY2hlbWEucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKCh0eXBlb2YgKHZhbHVlWyd0b0pTT04nXSkgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdmFsdWVbJ3RvSlNPTiddKClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdmFsdWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIERlY29kaW5nIHV0aWxpdGllc1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIFNldFNjaGVtYS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoaXNEZWNvZGluZykge1xuICAgICAgICAgICAgICAgIHZhciBjbG9uZWQ7XG4gICAgICAgICAgICAgICAgaWYgKGlzRGVjb2RpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2xpZW50LXNpZGVcbiAgICAgICAgICAgICAgICAgICAgY2xvbmVkID0gT2JqZWN0LmFzc2lnbihuZXcgU2V0U2NoZW1hKCksIHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2VydmVyLXNpZGVcbiAgICAgICAgICAgICAgICAgICAgY2xvbmVkID0gbmV3IFNldFNjaGVtYSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVbJyRjaGFuZ2VzJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9uZWQuYWRkKHZhbHVlWydjbG9uZSddKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmVkLmFkZCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY2xvbmVkO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBTZXRTY2hlbWE7XG4gICAgICAgIH0oKSk7XG5cbiAgICAgICAgdmFyIENsaWVudFN0YXRlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gQ2xpZW50U3RhdGUoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZJZHMgPSBuZXcgV2Vha1NldCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVySW5kZXhlcyA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjb250YWluZXJJbmRleGVzID0gbmV3IE1hcDxDaGFuZ2VUcmVlLCBTZXQ8bnVtYmVyPj4oKTtcbiAgICAgICAgICAgIENsaWVudFN0YXRlLnByb3RvdHlwZS5hZGRSZWZJZCA9IGZ1bmN0aW9uIChjaGFuZ2VUcmVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnJlZklkcy5oYXMoY2hhbmdlVHJlZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWZJZHMuYWRkKGNoYW5nZVRyZWUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lckluZGV4ZXMuc2V0KGNoYW5nZVRyZWUsIG5ldyBTZXQoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIENsaWVudFN0YXRlLmdldCA9IGZ1bmN0aW9uIChjbGllbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2xpZW50LiRmaWx0ZXJTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsaWVudC4kZmlsdGVyU3RhdGUgPSBuZXcgQ2xpZW50U3RhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsaWVudC4kZmlsdGVyU3RhdGU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIENsaWVudFN0YXRlO1xuICAgICAgICB9KCkpO1xuXG4gICAgICAgIHZhciBSZWZlcmVuY2VUcmFja2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gUmVmZXJlbmNlVHJhY2tlcigpIHtcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIFJlbGF0aW9uIG9mIHJlZklkID0+IFNjaGVtYSBzdHJ1Y3R1cmVcbiAgICAgICAgICAgICAgICAvLyBGb3IgZGlyZWN0IGFjY2VzcyBvZiBzdHJ1Y3R1cmVzIGR1cmluZyBkZWNvZGluZyB0aW1lLlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgdGhpcy5yZWZzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVmQ291bnRzID0ge307XG4gICAgICAgICAgICAgICAgdGhpcy5kZWxldGVkUmVmcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRVbmlxdWVJZCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSZWZlcmVuY2VUcmFja2VyLnByb3RvdHlwZS5nZXROZXh0VW5pcXVlSWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV4dFVuaXF1ZUlkKys7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gZm9yIGRlY29kaW5nXG4gICAgICAgICAgICBSZWZlcmVuY2VUcmFja2VyLnByb3RvdHlwZS5hZGRSZWYgPSBmdW5jdGlvbiAocmVmSWQsIHJlZiwgaW5jcmVtZW50Q291bnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5jcmVtZW50Q291bnQgPT09IHZvaWQgMCkgeyBpbmNyZW1lbnRDb3VudCA9IHRydWU7IH1cbiAgICAgICAgICAgICAgICB0aGlzLnJlZnMuc2V0KHJlZklkLCByZWYpO1xuICAgICAgICAgICAgICAgIGlmIChpbmNyZW1lbnRDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZkNvdW50c1tyZWZJZF0gPSAodGhpcy5yZWZDb3VudHNbcmVmSWRdIHx8IDApICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gZm9yIGRlY29kaW5nXG4gICAgICAgICAgICBSZWZlcmVuY2VUcmFja2VyLnByb3RvdHlwZS5yZW1vdmVSZWYgPSBmdW5jdGlvbiAocmVmSWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZkNvdW50c1tyZWZJZF0gPSB0aGlzLnJlZkNvdW50c1tyZWZJZF0gLSAxO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVsZXRlZFJlZnMuYWRkKHJlZklkKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBSZWZlcmVuY2VUcmFja2VyLnByb3RvdHlwZS5jbGVhclJlZnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZzLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWxldGVkUmVmcy5jbGVhcigpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVmQ291bnRzID0ge307XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gZm9yIGRlY29kaW5nXG4gICAgICAgICAgICBSZWZlcmVuY2VUcmFja2VyLnByb3RvdHlwZS5nYXJiYWdlQ29sbGVjdERlbGV0ZWRSZWZzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWxldGVkUmVmcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWZJZCkge1xuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIGFjdGl2ZSByZWZlcmVuY2VzLlxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMucmVmQ291bnRzW3JlZklkXSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVmID0gX3RoaXMucmVmcy5nZXQocmVmSWQpO1xuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBFbnN1cmUgY2hpbGQgc2NoZW1hIGluc3RhbmNlcyBoYXZlIHRoZWlyIHJlZmVyZW5jZXMgcmVtb3ZlZCBhcyB3ZWxsLlxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVmIGluc3RhbmNlb2YgU2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBmaWVsZE5hbWUgaW4gcmVmWydfZGVmaW5pdGlvbiddLnNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHJlZlsnX2RlZmluaXRpb24nXS5zY2hlbWFbZmllbGROYW1lXSkgIT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmW2ZpZWxkTmFtZV0gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmW2ZpZWxkTmFtZV1bJyRjaGFuZ2VzJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVtb3ZlUmVmKHJlZltmaWVsZE5hbWVdWyckY2hhbmdlcyddLnJlZklkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVmaW5pdGlvbiA9IHJlZlsnJGNoYW5nZXMnXS5wYXJlbnQuX2RlZmluaXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IGRlZmluaXRpb24uc2NoZW1hW2RlZmluaXRpb24uZmllbGRzQnlJbmRleFtyZWZbJyRjaGFuZ2VzJ10ucGFyZW50SW5kZXhdXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKE9iamVjdC52YWx1ZXModHlwZSlbMF0pID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBBcnJheS5mcm9tKHJlZi52YWx1ZXMoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiBfdGhpcy5yZW1vdmVSZWYoY2hpbGRbJyRjaGFuZ2VzJ10ucmVmSWQpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZWZzLmRlbGV0ZShyZWZJZCk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBfdGhpcy5yZWZDb3VudHNbcmVmSWRdO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIGNsZWFyIGRlbGV0ZWQgcmVmcy5cbiAgICAgICAgICAgICAgICB0aGlzLmRlbGV0ZWRSZWZzLmNsZWFyKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIFJlZmVyZW5jZVRyYWNrZXI7XG4gICAgICAgIH0oKSk7XG5cbiAgICAgICAgdmFyIEVuY29kZVNjaGVtYUVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICAgICAgX19leHRlbmRzKEVuY29kZVNjaGVtYUVycm9yLCBfc3VwZXIpO1xuICAgICAgICAgICAgZnVuY3Rpb24gRW5jb2RlU2NoZW1hRXJyb3IoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEVuY29kZVNjaGVtYUVycm9yO1xuICAgICAgICB9KEVycm9yKSk7XG4gICAgICAgIGZ1bmN0aW9uIGFzc2VydFR5cGUodmFsdWUsIHR5cGUsIGtsYXNzLCBmaWVsZCkge1xuICAgICAgICAgICAgdmFyIHR5cGVvZlRhcmdldDtcbiAgICAgICAgICAgIHZhciBhbGxvd051bGwgPSBmYWxzZTtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiaW50OFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJ1aW50OFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJpbnQxNlwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJ1aW50MTZcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiaW50MzJcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwidWludDMyXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcImludDY0XCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInVpbnQ2NFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJmbG9hdDMyXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcImZsb2F0NjRcIjpcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mVGFyZ2V0ID0gXCJudW1iZXJcIjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJ0cnlpbmcgdG8gZW5jb2RlIFxcXCJOYU5cXFwiIGluIFwiLmNvbmNhdChrbGFzcy5jb25zdHJ1Y3Rvci5uYW1lLCBcIiNcIikuY29uY2F0KGZpZWxkKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2ZUYXJnZXQgPSBcInN0cmluZ1wiO1xuICAgICAgICAgICAgICAgICAgICBhbGxvd051bGwgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgICAgICAgICAgICAvLyBib29sZWFuIGlzIGFsd2F5cyBlbmNvZGVkIGFzIHRydWUvZmFsc2UgYmFzZWQgb24gdHJ1dGhpbmVzc1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgIT09IHR5cGVvZlRhcmdldCAmJiAoIWFsbG93TnVsbCB8fCAoYWxsb3dOdWxsICYmIHZhbHVlICE9PSBudWxsKSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZm91bmRWYWx1ZSA9IFwiJ1wiLmNvbmNhdChKU09OLnN0cmluZ2lmeSh2YWx1ZSksIFwiJ1wiKS5jb25jYXQoKHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yICYmIFwiIChcIi5jb25jYXQodmFsdWUuY29uc3RydWN0b3IubmFtZSwgXCIpXCIpKSB8fCAnJyk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVuY29kZVNjaGVtYUVycm9yKFwiYSAnXCIuY29uY2F0KHR5cGVvZlRhcmdldCwgXCInIHdhcyBleHBlY3RlZCwgYnV0IFwiKS5jb25jYXQoZm91bmRWYWx1ZSwgXCIgd2FzIHByb3ZpZGVkIGluIFwiKS5jb25jYXQoa2xhc3MuY29uc3RydWN0b3IubmFtZSwgXCIjXCIpLmNvbmNhdChmaWVsZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFzc2VydEluc3RhbmNlVHlwZSh2YWx1ZSwgdHlwZSwga2xhc3MsIGZpZWxkKSB7XG4gICAgICAgICAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVuY29kZVNjaGVtYUVycm9yKFwiYSAnXCIuY29uY2F0KHR5cGUubmFtZSwgXCInIHdhcyBleHBlY3RlZCwgYnV0ICdcIikuY29uY2F0KHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUsIFwiJyB3YXMgcHJvdmlkZWQgaW4gXCIpLmNvbmNhdChrbGFzcy5jb25zdHJ1Y3Rvci5uYW1lLCBcIiNcIikuY29uY2F0KGZpZWxkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZW5jb2RlUHJpbWl0aXZlVHlwZSh0eXBlLCBieXRlcywgdmFsdWUsIGtsYXNzLCBmaWVsZCkge1xuICAgICAgICAgICAgYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZSwga2xhc3MsIGZpZWxkKTtcbiAgICAgICAgICAgIHZhciBlbmNvZGVGdW5jID0gZW5jb2RlW3R5cGVdO1xuICAgICAgICAgICAgaWYgKGVuY29kZUZ1bmMpIHtcbiAgICAgICAgICAgICAgICBlbmNvZGVGdW5jKGJ5dGVzLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRW5jb2RlU2NoZW1hRXJyb3IoXCJhICdcIi5jb25jYXQodHlwZSwgXCInIHdhcyBleHBlY3RlZCwgYnV0IFwiKS5jb25jYXQodmFsdWUsIFwiIHdhcyBwcm92aWRlZCBpbiBcIikuY29uY2F0KGtsYXNzLmNvbnN0cnVjdG9yLm5hbWUsIFwiI1wiKS5jb25jYXQoZmllbGQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBkZWNvZGVQcmltaXRpdmVUeXBlKHR5cGUsIGJ5dGVzLCBpdCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlY29kZVt0eXBlXShieXRlcywgaXQpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTY2hlbWEgZW5jb2RlciAvIGRlY29kZXJcbiAgICAgICAgICovXG4gICAgICAgIHZhciBTY2hlbWEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBhbGxvdyBpbmhlcml0ZWQgY2xhc3NlcyB0byBoYXZlIGEgY29uc3RydWN0b3JcbiAgICAgICAgICAgIGZ1bmN0aW9uIFNjaGVtYSgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZml4IGVudW1lcmFiaWxpdHkgb2YgZmllbGRzIGZvciBlbmQtdXNlclxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgICAgICAgICAgJGNoYW5nZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgQ2hhbmdlVHJlZSh0aGlzLCB1bmRlZmluZWQsIG5ldyBSZWZlcmVuY2VUcmFja2VyKCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAvLyAkbGlzdGVuZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAvLyB9LFxuICAgICAgICAgICAgICAgICAgICAkY2FsbGJhY2tzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhciBkZXNjcmlwdG9ycyA9IHRoaXMuX2RlZmluaXRpb24uZGVzY3JpcHRvcnM7XG4gICAgICAgICAgICAgICAgaWYgKGRlc2NyaXB0b3JzKSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIGRlc2NyaXB0b3JzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBBc3NpZ24gaW5pdGlhbCB2YWx1ZXNcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIGlmIChhcmdzWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXNzaWduKGFyZ3NbMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFNjaGVtYS5vbkVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFNjaGVtYS5pcyA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0eXBlWydfZGVmaW5pdGlvbiddICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVbJ19kZWZpbml0aW9uJ10uc2NoZW1hICE9PSB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFNjaGVtYS5wcm90b3R5cGUub25DaGFuZ2UgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWRkQ2FsbGJhY2soKHRoaXMuJGNhbGxiYWNrcyB8fCAodGhpcy4kY2FsbGJhY2tzID0gW10pKSwgZXhwb3J0cy5PUEVSQVRJT04uUkVQTEFDRSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFNjaGVtYS5wcm90b3R5cGUub25SZW1vdmUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWRkQ2FsbGJhY2soKHRoaXMuJGNhbGxiYWNrcyB8fCAodGhpcy4kY2FsbGJhY2tzID0gW10pKSwgZXhwb3J0cy5PUEVSQVRJT04uREVMRVRFLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgU2NoZW1hLnByb3RvdHlwZS5hc3NpZ24gPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHByb3BzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2NoZW1hLnByb3RvdHlwZSwgXCJfZGVmaW5pdGlvblwiLCB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLl9kZWZpbml0aW9uOyB9LFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIChTZXJ2ZXItc2lkZSk6IEZsYWcgYSBwcm9wZXJ0eSB0byBiZSBlbmNvZGVkIGZvciB0aGUgbmV4dCBwYXRjaC5cbiAgICAgICAgICAgICAqIEBwYXJhbSBpbnN0YW5jZSBTY2hlbWEgaW5zdGFuY2VcbiAgICAgICAgICAgICAqIEBwYXJhbSBwcm9wZXJ0eSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBwcm9wZXJ0eSBuYW1lLCBvciBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSBpbmRleCBvZiB0aGUgcHJvcGVydHkuXG4gICAgICAgICAgICAgKiBAcGFyYW0gb3BlcmF0aW9uIE9QRVJBVElPTiB0byBwZXJmb3JtIChkZXRlY3RlZCBhdXRvbWF0aWNhbGx5KVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBTY2hlbWEucHJvdG90eXBlLnNldERpcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5LCBvcGVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRjaGFuZ2VzLmNoYW5nZShwcm9wZXJ0eSwgb3BlcmF0aW9uKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENsaWVudC1zaWRlOiBsaXN0ZW4gZm9yIGNoYW5nZXMgb24gcHJvcGVydHkuXG4gICAgICAgICAgICAgKiBAcGFyYW0gcHJvcCB0aGUgcHJvcGVydHkgbmFtZVxuICAgICAgICAgICAgICogQHBhcmFtIGNhbGxiYWNrIGNhbGxiYWNrIHRvIGJlIHRyaWdnZXJlZCBvbiBwcm9wZXJ0eSBjaGFuZ2VcbiAgICAgICAgICAgICAqIEBwYXJhbSBpbW1lZGlhdGUgdHJpZ2dlciBpbW1lZGlhdGVsbHkgaWYgcHJvcGVydHkgaGFzIGJlZW4gYWxyZWFkeSBzZXQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFNjaGVtYS5wcm90b3R5cGUubGlzdGVuID0gZnVuY3Rpb24gKHByb3AsIGNhbGxiYWNrLCBpbW1lZGlhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgIGlmIChpbW1lZGlhdGUgPT09IHZvaWQgMCkgeyBpbW1lZGlhdGUgPSB0cnVlOyB9XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLiRjYWxsYmFja3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kY2FsbGJhY2tzID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghdGhpcy4kY2FsbGJhY2tzW3Byb3BdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGNhbGxiYWNrc1twcm9wXSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLiRjYWxsYmFja3NbcHJvcF0ucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgaWYgKGltbWVkaWF0ZSAmJiB0aGlzW3Byb3BdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sodGhpc1twcm9wXSwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIHVuLXJlZ2lzdGVyIGNhbGxiYWNrLlxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBzcGxpY2VPbmUoX3RoaXMuJGNhbGxiYWNrc1twcm9wXSwgX3RoaXMuJGNhbGxiYWNrc1twcm9wXS5pbmRleE9mKGNhbGxiYWNrKSk7IH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgU2NoZW1hLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiAoYnl0ZXMsIGl0LCByZWYpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgaWYgKGl0ID09PSB2b2lkIDApIHsgaXQgPSB7IG9mZnNldDogMCB9OyB9XG4gICAgICAgICAgICAgICAgaWYgKHJlZiA9PT0gdm9pZCAwKSB7IHJlZiA9IHRoaXM7IH1cbiAgICAgICAgICAgICAgICB2YXIgYWxsQ2hhbmdlcyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciAkcm9vdCA9IHRoaXMuJGNoYW5nZXMucm9vdDtcbiAgICAgICAgICAgICAgICB2YXIgdG90YWxCeXRlcyA9IGJ5dGVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB2YXIgcmVmSWQgPSAwO1xuICAgICAgICAgICAgICAgICRyb290LnJlZnMuc2V0KHJlZklkLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaXQub2Zmc2V0IDwgdG90YWxCeXRlcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYnl0ZSA9IGJ5dGVzW2l0Lm9mZnNldCsrXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ5dGUgPT0gU1dJVENIX1RPX1NUUlVDVFVSRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmSWQgPSBudW1iZXIoYnl0ZXMsIGl0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXh0UmVmID0gJHJvb3QucmVmcy5nZXQocmVmSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyeWluZyB0byBhY2Nlc3MgYSByZWZlcmVuY2UgdGhhdCBoYXZlbid0IGJlZW4gZGVjb2RlZCB5ZXQuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXh0UmVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXFxcInJlZklkXFxcIiBub3QgZm91bmQ6IFwiLmNvbmNhdChyZWZJZCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmID0gbmV4dFJlZjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGFuZ2VUcmVlID0gcmVmWyckY2hhbmdlcyddO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXNTY2hlbWEgPSAocmVmWydfZGVmaW5pdGlvbiddICE9PSB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3BlcmF0aW9uID0gKGlzU2NoZW1hKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyAoYnl0ZSA+PiA2KSA8PCA2IC8vIFwiY29tcHJlc3NlZFwiIGluZGV4ICsgb3BlcmF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGJ5dGU7IC8vIFwidW5jb21wcmVzc2VkXCIgaW5kZXggKyBvcGVyYXRpb24gKGFycmF5L21hcCBpdGVtcylcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wZXJhdGlvbiA9PT0gZXhwb3J0cy5PUEVSQVRJT04uQ0xFQVIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiByZWZhY3RvciBtZSFcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBgLmNsZWFyKClgIG1ldGhvZCBpcyBjYWxsaW5nIGAkcm9vdC5yZW1vdmVSZWYocmVmSWQpYCBmb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVhY2ggaXRlbSBpbnNpZGUgdGhpcyBjb2xsZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmLmNsZWFyKGFsbENoYW5nZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpZWxkSW5kZXggPSAoaXNTY2hlbWEpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGJ5dGUgJSAob3BlcmF0aW9uIHx8IDI1NSkgLy8gaWYgXCJSRVBMQUNFXCIgb3BlcmF0aW9uICgwKSwgdXNlIDI1NVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBudW1iZXIoYnl0ZXMsIGl0KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpZWxkTmFtZSA9IChpc1NjaGVtYSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gKHJlZlsnX2RlZmluaXRpb24nXS5maWVsZHNCeUluZGV4W2ZpZWxkSW5kZXhdKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBcIlwiO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IGNoYW5nZVRyZWUuZ2V0VHlwZShmaWVsZEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNWYWx1ZSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGR5bmFtaWNJbmRleCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1NjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNWYWx1ZSA9IHJlZlsnZ2V0QnlJbmRleCddKGZpZWxkSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChvcGVyYXRpb24gJiBleHBvcnRzLk9QRVJBVElPTi5BREQpID09PSBleHBvcnRzLk9QRVJBVElPTi5BREQpIHsgLy8gQUREIG9yIERFTEVURV9BTkRfQUREXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHluYW1pY0luZGV4ID0gKHJlZiBpbnN0YW5jZW9mIE1hcFNjaGVtYSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBzdHJpbmcoYnl0ZXMsIGl0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGZpZWxkSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmWydzZXRJbmRleCddKGZpZWxkSW5kZXgsIGR5bmFtaWNJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBoZXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHluYW1pY0luZGV4ID0gcmVmWydnZXRJbmRleCddKGZpZWxkSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNWYWx1ZSA9IHJlZltcIl9cIi5jb25jYXQoZmllbGROYW1lKV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gRGVsZXRlIG9wZXJhdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgaWYgKChvcGVyYXRpb24gJiBleHBvcnRzLk9QRVJBVElPTi5ERUxFVEUpID09PSBleHBvcnRzLk9QRVJBVElPTi5ERUxFVEUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcGVyYXRpb24gIT09IGV4cG9ydHMuT1BFUkFUSU9OLkRFTEVURV9BTkRfQUREKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmWydkZWxldGVCeUluZGV4J10oZmllbGRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGbGFnIGByZWZJZGAgZm9yIGdhcmJhZ2UgY29sbGVjdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c1ZhbHVlICYmIHByZXZpb3VzVmFsdWVbJyRjaGFuZ2VzJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkcm9vdC5yZW1vdmVSZWYocHJldmlvdXNWYWx1ZVsnJGNoYW5nZXMnXS5yZWZJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJAY29seXNldXMvc2NoZW1hOiBkZWZpbml0aW9uIG1pc21hdGNoXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGtlZXAgc2tpcHBpbmcgbmV4dCBieXRlcyB1bnRpbCByZWFjaGVzIGEga25vd24gc3RydWN0dXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBieSBsb2NhbCBkZWNvZGVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXh0SXRlcmF0b3IgPSB7IG9mZnNldDogaXQub2Zmc2V0IH07XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaXQub2Zmc2V0IDwgdG90YWxCeXRlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzd2l0Y2hTdHJ1Y3R1cmVDaGVjayhieXRlcywgaXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRJdGVyYXRvci5vZmZzZXQgPSBpdC5vZmZzZXQgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoJHJvb3QucmVmcy5oYXMobnVtYmVyKGJ5dGVzLCBuZXh0SXRlcmF0b3IpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXQub2Zmc2V0Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChvcGVyYXRpb24gPT09IGV4cG9ydHMuT1BFUkFUSU9OLkRFTEVURSkgO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChTY2hlbWEuaXModHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWZJZF8xID0gbnVtYmVyKGJ5dGVzLCBpdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICRyb290LnJlZnMuZ2V0KHJlZklkXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wZXJhdGlvbiAhPT0gZXhwb3J0cy5PUEVSQVRJT04uUkVQTEFDRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZFR5cGUgPSB0aGlzLmdldFNjaGVtYVR5cGUoYnl0ZXMsIGl0LCB0eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5jcmVhdGVUeXBlSW5zdGFuY2UoY2hpbGRUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuJGNoYW5nZXMucmVmSWQgPSByZWZJZF8xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuJGNhbGxiYWNrcyA9IHByZXZpb3VzVmFsdWUuJGNhbGxiYWNrcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZhbHVlLiRsaXN0ZW5lcnMgPSBwcmV2aW91c1ZhbHVlLiRsaXN0ZW5lcnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNWYWx1ZVsnJGNoYW5nZXMnXS5yZWZJZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZklkXzEgIT09IHByZXZpb3VzVmFsdWVbJyRjaGFuZ2VzJ10ucmVmSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkcm9vdC5yZW1vdmVSZWYocHJldmlvdXNWYWx1ZVsnJGNoYW5nZXMnXS5yZWZJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3QuYWRkUmVmKHJlZklkXzEsIHZhbHVlLCAodmFsdWUgIT09IHByZXZpb3VzVmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgKHR5cGUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJpbWl0aXZlIHZhbHVlIChudW1iZXIsIHN0cmluZywgYm9vbGVhbiwgZXRjKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZGVjb2RlUHJpbWl0aXZlVHlwZSh0eXBlLCBieXRlcywgaXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGVEZWYgPSBnZXRUeXBlKE9iamVjdC5rZXlzKHR5cGUpWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWZJZF8yID0gbnVtYmVyKGJ5dGVzLCBpdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWVSZWYgPSAoJHJvb3QucmVmcy5oYXMocmVmSWRfMikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBwcmV2aW91c1ZhbHVlIHx8ICRyb290LnJlZnMuZ2V0KHJlZklkXzIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBuZXcgdHlwZURlZi5jb25zdHJ1Y3RvcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZVJlZi5jbG9uZSh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLiRjaGFuZ2VzLnJlZklkID0gcmVmSWRfMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByZXNlcnZlIHNjaGVtYSBjYWxsYmFja3NcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVbJyRjYWxsYmFja3MnXSA9IHByZXZpb3VzVmFsdWVbJyRjYWxsYmFja3MnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNWYWx1ZVsnJGNoYW5nZXMnXS5yZWZJZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZJZF8yICE9PSBwcmV2aW91c1ZhbHVlWyckY2hhbmdlcyddLnJlZklkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRyb290LnJlbW92ZVJlZihwcmV2aW91c1ZhbHVlWyckY2hhbmdlcyddLnJlZklkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJpZ2dlciBvblJlbW92ZSBpZiBzdHJ1Y3R1cmUgaGFzIGJlZW4gcmVwbGFjZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbnRyaWVzID0gcHJldmlvdXNWYWx1ZS5lbnRyaWVzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVyID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKGl0ZXIgPSBlbnRyaWVzLm5leHQoKSkgJiYgIWl0ZXIuZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IChfYSA9IGl0ZXIudmFsdWUsIF9hWzBdKSwgdmFsdWVfMSA9IF9hWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsQ2hhbmdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZJZDogcmVmSWRfMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcDogZXhwb3J0cy5PUEVSQVRJT04uREVMRVRFLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkOiBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1ZhbHVlOiB2YWx1ZV8xLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAkcm9vdC5hZGRSZWYocmVmSWRfMiwgdmFsdWUsICh2YWx1ZVJlZiAhPT0gcHJldmlvdXNWYWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlWyckY2hhbmdlcyddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVbJyRjaGFuZ2VzJ10uc2V0UGFyZW50KGNoYW5nZVRyZWUucmVmLCBjaGFuZ2VUcmVlLnJvb3QsIGZpZWxkSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlZiBpbnN0YW5jZW9mIFNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZltmaWVsZE5hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVmW2BfJHtmaWVsZE5hbWV9YF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlZiBpbnN0YW5jZW9mIE1hcFNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnN0IGtleSA9IHJlZlsnJGluZGV4ZXMnXS5nZXQoZmllbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBkeW5hbWljSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVmLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZbJyRpdGVtcyddLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZbJyRjaGFuZ2VzJ10uYWxsQ2hhbmdlcy5hZGQoZmllbGRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyZWYgaW5zdGFuY2VvZiBBcnJheVNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnN0IGtleSA9IHJlZlsnJGluZGV4ZXMnXVtmaWVsZF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJTRVRUSU5HIEZPUiBBcnJheVNjaGVtYSA9PlwiLCB7IGZpZWxkLCBrZXksIHZhbHVlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlZltrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmLnNldEF0KGZpZWxkSW5kZXgsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlZiBpbnN0YW5jZW9mIENvbGxlY3Rpb25TY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSByZWYuYWRkKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZbJ3NldEluZGV4J10oZmllbGRJbmRleCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocmVmIGluc3RhbmNlb2YgU2V0U2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gcmVmLmFkZCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZbJ3NldEluZGV4J10oZmllbGRJbmRleCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNWYWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbENoYW5nZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmSWQ6IHJlZklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wOiBvcGVyYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQ6IGZpZWxkTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkeW5hbWljSW5kZXg6IGR5bmFtaWNJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNWYWx1ZTogcHJldmlvdXNWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJDaGFuZ2VzKGFsbENoYW5nZXMpO1xuICAgICAgICAgICAgICAgIC8vIGRyb3AgcmVmZXJlbmNlcyBvZiB1bnVzZWQgc2NoZW1hc1xuICAgICAgICAgICAgICAgICRyb290LmdhcmJhZ2VDb2xsZWN0RGVsZXRlZFJlZnMoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWxsQ2hhbmdlcztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBTY2hlbWEucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uIChlbmNvZGVBbGwsIGJ5dGVzLCB1c2VGaWx0ZXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVuY29kZUFsbCA9PT0gdm9pZCAwKSB7IGVuY29kZUFsbCA9IGZhbHNlOyB9XG4gICAgICAgICAgICAgICAgaWYgKGJ5dGVzID09PSB2b2lkIDApIHsgYnl0ZXMgPSBbXTsgfVxuICAgICAgICAgICAgICAgIGlmICh1c2VGaWx0ZXJzID09PSB2b2lkIDApIHsgdXNlRmlsdGVycyA9IGZhbHNlOyB9XG4gICAgICAgICAgICAgICAgdmFyIHJvb3RDaGFuZ2VUcmVlID0gdGhpcy4kY2hhbmdlcztcbiAgICAgICAgICAgICAgICB2YXIgcmVmSWRzVmlzaXRlZCA9IG5ldyBXZWFrU2V0KCk7XG4gICAgICAgICAgICAgICAgdmFyIGNoYW5nZVRyZWVzID0gW3Jvb3RDaGFuZ2VUcmVlXTtcbiAgICAgICAgICAgICAgICB2YXIgbnVtQ2hhbmdlVHJlZXMgPSAxO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtQ2hhbmdlVHJlZXM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hhbmdlVHJlZSA9IGNoYW5nZVRyZWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVmID0gY2hhbmdlVHJlZS5yZWY7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpc1NjaGVtYSA9IChyZWYgaW5zdGFuY2VvZiBTY2hlbWEpO1xuICAgICAgICAgICAgICAgICAgICAvLyBHZW5lcmF0ZSB1bmlxdWUgcmVmSWQgZm9yIHRoZSBDaGFuZ2VUcmVlLlxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VUcmVlLmVuc3VyZVJlZklkKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1hcmsgdGhpcyBDaGFuZ2VUcmVlIGFzIHZpc2l0ZWQuXG4gICAgICAgICAgICAgICAgICAgIHJlZklkc1Zpc2l0ZWQuYWRkKGNoYW5nZVRyZWUpO1xuICAgICAgICAgICAgICAgICAgICAvLyByb290IGByZWZJZGAgaXMgc2tpcHBlZC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYW5nZVRyZWUgIT09IHJvb3RDaGFuZ2VUcmVlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoY2hhbmdlVHJlZS5jaGFuZ2VkIHx8IGVuY29kZUFsbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVpbnQ4JDEoYnl0ZXMsIFNXSVRDSF9UT19TVFJVQ1RVUkUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtYmVyJDEoYnl0ZXMsIGNoYW5nZVRyZWUucmVmSWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGFuZ2VzID0gKGVuY29kZUFsbClcbiAgICAgICAgICAgICAgICAgICAgICAgID8gQXJyYXkuZnJvbShjaGFuZ2VUcmVlLmFsbENoYW5nZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IEFycmF5LmZyb20oY2hhbmdlVHJlZS5jaGFuZ2VzLnZhbHVlcygpKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGNsID0gY2hhbmdlcy5sZW5ndGg7IGogPCBjbDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3BlcmF0aW9uID0gKGVuY29kZUFsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHsgb3A6IGV4cG9ydHMuT1BFUkFUSU9OLkFERCwgaW5kZXg6IGNoYW5nZXNbal0gfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogY2hhbmdlc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWVsZEluZGV4ID0gb3BlcmF0aW9uLmluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpZWxkID0gKGlzU2NoZW1hKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gcmVmWydfZGVmaW5pdGlvbiddLmZpZWxkc0J5SW5kZXggJiYgcmVmWydfZGVmaW5pdGlvbiddLmZpZWxkc0J5SW5kZXhbZmllbGRJbmRleF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGZpZWxkSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYWNoZSBiZWdpbiBpbmRleCBpZiBgdXNlRmlsdGVyc2BcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiZWdpbkluZGV4ID0gYnl0ZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZW5jb2RlIGZpZWxkIGluZGV4ICsgb3BlcmF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3BlcmF0aW9uLm9wICE9PSBleHBvcnRzLk9QRVJBVElPTi5UT1VDSCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1NjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb21wcmVzcyBgZmllbGRJbmRleGAgKyBgb3BlcmF0aW9uYCBpbnRvIGEgc2luZ2xlIGJ5dGUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgYWRkcyBhIGxpbWl0YWlvbiBvZiA2NCBmaWVsZHMgcGVyIFNjaGVtYSBzdHJ1Y3R1cmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdWludDgkMShieXRlcywgKGZpZWxkSW5kZXggfCBvcGVyYXRpb24ub3ApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVpbnQ4JDEoYnl0ZXMsIG9wZXJhdGlvbi5vcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGN1c3RvbSBvcGVyYXRpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcGVyYXRpb24ub3AgPT09IGV4cG9ydHMuT1BFUkFUSU9OLkNMRUFSKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbmRleGVkIG9wZXJhdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtYmVyJDEoYnl0ZXMsIGZpZWxkSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlbmNvZGUgXCJhbGlhc1wiIGZvciBkeW5hbWljIGZpZWxkcyAobWFwcylcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzU2NoZW1hICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKG9wZXJhdGlvbi5vcCAmIGV4cG9ydHMuT1BFUkFUSU9OLkFERCkgPT0gZXhwb3J0cy5PUEVSQVRJT04uQUREIC8vIEFERCBvciBERUxFVEVfQU5EX0FERFxuICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlZiBpbnN0YW5jZW9mIE1hcFNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNYXBTY2hlbWEgZHluYW1pYyBrZXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGR5bmFtaWNJbmRleCA9IGNoYW5nZVRyZWUucmVmWyckaW5kZXhlcyddLmdldChmaWVsZEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nJDEoYnl0ZXMsIGR5bmFtaWNJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wZXJhdGlvbi5vcCA9PT0gZXhwb3J0cy5PUEVSQVRJT04uREVMRVRFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBkZWxldGUgZnJvbSBmaWx0ZXIgY2FjaGUgZGF0YS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmICh1c2VGaWx0ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgIGRlbGV0ZSBjaGFuZ2VUcmVlLmNhY2hlc1tmaWVsZEluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zdCB0eXBlID0gY2hhbmdlVHJlZS5jaGlsZFR5cGUgfHwgcmVmLl9zY2hlbWFbZmllbGRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBjaGFuZ2VUcmVlLmdldFR5cGUoZmllbGRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zdCB0eXBlID0gY2hhbmdlVHJlZS5nZXRUeXBlKGZpZWxkSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gY2hhbmdlVHJlZS5nZXRWYWx1ZShmaWVsZEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVucXVldWUgQ2hhbmdlVHJlZSB0byBiZSB2aXNpdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVsnJGNoYW5nZXMnXSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICFyZWZJZHNWaXNpdGVkLmhhcyh2YWx1ZVsnJGNoYW5nZXMnXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VUcmVlcy5wdXNoKHZhbHVlWyckY2hhbmdlcyddKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVsnJGNoYW5nZXMnXS5lbnN1cmVSZWZJZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bUNoYW5nZVRyZWVzKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3BlcmF0aW9uLm9wID09PSBleHBvcnRzLk9QRVJBVElPTi5UT1VDSCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFNjaGVtYS5pcyh0eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydEluc3RhbmNlVHlwZSh2YWx1ZSwgdHlwZSwgcmVmLCBmaWVsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFbmNvZGUgcmVmSWQgZm9yIHRoaXMgaW5zdGFuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGFjdHVhbCBpbnN0YW5jZSBpcyBnb2luZyB0byBiZSBlbmNvZGVkIG9uIG5leHQgYGNoYW5nZVRyZWVgIGl0ZXJhdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bWJlciQxKGJ5dGVzLCB2YWx1ZS4kY2hhbmdlcy5yZWZJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJ5IHRvIGVuY29kZSBpbmhlcml0ZWQgVFlQRV9JRCBpZiBpdCdzIGFuIEFERCBvcGVyYXRpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChvcGVyYXRpb24ub3AgJiBleHBvcnRzLk9QRVJBVElPTi5BREQpID09PSBleHBvcnRzLk9QRVJBVElPTi5BREQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cnlFbmNvZGVUeXBlSWQoYnl0ZXMsIHR5cGUsIHZhbHVlLmNvbnN0cnVjdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgKHR5cGUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQcmltaXRpdmUgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVQcmltaXRpdmVUeXBlKHR5cGUsIGJ5dGVzLCB2YWx1ZSwgcmVmLCBmaWVsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEN1c3RvbSB0eXBlIChNYXBTY2hlbWEsIEFycmF5U2NoZW1hLCBldGMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVmaW5pdGlvbiA9IGdldFR5cGUoT2JqZWN0LmtleXModHlwZSlbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZW5zdXJlIGEgQXJyYXlTY2hlbWEgaGFzIGJlZW4gcHJvdmlkZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydEluc3RhbmNlVHlwZShyZWZbXCJfXCIuY29uY2F0KGZpZWxkKV0sIGRlZmluaXRpb24uY29uc3RydWN0b3IsIHJlZiwgZmllbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5jb2RlIHJlZklkIGZvciB0aGlzIGluc3RhbmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBhY3R1YWwgaW5zdGFuY2UgaXMgZ29pbmcgdG8gYmUgZW5jb2RlZCBvbiBuZXh0IGBjaGFuZ2VUcmVlYCBpdGVyYXRpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1iZXIkMShieXRlcywgdmFsdWUuJGNoYW5nZXMucmVmSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVzZUZpbHRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjYWNoZSBiZWdpbiAvIGVuZCBpbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZVRyZWUuY2FjaGUoZmllbGRJbmRleCwgYnl0ZXMuc2xpY2UoYmVnaW5JbmRleCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghZW5jb2RlQWxsICYmICF1c2VGaWx0ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VUcmVlLmRpc2NhcmQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgU2NoZW1hLnByb3RvdHlwZS5lbmNvZGVBbGwgPSBmdW5jdGlvbiAodXNlRmlsdGVycykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZSh0cnVlLCBbXSwgdXNlRmlsdGVycyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgU2NoZW1hLnByb3RvdHlwZS5hcHBseUZpbHRlcnMgPSBmdW5jdGlvbiAoY2xpZW50LCBlbmNvZGVBbGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgIGlmIChlbmNvZGVBbGwgPT09IHZvaWQgMCkgeyBlbmNvZGVBbGwgPSBmYWxzZTsgfVxuICAgICAgICAgICAgICAgIHZhciByb290ID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgcmVmSWRzRGlzc2FsbG93ZWQgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICAgICAgdmFyICRmaWx0ZXJTdGF0ZSA9IENsaWVudFN0YXRlLmdldChjbGllbnQpO1xuICAgICAgICAgICAgICAgIHZhciBjaGFuZ2VUcmVlcyA9IFt0aGlzLiRjaGFuZ2VzXTtcbiAgICAgICAgICAgICAgICB2YXIgbnVtQ2hhbmdlVHJlZXMgPSAxO1xuICAgICAgICAgICAgICAgIHZhciBmaWx0ZXJlZEJ5dGVzID0gW107XG4gICAgICAgICAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hhbmdlVHJlZSA9IGNoYW5nZVRyZWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVmSWRzRGlzc2FsbG93ZWQuaGFzKGNoYW5nZVRyZWUucmVmSWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWYgPSBjaGFuZ2VUcmVlLnJlZjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzU2NoZW1hID0gcmVmIGluc3RhbmNlb2YgU2NoZW1hO1xuICAgICAgICAgICAgICAgICAgICB1aW50OCQxKGZpbHRlcmVkQnl0ZXMsIFNXSVRDSF9UT19TVFJVQ1RVUkUpO1xuICAgICAgICAgICAgICAgICAgICBudW1iZXIkMShmaWx0ZXJlZEJ5dGVzLCBjaGFuZ2VUcmVlLnJlZklkKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsaWVudEhhc1JlZklkID0gJGZpbHRlclN0YXRlLnJlZklkcy5oYXMoY2hhbmdlVHJlZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpc0VuY29kZUFsbCA9IChlbmNvZGVBbGwgfHwgIWNsaWVudEhhc1JlZklkKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJSRUY6XCIsIHJlZi5jb25zdHJ1Y3Rvci5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJFbmNvZGUgYWxsP1wiLCBpc0VuY29kZUFsbCk7XG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIGluY2x1ZGUgYGNoYW5nZVRyZWVgIG9uIGxpc3Qgb2Yga25vd24gcmVmSWRzIGJ5IHRoaXMgY2xpZW50LlxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAkZmlsdGVyU3RhdGUuYWRkUmVmSWQoY2hhbmdlVHJlZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250YWluZXJJbmRleGVzID0gJGZpbHRlclN0YXRlLmNvbnRhaW5lckluZGV4ZXMuZ2V0KGNoYW5nZVRyZWUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hhbmdlcyA9IChpc0VuY29kZUFsbClcbiAgICAgICAgICAgICAgICAgICAgICAgID8gQXJyYXkuZnJvbShjaGFuZ2VUcmVlLmFsbENoYW5nZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IEFycmF5LmZyb20oY2hhbmdlVHJlZS5jaGFuZ2VzLnZhbHVlcygpKTtcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gV09SS0FST1VORDogdHJpZXMgdG8gcmUtZXZhbHVhdGUgcHJldmlvdXNseSBub3QgaW5jbHVkZWQgQGZpbHRlcigpIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgICAgICAgLy8gLSBzZWUgXCJERUxFVEUgYSBmaWVsZCBvZiBTY2hlbWFcIiB0ZXN0IGNhc2UuXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIGlmICghZW5jb2RlQWxsICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1NjaGVtYSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmLl9kZWZpbml0aW9uLmluZGV4ZXNXaXRoRmlsdGVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ZXNXaXRoRmlsdGVycyA9IHJlZi5fZGVmaW5pdGlvbi5pbmRleGVzV2l0aEZpbHRlcnM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleGVzV2l0aEZpbHRlcnMuZm9yRWFjaChmdW5jdGlvbiAoaW5kZXhXaXRoRmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb250YWluZXJJbmRleGVzLmhhcyhpbmRleFdpdGhGaWx0ZXIpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZVRyZWUuYWxsQ2hhbmdlcy5oYXMoaW5kZXhXaXRoRmlsdGVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNFbmNvZGVBbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaChpbmRleFdpdGhGaWx0ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgb3A6IGV4cG9ydHMuT1BFUkFUSU9OLkFERCwgaW5kZXg6IGluZGV4V2l0aEZpbHRlciwgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgY2wgPSBjaGFuZ2VzLmxlbmd0aDsgaiA8IGNsOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGFuZ2UgPSAoaXNFbmNvZGVBbGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB7IG9wOiBleHBvcnRzLk9QRVJBVElPTi5BREQsIGluZGV4OiBjaGFuZ2VzW2pdIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGNoYW5nZXNbal07XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjdXN0b20gb3BlcmF0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoYW5nZS5vcCA9PT0gZXhwb3J0cy5PUEVSQVRJT04uQ0xFQVIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1aW50OCQxKGZpbHRlcmVkQnl0ZXMsIGNoYW5nZS5vcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmllbGRJbmRleCA9IGNoYW5nZS5pbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWxldGluZyBmaWVsZHM6IGVuY29kZSB0aGUgb3BlcmF0aW9uICsgZmllbGQgaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlLm9wID09PSBleHBvcnRzLk9QRVJBVElPTi5ERUxFVEUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERFTEVURSBvcGVyYXRpb25zIGFsc28gbmVlZCB0byBnbyB0aHJvdWdoIGZpbHRlcmluZy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGNhY2hlIHRoZSBwcmV2aW91cyB2YWx1ZSBzbyB3ZSBjYW4gYWNjZXNzIHRoZSB2YWx1ZSAocHJpbWl0aXZlIG9yIGByZWZJZGApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gKGNoZWNrIGFnYWluc3QgYCRmaWx0ZXJTdGF0ZS5yZWZJZHNgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzU2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVpbnQ4JDEoZmlsdGVyZWRCeXRlcywgY2hhbmdlLm9wIHwgZmllbGRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1aW50OCQxKGZpbHRlcmVkQnl0ZXMsIGNoYW5nZS5vcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bWJlciQxKGZpbHRlcmVkQnl0ZXMsIGZpZWxkSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluZGV4ZWQgb3BlcmF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBjaGFuZ2VUcmVlLmdldFZhbHVlKGZpZWxkSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBjaGFuZ2VUcmVlLmdldFR5cGUoZmllbGRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNTY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJcyBhIFNjaGVtYSFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlsdGVyID0gKHJlZi5fZGVmaW5pdGlvbi5maWx0ZXJzICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZi5fZGVmaW5pdGlvbi5maWx0ZXJzW2ZpZWxkSW5kZXhdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyICYmICFmaWx0ZXIuY2FsbChyZWYsIGNsaWVudCwgdmFsdWUsIHJvb3QpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZVsnJGNoYW5nZXMnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmSWRzRGlzc2FsbG93ZWQuYWRkKHZhbHVlWyckY2hhbmdlcyddLnJlZklkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJcyBhIGNvbGxlY3Rpb24hIChtYXAsIGFycmF5LCBldGMuKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSBjaGFuZ2VUcmVlLnBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlsdGVyID0gY2hhbmdlVHJlZS5nZXRDaGlsZHJlbkZpbHRlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWx0ZXIgJiYgIWZpbHRlci5jYWxsKHBhcmVudCwgY2xpZW50LCByZWZbJyRpbmRleGVzJ10uZ2V0KGZpZWxkSW5kZXgpLCB2YWx1ZSwgcm9vdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlWyckY2hhbmdlcyddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZJZHNEaXNzYWxsb3dlZC5hZGQodmFsdWVbJyRjaGFuZ2VzJ10ucmVmSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZpc2l0IGNoaWxkIENoYW5nZVRyZWUgb24gZnVydGhlciBpdGVyYXRpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVbJyRjaGFuZ2VzJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VUcmVlcy5wdXNoKHZhbHVlWyckY2hhbmdlcyddKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1DaGFuZ2VUcmVlcysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvcHkgY2FjaGVkIGJ5dGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoYW5nZS5vcCAhPT0gZXhwb3J0cy5PUEVSQVRJT04uVE9VQ0gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IHJlZmFjdG9yIG1lIVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoYW5nZS5vcCA9PT0gZXhwb3J0cy5PUEVSQVRJT04uQUREIHx8IGlzU2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVzZSBjYWNoZWQgYnl0ZXMgZGlyZWN0bHkgaWYgaXMgZnJvbSBTY2hlbWEgdHlwZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyZWRCeXRlcy5wdXNoLmFwcGx5KGZpbHRlcmVkQnl0ZXMsIChfYSA9IGNoYW5nZVRyZWUuY2FjaGVzW2ZpZWxkSW5kZXhdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lckluZGV4ZXMuYWRkKGZpZWxkSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5lckluZGV4ZXMuaGFzKGZpZWxkSW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXNlIGNhY2hlZCBieXRlcyBpZiBhbHJlYWR5IGhhcyB0aGUgZmllbGRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJlZEJ5dGVzLnB1c2guYXBwbHkoZmlsdGVyZWRCeXRlcywgKF9iID0gY2hhbmdlVHJlZS5jYWNoZXNbZmllbGRJbmRleF0pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3JjZSBBREQgb3BlcmF0aW9uIGlmIGZpZWxkIGlzIG5vdCBrbm93biBieSB0aGlzIGNsaWVudC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXJJbmRleGVzLmFkZChmaWVsZEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVpbnQ4JDEoZmlsdGVyZWRCeXRlcywgZXhwb3J0cy5PUEVSQVRJT04uQUREKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bWJlciQxKGZpbHRlcmVkQnl0ZXMsIGZpZWxkSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlZiBpbnN0YW5jZW9mIE1hcFNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFwU2NoZW1hIGR5bmFtaWMga2V5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHluYW1pY0luZGV4ID0gY2hhbmdlVHJlZS5yZWZbJyRpbmRleGVzJ10uZ2V0KGZpZWxkSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZyQxKGZpbHRlcmVkQnl0ZXMsIGR5bmFtaWNJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVbJyRjaGFuZ2VzJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1iZXIkMShmaWx0ZXJlZEJ5dGVzLCB2YWx1ZVsnJGNoYW5nZXMnXS5yZWZJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBcImVuY29kZVByaW1pdGl2ZVR5cGVcIiB3aXRob3V0IHR5cGUgY2hlY2tpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHR5cGUgY2hlY2tpbmcgaGFzIGJlZW4gZG9uZSBvbiB0aGUgZmlyc3QgLmVuY29kZSgpIGNhbGwuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlW3R5cGVdKGZpbHRlcmVkQnl0ZXMsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlWyckY2hhbmdlcyddICYmICFpc1NjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAtIHRyYWNrIEFERC9SRVBMQUNFL0RFTEVURSBpbnN0YW5jZXMgb24gYCRmaWx0ZXJTdGF0ZWBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAtIGRvIE5PVCBhbHdheXMgZW5jb2RlIGR5bmFtaWNJbmRleCBmb3IgTWFwU2NoZW1hLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgKElmIGNsaWVudCBhbHJlYWR5IGhhcyB0aGF0IGtleSwgb25seSB0aGUgZmlyc3QgaW5kZXggaXMgbmVjZXNzYXJ5LilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVpbnQ4JDEoZmlsdGVyZWRCeXRlcywgZXhwb3J0cy5PUEVSQVRJT04uQUREKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1iZXIkMShmaWx0ZXJlZEJ5dGVzLCBmaWVsZEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVmIGluc3RhbmNlb2YgTWFwU2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1hcFNjaGVtYSBkeW5hbWljIGtleVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHluYW1pY0luZGV4ID0gY2hhbmdlVHJlZS5yZWZbJyRpbmRleGVzJ10uZ2V0KGZpZWxkSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmckMShmaWx0ZXJlZEJ5dGVzLCBkeW5hbWljSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1iZXIkMShmaWx0ZXJlZEJ5dGVzLCB2YWx1ZVsnJGNoYW5nZXMnXS5yZWZJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtQ2hhbmdlVHJlZXM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBfbG9vcF8xKGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsdGVyZWRCeXRlcztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBTY2hlbWEucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICB2YXIgY2xvbmVkID0gbmV3ICh0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICAgICAgICAgICAgICB2YXIgc2NoZW1hID0gdGhpcy5fZGVmaW5pdGlvbi5zY2hlbWE7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZmllbGQgaW4gc2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHRoaXNbZmllbGRdKSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mICgoX2EgPSB0aGlzW2ZpZWxkXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsb25lKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkZWVwIGNsb25lXG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9uZWRbZmllbGRdID0gdGhpc1tmaWVsZF0uY2xvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByaW1pdGl2ZSB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lZFtmaWVsZF0gPSB0aGlzW2ZpZWxkXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY2xvbmVkO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFNjaGVtYS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBzY2hlbWEgPSB0aGlzLl9kZWZpbml0aW9uLnNjaGVtYTtcbiAgICAgICAgICAgICAgICB2YXIgZGVwcmVjYXRlZCA9IHRoaXMuX2RlZmluaXRpb24uZGVwcmVjYXRlZDtcbiAgICAgICAgICAgICAgICB2YXIgb2JqID0ge307XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZmllbGQgaW4gc2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZGVwcmVjYXRlZFtmaWVsZF0gJiYgdGhpc1tmaWVsZF0gIT09IG51bGwgJiYgdHlwZW9mICh0aGlzW2ZpZWxkXSkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ialtmaWVsZF0gPSAodHlwZW9mICh0aGlzW2ZpZWxkXVsndG9KU09OJ10pID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzW2ZpZWxkXVsndG9KU09OJ10oKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpc1tcIl9cIi5jb25jYXQoZmllbGQpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFNjaGVtYS5wcm90b3R5cGUuZGlzY2FyZEFsbENoYW5nZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kY2hhbmdlcy5kaXNjYXJkQWxsKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgU2NoZW1hLnByb3RvdHlwZS5nZXRCeUluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbdGhpcy5fZGVmaW5pdGlvbi5maWVsZHNCeUluZGV4W2luZGV4XV07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgU2NoZW1hLnByb3RvdHlwZS5kZWxldGVCeUluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdGhpc1t0aGlzLl9kZWZpbml0aW9uLmZpZWxkc0J5SW5kZXhbaW5kZXhdXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBTY2hlbWEucHJvdG90eXBlLnRyeUVuY29kZVR5cGVJZCA9IGZ1bmN0aW9uIChieXRlcywgdHlwZSwgdGFyZ2V0VHlwZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlLl90eXBlaWQgIT09IHRhcmdldFR5cGUuX3R5cGVpZCkge1xuICAgICAgICAgICAgICAgICAgICB1aW50OCQxKGJ5dGVzLCBUWVBFX0lEKTtcbiAgICAgICAgICAgICAgICAgICAgbnVtYmVyJDEoYnl0ZXMsIHRhcmdldFR5cGUuX3R5cGVpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFNjaGVtYS5wcm90b3R5cGUuZ2V0U2NoZW1hVHlwZSA9IGZ1bmN0aW9uIChieXRlcywgaXQsIGRlZmF1bHRUeXBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHR5cGU7XG4gICAgICAgICAgICAgICAgaWYgKGJ5dGVzW2l0Lm9mZnNldF0gPT09IFRZUEVfSUQpIHtcbiAgICAgICAgICAgICAgICAgICAgaXQub2Zmc2V0Kys7XG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSB0aGlzLmNvbnN0cnVjdG9yLl9jb250ZXh0LmdldChudW1iZXIoYnl0ZXMsIGl0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlIHx8IGRlZmF1bHRUeXBlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFNjaGVtYS5wcm90b3R5cGUuY3JlYXRlVHlwZUluc3RhbmNlID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgdHlwZSgpO1xuICAgICAgICAgICAgICAgIC8vIGFzc2lnbiByb290IG9uICRjaGFuZ2VzXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuJGNoYW5nZXMucm9vdCA9IHRoaXMuJGNoYW5nZXMucm9vdDtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgU2NoZW1hLnByb3RvdHlwZS5fdHJpZ2dlckNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qO1xuICAgICAgICAgICAgICAgIHZhciB1bmlxdWVSZWZJZHMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICAgICAgdmFyICRyZWZzID0gdGhpcy4kY2hhbmdlcy5yb290LnJlZnM7XG4gICAgICAgICAgICAgICAgdmFyIF9sb29wXzIgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hhbmdlID0gY2hhbmdlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlZklkID0gY2hhbmdlLnJlZklkO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVmID0gJHJlZnMuZ2V0KHJlZklkKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyICRjYWxsYmFja3MgPSByZWZbJyRjYWxsYmFja3MnXTtcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gdHJpZ2dlciBvblJlbW92ZSBvbiBjaGlsZCBzdHJ1Y3R1cmUuXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIGlmICgoY2hhbmdlLm9wICYgZXhwb3J0cy5PUEVSQVRJT04uREVMRVRFKSA9PT0gZXhwb3J0cy5PUEVSQVRJT04uREVMRVRFICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2UucHJldmlvdXNWYWx1ZSBpbnN0YW5jZW9mIFNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgKF9iID0gKF9hID0gY2hhbmdlLnByZXZpb3VzVmFsdWVbJyRjYWxsYmFja3MnXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2V4cG9ydHMuT1BFUkFUSU9OLkRFTEVURV0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5mb3JFYWNoKGZ1bmN0aW9uIChjYWxsYmFjaykgeyByZXR1cm4gY2FsbGJhY2soKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gbm8gY2FsbGJhY2tzIGRlZmluZWQsIHNraXAgdGhpcyBzdHJ1Y3R1cmUhXG4gICAgICAgICAgICAgICAgICAgIGlmICghJGNhbGxiYWNrcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVmIGluc3RhbmNlb2YgU2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXVuaXF1ZVJlZklkcy5oYXMocmVmSWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJpZ2dlciBvbkNoYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoX2MgPSAkY2FsbGJhY2tzID09PSBudWxsIHx8ICRjYWxsYmFja3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6ICRjYWxsYmFja3NbZXhwb3J0cy5PUEVSQVRJT04uUkVQTEFDRV0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5mb3JFYWNoKGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNoYW5nZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2NoZW1hLm9uRXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoJGNhbGxiYWNrcy5oYXNPd25Qcm9wZXJ0eShjaGFuZ2UuZmllbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChfZCA9ICRjYWxsYmFja3NbY2hhbmdlLmZpZWxkXSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmZvckVhY2goZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hhbmdlLnZhbHVlLCBjaGFuZ2UucHJldmlvdXNWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgU2NoZW1hLm9uRXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpcyBhIGNvbGxlY3Rpb24gb2YgaXRlbXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2Uub3AgPT09IGV4cG9ydHMuT1BFUkFUSU9OLkFERCAmJiBjaGFuZ2UucHJldmlvdXNWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJpZ2VyIG9uQWRkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKF9lID0gJGNhbGxiYWNrc1tleHBvcnRzLk9QRVJBVElPTi5BRERdKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UuZm9yRWFjaChmdW5jdGlvbiAoY2FsbGJhY2spIHsgdmFyIF9hOyByZXR1cm4gY2FsbGJhY2soY2hhbmdlLnZhbHVlLCAoX2EgPSBjaGFuZ2UuZHluYW1pY0luZGV4KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjaGFuZ2UuZmllbGQpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoYW5nZS5vcCA9PT0gZXhwb3J0cy5PUEVSQVRJT04uREVMRVRFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRTogYHByZXZpb3VzVmFsdWVgIHNob3VsZCBhbHdheXMgYmUgYXZhaWxhYmxlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFERCArIERFTEVURSBvcGVyYXRpb25zIGFyZSBzdGlsbCBlbmNvZGluZyBERUxFVEUgb3BlcmF0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoYW5nZS5wcmV2aW91c1ZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJpZ2VyIG9uUmVtb3ZlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChfZiA9ICRjYWxsYmFja3NbZXhwb3J0cy5PUEVSQVRJT04uREVMRVRFXSkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmZvckVhY2goZnVuY3Rpb24gKGNhbGxiYWNrKSB7IHZhciBfYTsgcmV0dXJuIGNhbGxiYWNrKGNoYW5nZS5wcmV2aW91c1ZhbHVlLCAoX2EgPSBjaGFuZ2UuZHluYW1pY0luZGV4KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjaGFuZ2UuZmllbGQpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGFuZ2Uub3AgPT09IGV4cG9ydHMuT1BFUkFUSU9OLkRFTEVURV9BTkRfQUREKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJpZ2VyIG9uUmVtb3ZlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoYW5nZS5wcmV2aW91c1ZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKF9nID0gJGNhbGxiYWNrc1tleHBvcnRzLk9QRVJBVElPTi5ERUxFVEVdKSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cuZm9yRWFjaChmdW5jdGlvbiAoY2FsbGJhY2spIHsgdmFyIF9hOyByZXR1cm4gY2FsbGJhY2soY2hhbmdlLnByZXZpb3VzVmFsdWUsIChfYSA9IGNoYW5nZS5keW5hbWljSW5kZXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNoYW5nZS5maWVsZCk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cmlnZXIgb25BZGRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoX2ggPSAkY2FsbGJhY2tzW2V4cG9ydHMuT1BFUkFUSU9OLkFERF0pID09PSBudWxsIHx8IF9oID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaC5mb3JFYWNoKGZ1bmN0aW9uIChjYWxsYmFjaykgeyB2YXIgX2E7IHJldHVybiBjYWxsYmFjayhjaGFuZ2UudmFsdWUsIChfYSA9IGNoYW5nZS5keW5hbWljSW5kZXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNoYW5nZS5maWVsZCk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJpZ2dlciBvbkNoYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoYW5nZS52YWx1ZSAhPT0gY2hhbmdlLnByZXZpb3VzVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoX2ogPSAkY2FsbGJhY2tzW2V4cG9ydHMuT1BFUkFUSU9OLlJFUExBQ0VdKSA9PT0gbnVsbCB8fCBfaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2ouZm9yRWFjaChmdW5jdGlvbiAoY2FsbGJhY2spIHsgdmFyIF9hOyByZXR1cm4gY2FsbGJhY2soY2hhbmdlLnZhbHVlLCAoX2EgPSBjaGFuZ2UuZHluYW1pY0luZGV4KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjaGFuZ2UuZmllbGQpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB1bmlxdWVSZWZJZHMuYWRkKHJlZklkKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBfbG9vcF8yKGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBTY2hlbWEuX2RlZmluaXRpb24gPSBTY2hlbWFEZWZpbml0aW9uLmNyZWF0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIFNjaGVtYTtcbiAgICAgICAgfSgpKTtcblxuICAgICAgICBmdW5jdGlvbiBkdW1wQ2hhbmdlcyhzY2hlbWEpIHtcbiAgICAgICAgICAgIHZhciBjaGFuZ2VUcmVlcyA9IFtzY2hlbWFbJyRjaGFuZ2VzJ11dO1xuICAgICAgICAgICAgdmFyIG51bUNoYW5nZVRyZWVzID0gMTtcbiAgICAgICAgICAgIHZhciBkdW1wID0ge307XG4gICAgICAgICAgICB2YXIgY3VycmVudFN0cnVjdHVyZSA9IGR1bXA7XG4gICAgICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoYW5nZVRyZWUgPSBjaGFuZ2VUcmVlc1tpXTtcbiAgICAgICAgICAgICAgICBjaGFuZ2VUcmVlLmNoYW5nZXMuZm9yRWFjaChmdW5jdGlvbiAoY2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWYgPSBjaGFuZ2VUcmVlLnJlZjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpZWxkSW5kZXggPSBjaGFuZ2UuaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmaWVsZCA9IChyZWZbJ19kZWZpbml0aW9uJ10pXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHJlZlsnX2RlZmluaXRpb24nXS5maWVsZHNCeUluZGV4W2ZpZWxkSW5kZXhdXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHJlZlsnJGluZGV4ZXMnXS5nZXQoZmllbGRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdHJ1Y3R1cmVbZmllbGRdID0gY2hhbmdlVHJlZS5nZXRWYWx1ZShmaWVsZEluZGV4KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUNoYW5nZVRyZWVzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBfbG9vcF8xKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGR1bXA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVmbGVjdGlvbkNvbnRleHQgPSB7IGNvbnRleHQ6IG5ldyBDb250ZXh0KCkgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZmxlY3Rpb25cbiAgICAgICAgICovXG4gICAgICAgIHZhciBSZWZsZWN0aW9uRmllbGQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgICAgICBfX2V4dGVuZHMoUmVmbGVjdGlvbkZpZWxkLCBfc3VwZXIpO1xuICAgICAgICAgICAgZnVuY3Rpb24gUmVmbGVjdGlvbkZpZWxkKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICAgICAgICAgIHR5cGUoXCJzdHJpbmdcIiwgcmVmbGVjdGlvbkNvbnRleHQpXG4gICAgICAgICAgICBdLCBSZWZsZWN0aW9uRmllbGQucHJvdG90eXBlLCBcIm5hbWVcIiwgdm9pZCAwKTtcbiAgICAgICAgICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICAgICAgICAgIHR5cGUoXCJzdHJpbmdcIiwgcmVmbGVjdGlvbkNvbnRleHQpXG4gICAgICAgICAgICBdLCBSZWZsZWN0aW9uRmllbGQucHJvdG90eXBlLCBcInR5cGVcIiwgdm9pZCAwKTtcbiAgICAgICAgICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICAgICAgICAgIHR5cGUoXCJudW1iZXJcIiwgcmVmbGVjdGlvbkNvbnRleHQpXG4gICAgICAgICAgICBdLCBSZWZsZWN0aW9uRmllbGQucHJvdG90eXBlLCBcInJlZmVyZW5jZWRUeXBlXCIsIHZvaWQgMCk7XG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdGlvbkZpZWxkO1xuICAgICAgICB9KFNjaGVtYSkpO1xuICAgICAgICB2YXIgUmVmbGVjdGlvblR5cGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgICAgICBfX2V4dGVuZHMoUmVmbGVjdGlvblR5cGUsIF9zdXBlcik7XG4gICAgICAgICAgICBmdW5jdGlvbiBSZWZsZWN0aW9uVHlwZSgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgICAgICAgICBfdGhpcy5maWVsZHMgPSBuZXcgQXJyYXlTY2hlbWEoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgICAgICAgICB0eXBlKFwibnVtYmVyXCIsIHJlZmxlY3Rpb25Db250ZXh0KVxuICAgICAgICAgICAgXSwgUmVmbGVjdGlvblR5cGUucHJvdG90eXBlLCBcImlkXCIsIHZvaWQgMCk7XG4gICAgICAgICAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgICAgICAgICB0eXBlKFtSZWZsZWN0aW9uRmllbGRdLCByZWZsZWN0aW9uQ29udGV4dClcbiAgICAgICAgICAgIF0sIFJlZmxlY3Rpb25UeXBlLnByb3RvdHlwZSwgXCJmaWVsZHNcIiwgdm9pZCAwKTtcbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0aW9uVHlwZTtcbiAgICAgICAgfShTY2hlbWEpKTtcbiAgICAgICAgdmFyIFJlZmxlY3Rpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgICAgICBfX2V4dGVuZHMoUmVmbGVjdGlvbiwgX3N1cGVyKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIFJlZmxlY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgICAgICAgICAgX3RoaXMudHlwZXMgPSBuZXcgQXJyYXlTY2hlbWEoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSZWZsZWN0aW9uLmVuY29kZSA9IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIHZhciByb290U2NoZW1hVHlwZSA9IGluc3RhbmNlLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgICAgIHZhciByZWZsZWN0aW9uID0gbmV3IFJlZmxlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICByZWZsZWN0aW9uLnJvb3RUeXBlID0gcm9vdFNjaGVtYVR5cGUuX3R5cGVpZDtcbiAgICAgICAgICAgICAgICB2YXIgYnVpbGRUeXBlID0gZnVuY3Rpb24gKGN1cnJlbnRUeXBlLCBzY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZmllbGROYW1lIGluIHNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpZWxkID0gbmV3IFJlZmxlY3Rpb25GaWVsZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQubmFtZSA9IGZpZWxkTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWVsZFR5cGUgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChzY2hlbWFbZmllbGROYW1lXSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZFR5cGUgPSBzY2hlbWFbZmllbGROYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0eXBlXzEgPSBzY2hlbWFbZmllbGROYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGRUeXBlU2NoZW1hID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogcmVmYWN0b3IgYmVsb3cuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoU2NoZW1hLmlzKHR5cGVfMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRUeXBlID0gXCJyZWZcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRUeXBlU2NoZW1hID0gc2NoZW1hW2ZpZWxkTmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZFR5cGUgPSBPYmplY3Qua2V5cyh0eXBlXzEpWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mICh0eXBlXzFbZmllbGRUeXBlXSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkVHlwZSArPSBcIjpcIiArIHR5cGVfMVtmaWVsZFR5cGVdOyAvLyBhcnJheTpzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkVHlwZVNjaGVtYSA9IHR5cGVfMVtmaWVsZFR5cGVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkLnJlZmVyZW5jZWRUeXBlID0gKGNoaWxkVHlwZVNjaGVtYSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBjaGlsZFR5cGVTY2hlbWEuX3R5cGVpZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQudHlwZSA9IGZpZWxkVHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUeXBlLmZpZWxkcy5wdXNoKGZpZWxkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZWZsZWN0aW9uLnR5cGVzLnB1c2goY3VycmVudFR5cGUpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIHR5cGVzID0gcm9vdFNjaGVtYVR5cGUuX2NvbnRleHQudHlwZXM7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgdHlwZWlkIGluIHR5cGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0eXBlXzIgPSBuZXcgUmVmbGVjdGlvblR5cGUoKTtcbiAgICAgICAgICAgICAgICAgICAgdHlwZV8yLmlkID0gTnVtYmVyKHR5cGVpZCk7XG4gICAgICAgICAgICAgICAgICAgIGJ1aWxkVHlwZSh0eXBlXzIsIHR5cGVzW3R5cGVpZF0uX2RlZmluaXRpb24uc2NoZW1hKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlZmxlY3Rpb24uZW5jb2RlQWxsKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgUmVmbGVjdGlvbi5kZWNvZGUgPSBmdW5jdGlvbiAoYnl0ZXMsIGl0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCgpO1xuICAgICAgICAgICAgICAgIHZhciByZWZsZWN0aW9uID0gbmV3IFJlZmxlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICByZWZsZWN0aW9uLmRlY29kZShieXRlcywgaXQpO1xuICAgICAgICAgICAgICAgIHZhciBzY2hlbWFUeXBlcyA9IHJlZmxlY3Rpb24udHlwZXMucmVkdWNlKGZ1bmN0aW9uICh0eXBlcywgcmVmbGVjdGlvblR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjaGVtYSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fZXh0ZW5kcyhfLCBfc3VwZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gXygpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXztcbiAgICAgICAgICAgICAgICAgICAgfShTY2hlbWEpKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGVpZCA9IHJlZmxlY3Rpb25UeXBlLmlkO1xuICAgICAgICAgICAgICAgICAgICB0eXBlc1t0eXBlaWRdID0gc2NoZW1hO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmFkZChzY2hlbWEsIHR5cGVpZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlcztcbiAgICAgICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgICAgICAgICAgcmVmbGVjdGlvbi50eXBlcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWZsZWN0aW9uVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2NoZW1hVHlwZSA9IHNjaGVtYVR5cGVzW3JlZmxlY3Rpb25UeXBlLmlkXTtcbiAgICAgICAgICAgICAgICAgICAgcmVmbGVjdGlvblR5cGUuZmllbGRzLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGQucmVmZXJlbmNlZFR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWVsZFR5cGUgPSBmaWVsZC50eXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWZUeXBlID0gc2NoZW1hVHlwZXNbZmllbGQucmVmZXJlbmNlZFR5cGVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1hcCBvciBhcnJheSBvZiBwcmltaXRpdmUgdHlwZSAoLTEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWZUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0eXBlSW5mbyA9IGZpZWxkLnR5cGUuc3BsaXQoXCI6XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZFR5cGUgPSB0eXBlSW5mb1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmVHlwZSA9IHR5cGVJbmZvWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGRUeXBlID09PSBcInJlZlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUocmVmVHlwZSwgeyBjb250ZXh0OiBjb250ZXh0IH0pKHNjaGVtYVR5cGUucHJvdG90eXBlLCBmaWVsZC5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUoKF9hID0ge30sIF9hW2ZpZWxkVHlwZV0gPSByZWZUeXBlLCBfYSksIHsgY29udGV4dDogY29udGV4dCB9KShzY2hlbWFUeXBlLnByb3RvdHlwZSwgZmllbGQubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZShmaWVsZC50eXBlLCB7IGNvbnRleHQ6IGNvbnRleHQgfSkoc2NoZW1hVHlwZS5wcm90b3R5cGUsIGZpZWxkLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIgcm9vdFR5cGUgPSBzY2hlbWFUeXBlc1tyZWZsZWN0aW9uLnJvb3RUeXBlXTtcbiAgICAgICAgICAgICAgICB2YXIgcm9vdEluc3RhbmNlID0gbmV3IHJvb3RUeXBlKCk7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogYXV0by1pbml0aWFsaXplIHJlZmVyZW5jZWQgdHlwZXMgb24gcm9vdCB0eXBlXG4gICAgICAgICAgICAgICAgICogdG8gYWxsb3cgcmVnaXN0ZXJpbmcgbGlzdGVuZXJzIGltbWVkaWF0ZWxseSBvbiBjbGllbnQtc2lkZVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGZpZWxkTmFtZSBpbiByb290VHlwZS5fZGVmaW5pdGlvbi5zY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpZWxkVHlwZSA9IHJvb3RUeXBlLl9kZWZpbml0aW9uLnNjaGVtYVtmaWVsZE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChmaWVsZFR5cGUpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb290SW5zdGFuY2VbZmllbGROYW1lXSA9ICh0eXBlb2YgKGZpZWxkVHlwZSkgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG5ldyBmaWVsZFR5cGUoKSAvLyBpcyBhIHNjaGVtYSByZWZlcmVuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG5ldyAoZ2V0VHlwZShPYmplY3Qua2V5cyhmaWVsZFR5cGUpWzBdKSkuY29uc3RydWN0b3IoKTsgLy8gaXMgYSBcImNvbGxlY3Rpb25cIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByb290SW5zdGFuY2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX19kZWNvcmF0ZShbXG4gICAgICAgICAgICAgICAgdHlwZShbUmVmbGVjdGlvblR5cGVdLCByZWZsZWN0aW9uQ29udGV4dClcbiAgICAgICAgICAgIF0sIFJlZmxlY3Rpb24ucHJvdG90eXBlLCBcInR5cGVzXCIsIHZvaWQgMCk7XG4gICAgICAgICAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgICAgICAgICB0eXBlKFwibnVtYmVyXCIsIHJlZmxlY3Rpb25Db250ZXh0KVxuICAgICAgICAgICAgXSwgUmVmbGVjdGlvbi5wcm90b3R5cGUsIFwicm9vdFR5cGVcIiwgdm9pZCAwKTtcbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0aW9uO1xuICAgICAgICB9KFNjaGVtYSkpO1xuXG4gICAgICAgIHJlZ2lzdGVyVHlwZShcIm1hcFwiLCB7IGNvbnN0cnVjdG9yOiBNYXBTY2hlbWEgfSk7XG4gICAgICAgIHJlZ2lzdGVyVHlwZShcImFycmF5XCIsIHsgY29uc3RydWN0b3I6IEFycmF5U2NoZW1hIH0pO1xuICAgICAgICByZWdpc3RlclR5cGUoXCJzZXRcIiwgeyBjb25zdHJ1Y3RvcjogU2V0U2NoZW1hIH0pO1xuICAgICAgICByZWdpc3RlclR5cGUoXCJjb2xsZWN0aW9uXCIsIHsgY29uc3RydWN0b3I6IENvbGxlY3Rpb25TY2hlbWEsIH0pO1xuXG4gICAgICAgIGV4cG9ydHMuQXJyYXlTY2hlbWEgPSBBcnJheVNjaGVtYTtcbiAgICAgICAgZXhwb3J0cy5Db2xsZWN0aW9uU2NoZW1hID0gQ29sbGVjdGlvblNjaGVtYTtcbiAgICAgICAgZXhwb3J0cy5Db250ZXh0ID0gQ29udGV4dDtcbiAgICAgICAgZXhwb3J0cy5NYXBTY2hlbWEgPSBNYXBTY2hlbWE7XG4gICAgICAgIGV4cG9ydHMuUmVmbGVjdGlvbiA9IFJlZmxlY3Rpb247XG4gICAgICAgIGV4cG9ydHMuUmVmbGVjdGlvbkZpZWxkID0gUmVmbGVjdGlvbkZpZWxkO1xuICAgICAgICBleHBvcnRzLlJlZmxlY3Rpb25UeXBlID0gUmVmbGVjdGlvblR5cGU7XG4gICAgICAgIGV4cG9ydHMuU2NoZW1hID0gU2NoZW1hO1xuICAgICAgICBleHBvcnRzLlNjaGVtYURlZmluaXRpb24gPSBTY2hlbWFEZWZpbml0aW9uO1xuICAgICAgICBleHBvcnRzLlNldFNjaGVtYSA9IFNldFNjaGVtYTtcbiAgICAgICAgZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG4gICAgICAgIGV4cG9ydHMuZGVmaW5lVHlwZXMgPSBkZWZpbmVUeXBlcztcbiAgICAgICAgZXhwb3J0cy5kZXByZWNhdGVkID0gZGVwcmVjYXRlZDtcbiAgICAgICAgZXhwb3J0cy5kdW1wQ2hhbmdlcyA9IGR1bXBDaGFuZ2VzO1xuICAgICAgICBleHBvcnRzLmVuY29kZSA9IGVuY29kZTtcbiAgICAgICAgZXhwb3J0cy5maWx0ZXIgPSBmaWx0ZXI7XG4gICAgICAgIGV4cG9ydHMuZmlsdGVyQ2hpbGRyZW4gPSBmaWx0ZXJDaGlsZHJlbjtcbiAgICAgICAgZXhwb3J0cy5oYXNGaWx0ZXIgPSBoYXNGaWx0ZXI7XG4gICAgICAgIGV4cG9ydHMucmVnaXN0ZXJUeXBlID0gcmVnaXN0ZXJUeXBlO1xuICAgICAgICBleHBvcnRzLnR5cGUgPSB0eXBlO1xuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbiAgICB9KSk7XG4gICAgfSk7XG5cbiAgICB2YXIgUm9vbSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUm9vbShuYW1lLCByb290U2NoZW1hKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgLy8gUHVibGljIHNpZ25hbHNcbiAgICAgICAgICAgIHRoaXMub25TdGF0ZUNoYW5nZSA9IGNyZWF0ZVNpZ25hbCgpO1xuICAgICAgICAgICAgdGhpcy5vbkVycm9yID0gY3JlYXRlU2lnbmFsKCk7XG4gICAgICAgICAgICB0aGlzLm9uTGVhdmUgPSBjcmVhdGVTaWduYWwoKTtcbiAgICAgICAgICAgIHRoaXMub25Kb2luID0gY3JlYXRlU2lnbmFsKCk7XG4gICAgICAgICAgICB0aGlzLmhhc0pvaW5lZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5vbk1lc3NhZ2VIYW5kbGVycyA9IGNyZWF0ZU5hbm9FdmVudHMoKTtcbiAgICAgICAgICAgIHRoaXMucm9vbUlkID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgICBpZiAocm9vdFNjaGVtYSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VyaWFsaXplciA9IG5ldyAoZ2V0U2VyaWFsaXplcihcInNjaGVtYVwiKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yb290U2NoZW1hID0gcm9vdFNjaGVtYTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlcmlhbGl6ZXIuc3RhdGUgPSBuZXcgcm9vdFNjaGVtYSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vbkVycm9yKGZ1bmN0aW9uIChjb2RlLCBtZXNzYWdlKSB7IHJldHVybiBjb25zb2xlLndhcm4oXCJjb2x5c2V1cy5qcyAtIG9uRXJyb3IgPT4gKFwiLmNvbmNhdChjb2RlLCBcIikgXCIpLmNvbmNhdChtZXNzYWdlKSk7IH0pO1xuICAgICAgICAgICAgdGhpcy5vbkxlYXZlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnJlbW92ZUFsbExpc3RlbmVycygpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUm9vbS5wcm90b3R5cGUsIFwiaWRcIiwge1xuICAgICAgICAgICAgLy8gVE9ETzogZGVwcmVjYXRlIG1lIG9uIHZlcnNpb24gMS4wXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucm9vbUlkOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIFJvb20ucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAoZW5kcG9pbnQsIGRldk1vZGVDbG9zZUNhbGxiYWNrLCByb29tIC8vIHdoZW4gcmVjb25uZWN0aW5nIG9uIGRldk1vZGUsIHJlLXVzZSBwcmV2aW91cyByb29tIGludGFuY2UgZm9yIGhhbmRsaW5nIGV2ZW50cy5cbiAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAocm9vbSA9PT0gdm9pZCAwKSB7IHJvb20gPSB0aGlzOyB9XG4gICAgICAgICAgICB2YXIgY29ubmVjdGlvbiA9IG5ldyBDb25uZWN0aW9uKCk7XG4gICAgICAgICAgICByb29tLmNvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xuICAgICAgICAgICAgY29ubmVjdGlvbi5ldmVudHMub25tZXNzYWdlID0gUm9vbS5wcm90b3R5cGUub25NZXNzYWdlQ2FsbGJhY2suYmluZChyb29tKTtcbiAgICAgICAgICAgIGNvbm5lY3Rpb24uZXZlbnRzLm9uY2xvc2UgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGlmICghcm9vbS5oYXNKb2luZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiUm9vbSBjb25uZWN0aW9uIHdhcyBjbG9zZWQgdW5leHBlY3RlZGx5IChcIi5jb25jYXQoZS5jb2RlLCBcIik6IFwiKS5jb25jYXQoZS5yZWFzb24pKTtcbiAgICAgICAgICAgICAgICAgICAgcm9vbS5vbkVycm9yLmludm9rZShlLmNvZGUsIGUucmVhc29uKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZS5jb2RlID09PSBDbG9zZUNvZGUuREVWTU9ERV9SRVNUQVJUICYmIGRldk1vZGVDbG9zZUNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGRldk1vZGVDbG9zZUNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByb29tLm9uTGVhdmUuaW52b2tlKGUuY29kZSk7XG4gICAgICAgICAgICAgICAgICAgIHJvb20uZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25uZWN0aW9uLmV2ZW50cy5vbmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJSb29tLCBvbkVycm9yIChcIi5jb25jYXQoZS5jb2RlLCBcIik6IFwiKS5jb25jYXQoZS5yZWFzb24pKTtcbiAgICAgICAgICAgICAgICByb29tLm9uRXJyb3IuaW52b2tlKGUuY29kZSwgZS5yZWFzb24pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbm5lY3Rpb24uY29ubmVjdChlbmRwb2ludCk7XG4gICAgICAgIH07XG4gICAgICAgIFJvb20ucHJvdG90eXBlLmxlYXZlID0gZnVuY3Rpb24gKGNvbnNlbnRlZCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGlmIChjb25zZW50ZWQgPT09IHZvaWQgMCkgeyBjb25zZW50ZWQgPSB0cnVlOyB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5vbkxlYXZlKGZ1bmN0aW9uIChjb2RlKSB7IHJldHVybiByZXNvbHZlKGNvZGUpOyB9KTtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuY29ubmVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29uc2VudGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb25uZWN0aW9uLnNlbmQoW2V4cG9ydHMuUHJvdG9jb2wuTEVBVkVfUk9PTV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY29ubmVjdGlvbi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vbkxlYXZlLmludm9rZShDbG9zZUNvZGUuQ09OU0VOVEVEKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgUm9vbS5wcm90b3R5cGUub25NZXNzYWdlID0gZnVuY3Rpb24gKHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vbk1lc3NhZ2VIYW5kbGVycy5vbih0aGlzLmdldE1lc3NhZ2VIYW5kbGVyS2V5KHR5cGUpLCBjYWxsYmFjayk7XG4gICAgICAgIH07XG4gICAgICAgIFJvb20ucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAodHlwZSwgbWVzc2FnZSkge1xuICAgICAgICAgICAgdmFyIGluaXRpYWxCeXRlcyA9IFtleHBvcnRzLlByb3RvY29sLlJPT01fREFUQV07XG4gICAgICAgICAgICBpZiAodHlwZW9mICh0eXBlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHVtZC5lbmNvZGUuc3RyaW5nKGluaXRpYWxCeXRlcywgdHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1bWQuZW5jb2RlLm51bWJlcihpbml0aWFsQnl0ZXMsIHR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGFycjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZW5jb2RlZCA9IGVuY29kZShtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBhcnIgPSBuZXcgVWludDhBcnJheShpbml0aWFsQnl0ZXMubGVuZ3RoICsgZW5jb2RlZC5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBhcnIuc2V0KG5ldyBVaW50OEFycmF5KGluaXRpYWxCeXRlcyksIDApO1xuICAgICAgICAgICAgICAgIGFyci5zZXQobmV3IFVpbnQ4QXJyYXkoZW5jb2RlZCksIGluaXRpYWxCeXRlcy5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXJyID0gbmV3IFVpbnQ4QXJyYXkoaW5pdGlhbEJ5dGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbi5zZW5kKGFyci5idWZmZXIpO1xuICAgICAgICB9O1xuICAgICAgICBSb29tLnByb3RvdHlwZS5zZW5kQnl0ZXMgPSBmdW5jdGlvbiAodHlwZSwgYnl0ZXMpIHtcbiAgICAgICAgICAgIHZhciBpbml0aWFsQnl0ZXMgPSBbZXhwb3J0cy5Qcm90b2NvbC5ST09NX0RBVEFfQllURVNdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAodHlwZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICB1bWQuZW5jb2RlLnN0cmluZyhpbml0aWFsQnl0ZXMsIHR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdW1kLmVuY29kZS5udW1iZXIoaW5pdGlhbEJ5dGVzLCB0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBhcnI7XG4gICAgICAgICAgICBhcnIgPSBuZXcgVWludDhBcnJheShpbml0aWFsQnl0ZXMubGVuZ3RoICsgKGJ5dGVzLmJ5dGVMZW5ndGggfHwgYnl0ZXMubGVuZ3RoKSk7XG4gICAgICAgICAgICBhcnIuc2V0KG5ldyBVaW50OEFycmF5KGluaXRpYWxCeXRlcyksIDApO1xuICAgICAgICAgICAgYXJyLnNldChuZXcgVWludDhBcnJheShieXRlcyksIGluaXRpYWxCeXRlcy5sZW5ndGgpO1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uLnNlbmQoYXJyLmJ1ZmZlcik7XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSb29tLnByb3RvdHlwZSwgXCJzdGF0ZVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVyLmdldFN0YXRlKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIFJvb20ucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMub25Kb2luLmNsZWFyKCk7XG4gICAgICAgICAgICB0aGlzLm9uU3RhdGVDaGFuZ2UuY2xlYXIoKTtcbiAgICAgICAgICAgIHRoaXMub25FcnJvci5jbGVhcigpO1xuICAgICAgICAgICAgdGhpcy5vbkxlYXZlLmNsZWFyKCk7XG4gICAgICAgICAgICB0aGlzLm9uTWVzc2FnZUhhbmRsZXJzLmV2ZW50cyA9IHt9O1xuICAgICAgICB9O1xuICAgICAgICBSb29tLnByb3RvdHlwZS5vbk1lc3NhZ2VDYWxsYmFjayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIGJ5dGVzID0gQXJyYXkuZnJvbShuZXcgVWludDhBcnJheShldmVudC5kYXRhKSk7XG4gICAgICAgICAgICB2YXIgY29kZSA9IGJ5dGVzWzBdO1xuICAgICAgICAgICAgaWYgKGNvZGUgPT09IGV4cG9ydHMuUHJvdG9jb2wuSk9JTl9ST09NKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IDE7XG4gICAgICAgICAgICAgICAgdmFyIHJlY29ubmVjdGlvblRva2VuID0gdXRmOFJlYWQoYnl0ZXMsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IHV0ZjhMZW5ndGgocmVjb25uZWN0aW9uVG9rZW4pO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VyaWFsaXplcklkID0gdXRmOFJlYWQoYnl0ZXMsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IHV0ZjhMZW5ndGgodGhpcy5zZXJpYWxpemVySWQpO1xuICAgICAgICAgICAgICAgIC8vIEluc3RhbnRpYXRlIHNlcmlhbGl6ZXIgaWYgbm90IGxvY2FsbHkgYXZhaWxhYmxlLlxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zZXJpYWxpemVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZXJpYWxpemVyID0gZ2V0U2VyaWFsaXplcih0aGlzLnNlcmlhbGl6ZXJJZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VyaWFsaXplciA9IG5ldyBzZXJpYWxpemVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggPiBvZmZzZXQgJiYgdGhpcy5zZXJpYWxpemVyLmhhbmRzaGFrZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlcmlhbGl6ZXIuaGFuZHNoYWtlKGJ5dGVzLCB7IG9mZnNldDogb2Zmc2V0IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnJlY29ubmVjdGlvblRva2VuID0gXCJcIi5jb25jYXQodGhpcy5yb29tSWQsIFwiOlwiKS5jb25jYXQocmVjb25uZWN0aW9uVG9rZW4pO1xuICAgICAgICAgICAgICAgIHRoaXMuaGFzSm9pbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uSm9pbi5pbnZva2UoKTtcbiAgICAgICAgICAgICAgICAvLyBhY2tub3dsZWRnZSBzdWNjZXNzZnVsbCBKT0lOX1JPT01cbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb24uc2VuZChbZXhwb3J0cy5Qcm90b2NvbC5KT0lOX1JPT01dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvZGUgPT09IGV4cG9ydHMuUHJvdG9jb2wuRVJST1IpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRfMSA9IHsgb2Zmc2V0OiAxIH07XG4gICAgICAgICAgICAgICAgdmFyIGNvZGVfMSA9IHVtZC5kZWNvZGUubnVtYmVyKGJ5dGVzLCBpdF8xKTtcbiAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IHVtZC5kZWNvZGUuc3RyaW5nKGJ5dGVzLCBpdF8xKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uRXJyb3IuaW52b2tlKGNvZGVfMSwgbWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb2RlID09PSBleHBvcnRzLlByb3RvY29sLkxFQVZFX1JPT00pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxlYXZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb2RlID09PSBleHBvcnRzLlByb3RvY29sLlJPT01fREFUQV9TQ0hFTUEpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRfMiA9IHsgb2Zmc2V0OiAxIH07XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRleHRfMSA9IHRoaXMuc2VyaWFsaXplci5nZXRTdGF0ZSgpLmNvbnN0cnVjdG9yLl9jb250ZXh0O1xuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gY29udGV4dF8xLmdldCh1bWQuZGVjb2RlLm51bWJlcihieXRlcywgaXRfMikpO1xuICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3IHR5cGUoKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmRlY29kZShieXRlcywgaXRfMik7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaE1lc3NhZ2UodHlwZSwgbWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb2RlID09PSBleHBvcnRzLlByb3RvY29sLlJPT01fU1RBVEUpIHtcbiAgICAgICAgICAgICAgICBieXRlcy5zaGlmdCgpOyAvLyBkcm9wIGBjb2RlYCBieXRlXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZShieXRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb2RlID09PSBleHBvcnRzLlByb3RvY29sLlJPT01fU1RBVEVfUEFUQ0gpIHtcbiAgICAgICAgICAgICAgICBieXRlcy5zaGlmdCgpOyAvLyBkcm9wIGBjb2RlYCBieXRlXG4gICAgICAgICAgICAgICAgdGhpcy5wYXRjaChieXRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb2RlID09PSBleHBvcnRzLlByb3RvY29sLlJPT01fREFUQSkge1xuICAgICAgICAgICAgICAgIHZhciBpdF8zID0geyBvZmZzZXQ6IDEgfTtcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9ICh1bWQuZGVjb2RlLnN0cmluZ0NoZWNrKGJ5dGVzLCBpdF8zKSlcbiAgICAgICAgICAgICAgICAgICAgPyB1bWQuZGVjb2RlLnN0cmluZyhieXRlcywgaXRfMylcbiAgICAgICAgICAgICAgICAgICAgOiB1bWQuZGVjb2RlLm51bWJlcihieXRlcywgaXRfMyk7XG4gICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSAoYnl0ZXMubGVuZ3RoID4gaXRfMy5vZmZzZXQpXG4gICAgICAgICAgICAgICAgICAgID8gZGVjb2RlKGV2ZW50LmRhdGEsIGl0XzMub2Zmc2V0KVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoTWVzc2FnZSh0eXBlLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvZGUgPT09IGV4cG9ydHMuUHJvdG9jb2wuUk9PTV9EQVRBX0JZVEVTKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0XzQgPSB7IG9mZnNldDogMSB9O1xuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gKHVtZC5kZWNvZGUuc3RyaW5nQ2hlY2soYnl0ZXMsIGl0XzQpKVxuICAgICAgICAgICAgICAgICAgICA/IHVtZC5kZWNvZGUuc3RyaW5nKGJ5dGVzLCBpdF80KVxuICAgICAgICAgICAgICAgICAgICA6IHVtZC5kZWNvZGUubnVtYmVyKGJ5dGVzLCBpdF80KTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoTWVzc2FnZSh0eXBlLCBuZXcgVWludDhBcnJheShieXRlcy5zbGljZShpdF80Lm9mZnNldCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgUm9vbS5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAoZW5jb2RlZFN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLnNlcmlhbGl6ZXIuc2V0U3RhdGUoZW5jb2RlZFN0YXRlKTtcbiAgICAgICAgICAgIHRoaXMub25TdGF0ZUNoYW5nZS5pbnZva2UodGhpcy5zZXJpYWxpemVyLmdldFN0YXRlKCkpO1xuICAgICAgICB9O1xuICAgICAgICBSb29tLnByb3RvdHlwZS5wYXRjaCA9IGZ1bmN0aW9uIChiaW5hcnlQYXRjaCkge1xuICAgICAgICAgICAgdGhpcy5zZXJpYWxpemVyLnBhdGNoKGJpbmFyeVBhdGNoKTtcbiAgICAgICAgICAgIHRoaXMub25TdGF0ZUNoYW5nZS5pbnZva2UodGhpcy5zZXJpYWxpemVyLmdldFN0YXRlKCkpO1xuICAgICAgICB9O1xuICAgICAgICBSb29tLnByb3RvdHlwZS5kaXNwYXRjaE1lc3NhZ2UgPSBmdW5jdGlvbiAodHlwZSwgbWVzc2FnZSkge1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2VUeXBlID0gdGhpcy5nZXRNZXNzYWdlSGFuZGxlcktleSh0eXBlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9uTWVzc2FnZUhhbmRsZXJzLmV2ZW50c1ttZXNzYWdlVHlwZV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uTWVzc2FnZUhhbmRsZXJzLmVtaXQobWVzc2FnZVR5cGUsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5vbk1lc3NhZ2VIYW5kbGVycy5ldmVudHNbJyonXSkge1xuICAgICAgICAgICAgICAgIHRoaXMub25NZXNzYWdlSGFuZGxlcnMuZW1pdCgnKicsIHR5cGUsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiY29seXNldXMuanM6IG9uTWVzc2FnZSgpIG5vdCByZWdpc3RlcmVkIGZvciB0eXBlICdcIi5jb25jYXQodHlwZSwgXCInLlwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFJvb20ucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zZXJpYWxpemVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXJpYWxpemVyLnRlYXJkb3duKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFJvb20ucHJvdG90eXBlLmdldE1lc3NhZ2VIYW5kbGVyS2V5ID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mICh0eXBlKSkge1xuICAgICAgICAgICAgICAgIC8vIHR5cGVvZiBTY2hlbWFcbiAgICAgICAgICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjogcmV0dXJuIFwiJFwiLmNvbmNhdCh0eXBlLl90eXBlaWQpO1xuICAgICAgICAgICAgICAgIC8vIHN0cmluZ1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjogcmV0dXJuIHR5cGU7XG4gICAgICAgICAgICAgICAgLy8gbnVtYmVyXG4gICAgICAgICAgICAgICAgY2FzZSBcIm51bWJlclwiOiByZXR1cm4gXCJpXCIuY29uY2F0KHR5cGUpO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcihcImludmFsaWQgbWVzc2FnZSB0eXBlLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFJvb207XG4gICAgfSgpKTtcblxuICAgIHZhciBfYTtcbiAgICB2YXIgTWF0Y2hNYWtlRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhNYXRjaE1ha2VFcnJvciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gTWF0Y2hNYWtlRXJyb3IobWVzc2FnZSwgY29kZSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbWVzc2FnZSkgfHwgdGhpcztcbiAgICAgICAgICAgIF90aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBNYXRjaE1ha2VFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNYXRjaE1ha2VFcnJvcjtcbiAgICB9KEVycm9yKSk7XG4gICAgLy8gLSBSZWFjdCBOYXRpdmUgZG9lcyBub3QgcHJvdmlkZSBgd2luZG93LmxvY2F0aW9uYFxuICAgIC8vIC0gQ29jb3MgQ3JlYXRvciAoTmF0aXZlKSBkb2VzIG5vdCBwcm92aWRlIGB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWVgXG4gICAgdmFyIERFRkFVTFRfRU5EUE9JTlQgPSAodHlwZW9mICh3aW5kb3cpICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiAoKF9hID0gd2luZG93ID09PSBudWxsIHx8IHdpbmRvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2luZG93LmxvY2F0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaG9zdG5hbWUpICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICA/IFwiXCIuY29uY2F0KHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbC5yZXBsYWNlKFwiaHR0cFwiLCBcIndzXCIpLCBcIi8vXCIpLmNvbmNhdCh3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUpLmNvbmNhdCgod2luZG93LmxvY2F0aW9uLnBvcnQgJiYgXCI6XCIuY29uY2F0KHdpbmRvdy5sb2NhdGlvbi5wb3J0KSkpXG4gICAgICAgIDogXCJ3czovLzEyNy4wLjAuMToyNTY3XCI7XG4gICAgdmFyIENsaWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQ2xpZW50KHNldHRpbmdzKSB7XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MgPT09IHZvaWQgMCkgeyBzZXR0aW5ncyA9IERFRkFVTFRfRU5EUE9JTlQ7IH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgKHNldHRpbmdzKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gZW5kcG9pbnQgYnkgdXJsXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICB2YXIgdXJsID0gbmV3IFVSTChzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgdmFyIHNlY3VyZSA9ICh1cmwucHJvdG9jb2wgPT09IFwiaHR0cHM6XCIgfHwgdXJsLnByb3RvY29sID09PSBcIndzczpcIik7XG4gICAgICAgICAgICAgICAgdmFyIHBvcnQgPSBOdW1iZXIodXJsLnBvcnQgfHwgKHNlY3VyZSA/IDQ0MyA6IDgwKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncyA9IHtcbiAgICAgICAgICAgICAgICAgICAgaG9zdG5hbWU6IHVybC5ob3N0bmFtZSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWU6IHVybC5wYXRobmFtZSAhPT0gXCIvXCIgPyB1cmwucGF0aG5hbWUgOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICBwb3J0OiBwb3J0LFxuICAgICAgICAgICAgICAgICAgICBzZWN1cmU6IHNlY3VyZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIGVuZHBvaW50IGJ5IHNldHRpbmdzXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MucG9ydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnBvcnQgPSAoc2V0dGluZ3Muc2VjdXJlKSA/IDQ0MyA6IDgwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MucGF0aG5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5wYXRobmFtZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBDbGllbnQucHJvdG90eXBlLmpvaW5PckNyZWF0ZSA9IGZ1bmN0aW9uIChyb29tTmFtZSwgb3B0aW9ucywgcm9vdFNjaGVtYSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5jcmVhdGVNYXRjaE1ha2VSZXF1ZXN0KCdqb2luT3JDcmVhdGUnLCByb29tTmFtZSwgb3B0aW9ucywgcm9vdFNjaGVtYSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIENsaWVudC5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKHJvb21OYW1lLCBvcHRpb25zLCByb290U2NoZW1hKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmNyZWF0ZU1hdGNoTWFrZVJlcXVlc3QoJ2NyZWF0ZScsIHJvb21OYW1lLCBvcHRpb25zLCByb290U2NoZW1hKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgQ2xpZW50LnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gKHJvb21OYW1lLCBvcHRpb25zLCByb290U2NoZW1hKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmNyZWF0ZU1hdGNoTWFrZVJlcXVlc3QoJ2pvaW4nLCByb29tTmFtZSwgb3B0aW9ucywgcm9vdFNjaGVtYSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIENsaWVudC5wcm90b3R5cGUuam9pbkJ5SWQgPSBmdW5jdGlvbiAocm9vbUlkLCBvcHRpb25zLCByb290U2NoZW1hKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmNyZWF0ZU1hdGNoTWFrZVJlcXVlc3QoJ2pvaW5CeUlkJywgcm9vbUlkLCBvcHRpb25zLCByb290U2NoZW1hKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlLWVzdGFibGlzaCBjb25uZWN0aW9uIHdpdGggYSByb29tIHRoaXMgY2xpZW50IHdhcyBwcmV2aW91c2x5IGNvbm5lY3RlZCB0by5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHJlY29ubmVjdGlvblRva2VuIFRoZSBgcm9vbS5yZWNvbm5lY3Rpb25Ub2tlbmAgZnJvbSBwcmV2aW91c2x5IGNvbm5lY3RlZCByb29tLlxuICAgICAgICAgKiBAcGFyYW0gcm9vdFNjaGVtYSAob3B0aW9uYWwpIENvbmNyZXRlIHJvb3Qgc2NoZW1hIGRlZmluaXRpb25cbiAgICAgICAgICogQHJldHVybnMgUHJvbWlzZTxSb29tPlxuICAgICAgICAgKi9cbiAgICAgICAgQ2xpZW50LnByb3RvdHlwZS5yZWNvbm5lY3QgPSBmdW5jdGlvbiAocmVjb25uZWN0aW9uVG9rZW4sIHJvb3RTY2hlbWEpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIHJvb21JZCwgdG9rZW47XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAocmVjb25uZWN0aW9uVG9rZW4pID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiAocm9vdFNjaGVtYSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiREVQUkVDQVRFRDogLnJlY29ubmVjdCgpIG5vdyBvbmx5IGFjY2VwdHMgJ3JlY29ubmVjdGlvblRva2VuJyBhcyBhcmd1bWVudC5cXG5Zb3UgY2FuIGdldCB0aGlzIHRva2VuIGZyb20gcHJldmlvdXNseSBjb25uZWN0ZWQgYHJvb20ucmVjb25uZWN0aW9uVG9rZW5gXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYSA9IHJlY29ubmVjdGlvblRva2VuLnNwbGl0KFwiOlwiKSwgcm9vbUlkID0gX2FbMF0sIHRva2VuID0gX2FbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5jcmVhdGVNYXRjaE1ha2VSZXF1ZXN0KCdyZWNvbm5lY3QnLCByb29tSWQsIHsgcmVjb25uZWN0aW9uVG9rZW46IHRva2VuIH0sIHJvb3RTY2hlbWEpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9iLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBDbGllbnQucHJvdG90eXBlLmdldEF2YWlsYWJsZVJvb21zID0gZnVuY3Rpb24gKHJvb21OYW1lKSB7XG4gICAgICAgICAgICBpZiAocm9vbU5hbWUgPT09IHZvaWQgMCkgeyByb29tTmFtZSA9IFwiXCI7IH1cbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgZ2V0XzEodGhpcy5nZXRIdHRwRW5kcG9pbnQoXCJcIi5jb25jYXQocm9vbU5hbWUpKSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCAoX2Euc2VudCgpKS5kYXRhXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIENsaWVudC5wcm90b3R5cGUuY29uc3VtZVNlYXRSZXNlcnZhdGlvbiA9IGZ1bmN0aW9uIChyZXNwb25zZSwgcm9vdFNjaGVtYSwgcmV1c2VSb29tSW5zdGFuY2UgLy8gdXNlZCBpbiBkZXZNb2RlXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciByb29tLCBvcHRpb25zLCB0YXJnZXRSb29tO1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICByb29tID0gdGhpcy5jcmVhdGVSb29tKHJlc3BvbnNlLnJvb20ubmFtZSwgcm9vdFNjaGVtYSk7XG4gICAgICAgICAgICAgICAgICAgIHJvb20ucm9vbUlkID0gcmVzcG9uc2Uucm9vbS5yb29tSWQ7XG4gICAgICAgICAgICAgICAgICAgIHJvb20uc2Vzc2lvbklkID0gcmVzcG9uc2Uuc2Vzc2lvbklkO1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0geyBzZXNzaW9uSWQ6IHJvb20uc2Vzc2lvbklkIH07XG4gICAgICAgICAgICAgICAgICAgIC8vIGZvcndhcmQgXCJyZWNvbm5lY3Rpb24gdG9rZW5cIiBpbiBjYXNlIG9mIHJlY29ubmVjdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnJlY29ubmVjdGlvblRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnJlY29ubmVjdGlvblRva2VuID0gcmVzcG9uc2UucmVjb25uZWN0aW9uVG9rZW47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Um9vbSA9IHJldXNlUm9vbUluc3RhbmNlIHx8IHJvb207XG4gICAgICAgICAgICAgICAgICAgIHJvb20uY29ubmVjdCh0aGlzLmJ1aWxkRW5kcG9pbnQocmVzcG9uc2Uucm9vbSwgb3B0aW9ucyksIHJlc3BvbnNlLmRldk1vZGUgJiYgKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXRyeUNvdW50LCByZXRyeU1heFJldHJpZXMsIHJldHJ5UmVjb25uZWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oXCJbQ29seXNldXMgZGV2TW9kZV06IFwiLmNvbmNhdChTdHJpbmcuZnJvbUNvZGVQb2ludCgweDFGNTA0KSwgXCIgUmUtZXN0YWJsaXNoaW5nIGNvbm5lY3Rpb24gd2l0aCByb29tIGlkICdcIikuY29uY2F0KHJvb20ucm9vbUlkLCBcIicuLi5cIikpOyAvLyDwn5SEXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0cnlDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0cnlNYXhSZXRyaWVzID0gODtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXRyeVJlY29ubmVjdGlvbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0cnlDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzEsIDMsICwgNF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmNvbnN1bWVTZWF0UmVzZXJ2YXRpb24ocmVzcG9uc2UsIHJvb3RTY2hlbWEsIHRhcmdldFJvb20pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiW0NvbHlzZXVzIGRldk1vZGVdOiBcIi5jb25jYXQoU3RyaW5nLmZyb21Db2RlUG9pbnQoMHgyNzA1KSwgXCIgU3VjY2Vzc2Z1bGx5IHJlLWVzdGFibGlzaGVkIGNvbm5lY3Rpb24gd2l0aCByb29tICdcIikuY29uY2F0KHJvb20ucm9vbUlkLCBcIidcIikpOyAvLyDinIVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXRyeUNvdW50IDwgcmV0cnlNYXhSZXRyaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oXCJbQ29seXNldXMgZGV2TW9kZV06IFwiLmNvbmNhdChTdHJpbmcuZnJvbUNvZGVQb2ludCgweDFGNTA0KSwgXCIgcmV0cnlpbmcuLi4gKFwiKS5jb25jYXQocmV0cnlDb3VudCwgXCIgb3V0IG9mIFwiKS5jb25jYXQocmV0cnlNYXhSZXRyaWVzLCBcIilcIikpOyAvLyDwn5SEXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHJldHJ5UmVjb25uZWN0aW9uLCAyMDAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIltDb2x5c2V1cyBkZXZNb2RlXTogXCIuY29uY2F0KFN0cmluZy5mcm9tQ29kZVBvaW50KDB4Mjc0QyksIFwiIEZhaWxlZCB0byByZWNvbm5lY3QuIElzIHlvdXIgc2VydmVyIHJ1bm5pbmc/IFBsZWFzZSBjaGVjayBzZXJ2ZXIgbG9ncy5cIikpOyAvLyDinYxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7IH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChyZXRyeVJlY29ubmVjdGlvbiwgMjAwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pOyB9KSwgdGFyZ2V0Um9vbSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9uRXJyb3IgPSBmdW5jdGlvbiAoY29kZSwgbWVzc2FnZSkgeyByZXR1cm4gcmVqZWN0KG5ldyBTZXJ2ZXJFcnJvcihjb2RlLCBtZXNzYWdlKSk7IH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Um9vbS5vbkVycm9yLm9uY2Uob25FcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Um9vbVsnb25Kb2luJ10ub25jZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFJvb20ub25FcnJvci5yZW1vdmUob25FcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodGFyZ2V0Um9vbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgQ2xpZW50LnByb3RvdHlwZS5jcmVhdGVNYXRjaE1ha2VSZXF1ZXN0ID0gZnVuY3Rpb24gKG1ldGhvZCwgcm9vbU5hbWUsIG9wdGlvbnMsIHJvb3RTY2hlbWEsIHJldXNlUm9vbUluc3RhbmNlKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciByZXNwb25zZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgcG9zdF8xKHRoaXMuZ2V0SHR0cEVuZHBvaW50KFwiXCIuY29uY2F0KG1ldGhvZCwgXCIvXCIpLmNvbmNhdChyb29tTmFtZSkpLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gKF9hLnNlbnQoKSkuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE1hdGNoTWFrZUVycm9yKHJlc3BvbnNlLmVycm9yLCByZXNwb25zZS5jb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9yd2FyZCByZWNvbm5lY3Rpb24gdG9rZW4gZHVyaW5nIFwicmVjb25uZWN0XCIgbWV0aG9kcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kID09PSBcInJlY29ubmVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnJlY29ubmVjdGlvblRva2VuID0gb3B0aW9ucy5yZWNvbm5lY3Rpb25Ub2tlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5jb25zdW1lU2VhdFJlc2VydmF0aW9uKHJlc3BvbnNlLCByb290U2NoZW1hLCByZXVzZVJvb21JbnN0YW5jZSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIENsaWVudC5wcm90b3R5cGUuY3JlYXRlUm9vbSA9IGZ1bmN0aW9uIChyb29tTmFtZSwgcm9vdFNjaGVtYSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSb29tKHJvb21OYW1lLCByb290U2NoZW1hKTtcbiAgICAgICAgfTtcbiAgICAgICAgQ2xpZW50LnByb3RvdHlwZS5idWlsZEVuZHBvaW50ID0gZnVuY3Rpb24gKHJvb20sIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgICAgICB2YXIgcGFyYW1zID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBuYW1lXzEgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShuYW1lXzEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJhbXMucHVzaChcIlwiLmNvbmNhdChuYW1lXzEsIFwiPVwiKS5jb25jYXQob3B0aW9uc1tuYW1lXzFdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZW5kcG9pbnQgPSAodGhpcy5zZXR0aW5ncy5zZWN1cmUpXG4gICAgICAgICAgICAgICAgPyBcIndzczovL1wiXG4gICAgICAgICAgICAgICAgOiBcIndzOi8vXCI7XG4gICAgICAgICAgICBpZiAocm9vbS5wdWJsaWNBZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgZW5kcG9pbnQgKz0gXCJcIi5jb25jYXQocm9vbS5wdWJsaWNBZGRyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVuZHBvaW50ICs9IFwiXCIuY29uY2F0KHRoaXMuc2V0dGluZ3MuaG9zdG5hbWUpLmNvbmNhdCh0aGlzLmdldEVuZHBvaW50UG9ydCgpKS5jb25jYXQodGhpcy5zZXR0aW5ncy5wYXRobmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQoZW5kcG9pbnQsIFwiL1wiKS5jb25jYXQocm9vbS5wcm9jZXNzSWQsIFwiL1wiKS5jb25jYXQocm9vbS5yb29tSWQsIFwiP1wiKS5jb25jYXQocGFyYW1zLmpvaW4oJyYnKSk7XG4gICAgICAgIH07XG4gICAgICAgIENsaWVudC5wcm90b3R5cGUuZ2V0SHR0cEVuZHBvaW50ID0gZnVuY3Rpb24gKHNlZ21lbnRzKSB7XG4gICAgICAgICAgICBpZiAoc2VnbWVudHMgPT09IHZvaWQgMCkgeyBzZWdtZW50cyA9ICcnOyB9XG4gICAgICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQoKHRoaXMuc2V0dGluZ3Muc2VjdXJlKSA/IFwiaHR0cHNcIiA6IFwiaHR0cFwiLCBcIjovL1wiKS5jb25jYXQodGhpcy5zZXR0aW5ncy5ob3N0bmFtZSkuY29uY2F0KHRoaXMuZ2V0RW5kcG9pbnRQb3J0KCkpLmNvbmNhdCh0aGlzLnNldHRpbmdzLnBhdGhuYW1lLCBcIi9tYXRjaG1ha2UvXCIpLmNvbmNhdChzZWdtZW50cyk7XG4gICAgICAgIH07XG4gICAgICAgIENsaWVudC5wcm90b3R5cGUuZ2V0RW5kcG9pbnRQb3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLnNldHRpbmdzLnBvcnQgIT09IDgwICYmIHRoaXMuc2V0dGluZ3MucG9ydCAhPT0gNDQzKVxuICAgICAgICAgICAgICAgID8gXCI6XCIuY29uY2F0KHRoaXMuc2V0dGluZ3MucG9ydClcbiAgICAgICAgICAgICAgICA6IFwiXCI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBDbGllbnQ7XG4gICAgfSgpKTtcblxuICAgIC8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi90eXBpbmdzL2NvY29zLWNyZWF0b3IuZC50c1wiIC8+XG4gICAgLyoqXG4gICAgICogV2UgZG8gbm90IGFzc2lnbiAnc3RvcmFnZScgdG8gd2luZG93LmxvY2FsU3RvcmFnZSBpbW1lZGlhdGVsbHkgZm9yIFJlYWN0XG4gICAgICogTmF0aXZlIGNvbXBhdGliaWxpdHkuIHdpbmRvdy5sb2NhbFN0b3JhZ2UgaXMgbm90IHByZXNlbnQgd2hlbiB0aGlzIG1vZHVsZSBpc1xuICAgICAqIGxvYWRlZC5cbiAgICAgKi9cbiAgICB2YXIgc3RvcmFnZTtcbiAgICBmdW5jdGlvbiBnZXRTdG9yYWdlKCkge1xuICAgICAgICBpZiAoIXN0b3JhZ2UpIHtcbiAgICAgICAgICAgIHN0b3JhZ2UgPSAodHlwZW9mIChjYykgIT09ICd1bmRlZmluZWQnICYmIGNjLnN5cyAmJiBjYy5zeXMubG9jYWxTdG9yYWdlKVxuICAgICAgICAgICAgICAgID8gY2Muc3lzLmxvY2FsU3RvcmFnZSAvLyBjb21wYXRpYmlsaXR5IHdpdGggY29jb3MgY3JlYXRvclxuICAgICAgICAgICAgICAgIDogdHlwZW9mICh3aW5kb3cpICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5sb2NhbFN0b3JhZ2UgLy9STiBkb2VzIGhhdmUgd2luZG93IG9iamVjdCBhdCB0aGlzIHBvaW50LCBidXQgbG9jYWxTdG9yYWdlIGlzIG5vdCBkZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgID8gd2luZG93LmxvY2FsU3RvcmFnZSAvLyByZWd1bGFyIGJyb3dzZXIgZW52aXJvbm1lbnRcbiAgICAgICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZToge30sXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRJdGVtOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkgeyB0aGlzLmNhY2hlW2tleV0gPSB2YWx1ZTsgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldEl0ZW06IGZ1bmN0aW9uIChrZXkpIHsgdGhpcy5jYWNoZVtrZXldOyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlSXRlbTogZnVuY3Rpb24gKGtleSkgeyBkZWxldGUgdGhpcy5jYWNoZVtrZXldOyB9LFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdG9yYWdlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRJdGVtKGtleSwgdmFsdWUpIHtcbiAgICAgICAgZ2V0U3RvcmFnZSgpLnNldEl0ZW0oa2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbW92ZUl0ZW0oa2V5KSB7XG4gICAgICAgIGdldFN0b3JhZ2UoKS5yZW1vdmVJdGVtKGtleSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEl0ZW0oa2V5LCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgdmFsdWUgPSBnZXRTdG9yYWdlKCkuZ2V0SXRlbShrZXkpO1xuICAgICAgICBpZiAodHlwZW9mIChQcm9taXNlKSA9PT0gJ3VuZGVmaW5lZCcgfHwgLy8gb2xkIGJyb3dzZXJzXG4gICAgICAgICAgICAhKHZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkpIHtcbiAgICAgICAgICAgIC8vIGJyb3dzZXIgaGFzIHN5bmNocm9ub3VzIHJldHVyblxuICAgICAgICAgICAgY2FsbGJhY2sodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gcmVhY3QtbmF0aXZlIGlzIGFzeW5jaHJvbm91c1xuICAgICAgICAgICAgdmFsdWUudGhlbihmdW5jdGlvbiAoaWQpIHsgcmV0dXJuIGNhbGxiYWNrKGlkKTsgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgVE9LRU5fU1RPUkFHRSA9IFwiY29seXNldXMtYXV0aC10b2tlblwiO1xuICAgIGV4cG9ydHMuUGxhdGZvcm0gPSB2b2lkIDA7XG4gICAgKGZ1bmN0aW9uIChQbGF0Zm9ybSkge1xuICAgICAgICBQbGF0Zm9ybVtcImlvc1wiXSA9IFwiaW9zXCI7XG4gICAgICAgIFBsYXRmb3JtW1wiYW5kcm9pZFwiXSA9IFwiYW5kcm9pZFwiO1xuICAgIH0pKGV4cG9ydHMuUGxhdGZvcm0gfHwgKGV4cG9ydHMuUGxhdGZvcm0gPSB7fSkpO1xuICAgIHZhciBBdXRoID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBBdXRoKGVuZHBvaW50KSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5faWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLnVzZXJuYW1lID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5kaXNwbGF5TmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuYXZhdGFyVXJsID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5pc0Fub255bW91cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuZW1haWwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLmxhbmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLmxvY2F0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy50aW1lem9uZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMubWV0YWRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLmRldmljZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLmZhY2Vib29rSWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLnR3aXR0ZXJJZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuZ29vZ2xlSWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLmdhbWVDZW50ZXJJZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuc3RlYW1JZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuZnJpZW5kSWRzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5ibG9ja2VkVXNlcklkcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlZEF0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVkQXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAvLyBhdXRoIHRva2VuXG4gICAgICAgICAgICB0aGlzLnRva2VuID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5lbmRwb2ludCA9IGVuZHBvaW50LnJlcGxhY2UoXCJ3c1wiLCBcImh0dHBcIik7XG4gICAgICAgICAgICBnZXRJdGVtKFRPS0VOX1NUT1JBR0UsIGZ1bmN0aW9uICh0b2tlbikgeyByZXR1cm4gX3RoaXMudG9rZW4gPSB0b2tlbjsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEF1dGgucHJvdG90eXBlLCBcImhhc1Rva2VuXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhIXRoaXMudG9rZW47XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIEF1dGgucHJvdG90eXBlLmxvZ2luID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHF1ZXJ5UGFyYW1zLCBkYXRhLCBhdHRyO1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzVG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlQYXJhbXMudG9rZW4gPSB0aGlzLnRva2VuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnJlcXVlc3QoJ3Bvc3QnLCAnL2F1dGgnLCBxdWVyeVBhcmFtcyldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0ICYgY2FjaGUgdG9rZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRva2VuID0gZGF0YS50b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRJdGVtKFRPS0VOX1NUT1JBR0UsIHRoaXMudG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoYXR0ciBpbiBkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc093blByb3BlcnR5KGF0dHIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2F0dHJdID0gZGF0YVthdHRyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZ2lzdGVyUGluZ1NlcnZpY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpc107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBBdXRoLnByb3RvdHlwZS5zYXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnJlcXVlc3QoJ3B1dCcsICcvYXV0aCcsIHt9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJuYW1lOiB0aGlzLnVzZXJuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5TmFtZTogdGhpcy5kaXNwbGF5TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXZhdGFyVXJsOiB0aGlzLmF2YXRhclVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFuZzogdGhpcy5sYW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbjogdGhpcy5sb2NhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZXpvbmU6IHRoaXMudGltZXpvbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpc107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBBdXRoLnByb3RvdHlwZS5nZXRGcmllbmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnJlcXVlc3QoJ2dldCcsICcvZnJpZW5kcy9hbGwnKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCAoX2Euc2VudCgpKV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBBdXRoLnByb3RvdHlwZS5nZXRPbmxpbmVGcmllbmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnJlcXVlc3QoJ2dldCcsICcvZnJpZW5kcy9vbmxpbmUnKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCAoX2Euc2VudCgpKV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBBdXRoLnByb3RvdHlwZS5nZXRGcmllbmRSZXF1ZXN0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5yZXF1ZXN0KCdnZXQnLCAnL2ZyaWVuZHMvcmVxdWVzdHMnKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCAoX2Euc2VudCgpKV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBBdXRoLnByb3RvdHlwZS5zZW5kRnJpZW5kUmVxdWVzdCA9IGZ1bmN0aW9uIChmcmllbmRJZCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnJlcXVlc3QoJ3Bvc3QnLCAnL2ZyaWVuZHMvcmVxdWVzdHMnLCB7IHVzZXJJZDogZnJpZW5kSWQgfSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgKF9hLnNlbnQoKSldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgQXV0aC5wcm90b3R5cGUuYWNjZXB0RnJpZW5kUmVxdWVzdCA9IGZ1bmN0aW9uIChmcmllbmRJZCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnJlcXVlc3QoJ3B1dCcsICcvZnJpZW5kcy9yZXF1ZXN0cycsIHsgdXNlcklkOiBmcmllbmRJZCB9KV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCAoX2Euc2VudCgpKV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBBdXRoLnByb3RvdHlwZS5kZWNsaW5lRnJpZW5kUmVxdWVzdCA9IGZ1bmN0aW9uIChmcmllbmRJZCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnJlcXVlc3QoJ2RlbCcsICcvZnJpZW5kcy9yZXF1ZXN0cycsIHsgdXNlcklkOiBmcmllbmRJZCB9KV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCAoX2Euc2VudCgpKV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBBdXRoLnByb3RvdHlwZS5ibG9ja1VzZXIgPSBmdW5jdGlvbiAoZnJpZW5kSWQpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5yZXF1ZXN0KCdwb3N0JywgJy9mcmllbmRzL2Jsb2NrJywgeyB1c2VySWQ6IGZyaWVuZElkIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIChfYS5zZW50KCkpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIEF1dGgucHJvdG90eXBlLnVuYmxvY2tVc2VyID0gZnVuY3Rpb24gKGZyaWVuZElkKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucmVxdWVzdCgncHV0JywgJy9mcmllbmRzL2Jsb2NrJywgeyB1c2VySWQ6IGZyaWVuZElkIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIChfYS5zZW50KCkpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIEF1dGgucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiAobWV0aG9kLCBzZWdtZW50cywgcXVlcnksIGJvZHksIGhlYWRlcnMpIHtcbiAgICAgICAgICAgIGlmIChxdWVyeSA9PT0gdm9pZCAwKSB7IHF1ZXJ5ID0ge307IH1cbiAgICAgICAgICAgIGlmIChoZWFkZXJzID09PSB2b2lkIDApIHsgaGVhZGVycyA9IHt9OyB9XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHF1ZXJ5UGFyYW1zLCBuYW1lXzEsIHF1ZXJ5U3RyaW5nLCBvcHRzO1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnNbJ0FjY2VwdCddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc1Rva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnNbJ0F1dGhvcml6YXRpb24nXSA9ICdCZWFyZXIgJyArIHRoaXMudG9rZW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChuYW1lXzEgaW4gcXVlcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlQYXJhbXMucHVzaChcIlwiLmNvbmNhdChuYW1lXzEsIFwiPVwiKS5jb25jYXQocXVlcnlbbmFtZV8xXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeVN0cmluZyA9IChxdWVyeVBhcmFtcy5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IFwiP1wiLmNvbmNhdChxdWVyeVBhcmFtcy5qb2luKFwiJlwiKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRzID0geyBoZWFkZXJzOiBoZWFkZXJzIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0cy5ib2R5ID0gYm9keTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgaHR0cFttZXRob2RdKFwiXCIuY29uY2F0KHRoaXMuZW5kcG9pbnQpLmNvbmNhdChzZWdtZW50cykuY29uY2F0KHF1ZXJ5U3RyaW5nKSwgb3B0cyldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgKF9hLnNlbnQoKSkuZGF0YV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBBdXRoLnByb3RvdHlwZS5sb2dvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnRva2VuID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmVtb3ZlSXRlbShUT0tFTl9TVE9SQUdFKTtcbiAgICAgICAgICAgIHRoaXMudW5yZWdpc3RlclBpbmdTZXJ2aWNlKCk7XG4gICAgICAgIH07XG4gICAgICAgIEF1dGgucHJvdG90eXBlLnJlZ2lzdGVyUGluZ1NlcnZpY2UgPSBmdW5jdGlvbiAodGltZW91dCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGlmICh0aW1lb3V0ID09PSB2b2lkIDApIHsgdGltZW91dCA9IDE1MDAwOyB9XG4gICAgICAgICAgICB0aGlzLnVucmVnaXN0ZXJQaW5nU2VydmljZSgpO1xuICAgICAgICAgICAgdGhpcy5rZWVwT25saW5lSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5yZXF1ZXN0KCdnZXQnLCAnL2F1dGgnKTsgfSwgdGltZW91dCk7XG4gICAgICAgIH07XG4gICAgICAgIEF1dGgucHJvdG90eXBlLnVucmVnaXN0ZXJQaW5nU2VydmljZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5rZWVwT25saW5lSW50ZXJ2YWwpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQXV0aDtcbiAgICB9KCkpO1xuXG4gICAgdmFyIFNjaGVtYVNlcmlhbGl6ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFNjaGVtYVNlcmlhbGl6ZXIoKSB7XG4gICAgICAgIH1cbiAgICAgICAgU2NoZW1hU2VyaWFsaXplci5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAocmF3U3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmRlY29kZShyYXdTdGF0ZSk7XG4gICAgICAgIH07XG4gICAgICAgIFNjaGVtYVNlcmlhbGl6ZXIucHJvdG90eXBlLmdldFN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGU7XG4gICAgICAgIH07XG4gICAgICAgIFNjaGVtYVNlcmlhbGl6ZXIucHJvdG90eXBlLnBhdGNoID0gZnVuY3Rpb24gKHBhdGNoZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmRlY29kZShwYXRjaGVzKTtcbiAgICAgICAgfTtcbiAgICAgICAgU2NoZW1hU2VyaWFsaXplci5wcm90b3R5cGUudGVhcmRvd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgKF9iID0gKF9hID0gdGhpcy5zdGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWyckY2hhbmdlcyddKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iucm9vdC5jbGVhclJlZnMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgU2NoZW1hU2VyaWFsaXplci5wcm90b3R5cGUuaGFuZHNoYWtlID0gZnVuY3Rpb24gKGJ5dGVzLCBpdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiB2YWxpZGF0ZSBjbGllbnQvc2VydmVyIGRlZmluaXRpbm9zXG4gICAgICAgICAgICAgICAgdmFyIHJlZmxlY3Rpb24gPSBuZXcgdW1kLlJlZmxlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICByZWZsZWN0aW9uLmRlY29kZShieXRlcywgaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gaW5pdGlhbGl6ZSByZWZsZWN0ZWQgc3RhdGUgZnJvbSBzZXJ2ZXJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gdW1kLlJlZmxlY3Rpb24uZGVjb2RlKGJ5dGVzLCBpdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBTY2hlbWFTZXJpYWxpemVyO1xuICAgIH0oKSk7XG5cbiAgICB2YXIgTm9uZVNlcmlhbGl6ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE5vbmVTZXJpYWxpemVyKCkge1xuICAgICAgICB9XG4gICAgICAgIE5vbmVTZXJpYWxpemVyLnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uIChyYXdTdGF0ZSkgeyB9O1xuICAgICAgICBOb25lU2VyaWFsaXplci5wcm90b3R5cGUuZ2V0U3RhdGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgICBOb25lU2VyaWFsaXplci5wcm90b3R5cGUucGF0Y2ggPSBmdW5jdGlvbiAocGF0Y2hlcykgeyB9O1xuICAgICAgICBOb25lU2VyaWFsaXplci5wcm90b3R5cGUudGVhcmRvd24gPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIE5vbmVTZXJpYWxpemVyLnByb3RvdHlwZS5oYW5kc2hha2UgPSBmdW5jdGlvbiAoYnl0ZXMpIHsgfTtcbiAgICAgICAgcmV0dXJuIE5vbmVTZXJpYWxpemVyO1xuICAgIH0oKSk7XG5cbiAgICByZWdpc3RlclNlcmlhbGl6ZXIoJ3NjaGVtYScsIFNjaGVtYVNlcmlhbGl6ZXIpO1xuICAgIHJlZ2lzdGVyU2VyaWFsaXplcignbm9uZScsIE5vbmVTZXJpYWxpemVyKTtcblxuICAgIGV4cG9ydHMuQXV0aCA9IEF1dGg7XG4gICAgZXhwb3J0cy5DbGllbnQgPSBDbGllbnQ7XG4gICAgZXhwb3J0cy5Sb29tID0gUm9vbTtcbiAgICBleHBvcnRzLlNjaGVtYVNlcmlhbGl6ZXIgPSBTY2hlbWFTZXJpYWxpemVyO1xuICAgIGV4cG9ydHMucmVnaXN0ZXJTZXJpYWxpemVyID0gcmVnaXN0ZXJTZXJpYWxpemVyO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29seXNldXMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/colyseus.js/dist/colyseus.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/build/polyfills/process.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/process.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _global_process, _global_process1;\nmodule.exports = ((_global_process = __webpack_require__.g.process) == null ? void 0 : _global_process.env) && typeof ((_global_process1 = __webpack_require__.g.process) == null ? void 0 : _global_process1.env) === \"object\" ? __webpack_require__.g.process : __webpack_require__(/*! ../../compiled/process */ \"(app-client)/./node_modules/next/dist/compiled/process/browser.js\");\n\n//# sourceMappingURL=process.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC9wb2x5ZmlsbHMvcHJvY2Vzcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EscUNBQXFDLHFCQUFNLGlGQUFpRixxQkFBTSxrRUFBa0UscUJBQU0sV0FBVyxtQkFBTyxDQUFDLGlHQUF3Qjs7QUFFclAiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC9wb2x5ZmlsbHMvcHJvY2Vzcy5qcz8xMzhhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9nbG9iYWxfcHJvY2VzcywgX2dsb2JhbF9wcm9jZXNzMTtcbm1vZHVsZS5leHBvcnRzID0gKChfZ2xvYmFsX3Byb2Nlc3MgPSBnbG9iYWwucHJvY2VzcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9nbG9iYWxfcHJvY2Vzcy5lbnYpICYmIHR5cGVvZiAoKF9nbG9iYWxfcHJvY2VzczEgPSBnbG9iYWwucHJvY2VzcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9nbG9iYWxfcHJvY2VzczEuZW52KSA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbC5wcm9jZXNzIDogcmVxdWlyZShcIi4uLy4uL2NvbXBpbGVkL3Byb2Nlc3NcIik7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb2Nlc3MuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/build/polyfills/process.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=G%3A%5Cobject_hunt%5Capp%5Cg%5Cpage.tsx&server=false!":
/*!*******************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=G%3A%5Cobject_hunt%5Capp%5Cg%5Cpage.tsx&server=false! ***!
  \*******************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./app/g/page.tsx */ \"(app-client)/./app/g/page.tsx\"))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1mbGlnaHQtY2xpZW50LWVudHJ5LWxvYWRlci5qcz9tb2R1bGVzPUclM0ElNUNvYmplY3RfaHVudCU1Q2FwcCU1Q2clNUNwYWdlLnRzeCZzZXJ2ZXI9ZmFsc2UhIiwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8/YzlmOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIkc6XFxcXG9iamVjdF9odW50XFxcXGFwcFxcXFxnXFxcXHBhZ2UudHN4XCIpIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=G%3A%5Cobject_hunt%5Capp%5Cg%5Cpage.tsx&server=false!\n"));

/***/ }),

/***/ "(app-client)/./node_modules/react-slideshow-image/dist/styles.css":
/*!************************************************************!*\
  !*** ./node_modules/react-slideshow-image/dist/styles.css ***!
  \************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"354ab52811a6\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXNsaWRlc2hvdy1pbWFnZS9kaXN0L3N0eWxlcy5jc3MiLCJtYXBwaW5ncyI6IjtBQUFBLCtEQUFlLGNBQWM7QUFDN0IsSUFBSSxJQUFVLElBQUksaUJBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1zbGlkZXNob3ctaW1hZ2UvZGlzdC9zdHlsZXMuY3NzP2ZlNmEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCIzNTRhYjUyODExYTZcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/react-slideshow-image/dist/styles.css\n"));

/***/ }),

/***/ "(app-client)/./public/images/not found.png":
/*!*************************************!*\
  !*** ./public/images/not found.png ***!
  \*************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"src\":\"/_next/static/media/not found.dce63206.png\",\"height\":240,\"width\":359,\"blurDataURL\":\"/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fnot+found.dce63206.png&w=8&q=70\",\"blurWidth\":8,\"blurHeight\":5});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vcHVibGljL2ltYWdlcy9ub3QgZm91bmQucG5nIiwibWFwcGluZ3MiOiI7QUFBQSwrREFBZSxDQUFDLHNNQUFzTSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9wdWJsaWMvaW1hZ2VzL25vdCBmb3VuZC5wbmc/ODVjNCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCB7XCJzcmNcIjpcIi9fbmV4dC9zdGF0aWMvbWVkaWEvbm90IGZvdW5kLmRjZTYzMjA2LnBuZ1wiLFwiaGVpZ2h0XCI6MjQwLFwid2lkdGhcIjozNTksXCJibHVyRGF0YVVSTFwiOlwiL19uZXh0L2ltYWdlP3VybD0lMkZfbmV4dCUyRnN0YXRpYyUyRm1lZGlhJTJGbm90K2ZvdW5kLmRjZTYzMjA2LnBuZyZ3PTgmcT03MFwiLFwiYmx1cldpZHRoXCI6OCxcImJsdXJIZWlnaHRcIjo1fTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./public/images/not found.png\n"));

/***/ }),

/***/ "(app-client)/./app/Context/store.tsx":
/*!*******************************!*\
  !*** ./app/Context/store.tsx ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GlobalContextProvider: function() { return /* binding */ GlobalContextProvider; },\n/* harmony export */   useGlobalContext: function() { return /* binding */ useGlobalContext; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-client)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-client)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _components_BGMusic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components/BGMusic */ \"(app-client)/./app/components/BGMusic.tsx\");\n/* __next_internal_client_entry_do_not_use__ GlobalContextProvider,useGlobalContext auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\nconst GlobalContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({\n    ...{}\n});\nconst GlobalContextProvider = (param)=>{\n    let { children } = param;\n    _s();\n    // Game State\n    const remainingState = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(10);\n    const scoreState = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(5);\n    const roundState = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(3);\n    const tabState = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    // Object Detection\n    const isSubmitingState = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const matchedState = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(-1);\n    // User State\n    const username = \"soham\";\n    // const username = window.localStorage.getItem(\"username\") || \"unknown\";\n    const [_BGMusic, _setBGMusic] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const BGMusicState = {\n        state: _BGMusic,\n        toggle: ()=>{\n            _setBGMusic(!_BGMusic);\n        // window.localStorage.setItem(\"bgMusic\", _BGMusic.toString());\n        }\n    };\n    const restartGame = ()=>{\n        remainingState[1](10);\n        // roundState[1](3);\n        isSubmitingState[1](false);\n        matchedState[1](-1);\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(GlobalContext.Provider, {\n        value: {\n            remainingState,\n            scoreState,\n            roundState,\n            isSubmitingState,\n            matchedState,\n            tabState,\n            restartGame,\n            username: username,\n            BGMusicState\n        },\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_BGMusic__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                state: BGMusicState.state\n            }, void 0, false, {\n                fileName: \"G:\\\\object_hunt\\\\app\\\\Context\\\\store.tsx\",\n                lineNumber: 56,\n                columnNumber: 7\n            }, undefined),\n            children\n        ]\n    }, void 0, true, {\n        fileName: \"G:\\\\object_hunt\\\\app\\\\Context\\\\store.tsx\",\n        lineNumber: 43,\n        columnNumber: 5\n    }, undefined);\n};\n_s(GlobalContextProvider, \"CO7LI/xqYJnLoV/f5JWTgG6AhsI=\");\n_c = GlobalContextProvider;\nconst useGlobalContext = ()=>{\n    _s1();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(GlobalContext);\n};\n_s1(useGlobalContext, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nvar _c;\n$RefreshReg$(_c, \"GlobalContextProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vYXBwL0NvbnRleHQvc3RvcmUudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBRTREO0FBRWhCO0FBRTVDLE1BQU1JLDhCQUFnQkosb0RBQWFBLENBQU07SUFDdkMsR0FBSSxDQUFDLENBQUM7QUFDUjtBQUVPLE1BQU1LLHdCQUF3QjtRQUFDLEVBQUVDLFFBQVEsRUFBTzs7SUFDckQsYUFBYTtJQUNiLE1BQU1DLGlCQUFpQkwsK0NBQVFBLENBQUM7SUFDaEMsTUFBTU0sYUFBYU4sK0NBQVFBLENBQUM7SUFDNUIsTUFBTU8sYUFBYVAsK0NBQVFBLENBQUM7SUFFNUIsTUFBTVEsV0FBV1IsK0NBQVFBLENBQUM7SUFFMUIsbUJBQW1CO0lBQ25CLE1BQU1TLG1CQUFtQlQsK0NBQVFBLENBQUM7SUFDbEMsTUFBTVUsZUFBZVYsK0NBQVFBLENBQUMsQ0FBQztJQUUvQixhQUFhO0lBQ2IsTUFBTVcsV0FBVztJQUNqQix5RUFBeUU7SUFDekUsTUFBTSxDQUFDQyxVQUFVQyxZQUFZLEdBQUdiLCtDQUFRQSxDQUFDO0lBQ3pDLE1BQU1jLGVBQWU7UUFDbkJDLE9BQU9IO1FBQ1BJLFFBQVE7WUFDTkgsWUFBWSxDQUFDRDtRQUNiLCtEQUErRDtRQUNqRTtJQUNGO0lBRUEsTUFBTUssY0FBYztRQUNsQlosY0FBYyxDQUFDLEVBQUUsQ0FBQztRQUNsQixvQkFBb0I7UUFDcEJJLGdCQUFnQixDQUFDLEVBQUUsQ0FBQztRQUNwQkMsWUFBWSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQ25CO0lBRUEscUJBQ0UsOERBQUNSLGNBQWNnQjtRQUNiQyxPQUFPO1lBQ0xkO1lBQ0FDO1lBQ0FDO1lBQ0FFO1lBQ0FDO1lBQ0FGO1lBQ0FTO1lBQ0FOLFVBQVVBO1lBQ1ZHO1FBQ0Y7OzBCQUVBLDhEQUFDYiwyREFBT0E7Z0JBQUNjLE9BQU9ELGFBQWFDOzs7Ozs7WUFDNUJYOzs7Ozs7O0FBR1AsRUFBRTtHQWpEV0Q7S0FBQUE7QUFtRE4sTUFBTWlCLG1CQUFtQjs7SUFBTXJCLE9BQUFBLGlEQUFVQSxDQUFDRztBQUFhLEVBQUU7SUFBbkRrQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvQ29udGV4dC9zdG9yZS50c3g/ZTQ0YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcblxuaW1wb3J0IEJHTXVzaWMgZnJvbSBcIi4uL2NvbXBvbmVudHMvQkdNdXNpY1wiO1xuXG5jb25zdCBHbG9iYWxDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxhbnk+KHtcbiAgLi4uKHt9IGFzIGFueSksXG59KTtcblxuZXhwb3J0IGNvbnN0IEdsb2JhbENvbnRleHRQcm92aWRlciA9ICh7IGNoaWxkcmVuIH06IGFueSkgPT4ge1xuICAvLyBHYW1lIFN0YXRlXG4gIGNvbnN0IHJlbWFpbmluZ1N0YXRlID0gdXNlU3RhdGUoMTApO1xuICBjb25zdCBzY29yZVN0YXRlID0gdXNlU3RhdGUoNSk7XG4gIGNvbnN0IHJvdW5kU3RhdGUgPSB1c2VTdGF0ZSgzKTtcblxuICBjb25zdCB0YWJTdGF0ZSA9IHVzZVN0YXRlKDApO1xuXG4gIC8vIE9iamVjdCBEZXRlY3Rpb25cbiAgY29uc3QgaXNTdWJtaXRpbmdTdGF0ZSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgbWF0Y2hlZFN0YXRlID0gdXNlU3RhdGUoLTEpO1xuXG4gIC8vIFVzZXIgU3RhdGVcbiAgY29uc3QgdXNlcm5hbWUgPSBcInNvaGFtXCI7XG4gIC8vIGNvbnN0IHVzZXJuYW1lID0gd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKFwidXNlcm5hbWVcIikgfHwgXCJ1bmtub3duXCI7XG4gIGNvbnN0IFtfQkdNdXNpYywgX3NldEJHTXVzaWNdID0gdXNlU3RhdGUodHJ1ZSk7XG4gIGNvbnN0IEJHTXVzaWNTdGF0ZSA9IHtcbiAgICBzdGF0ZTogX0JHTXVzaWMsXG4gICAgdG9nZ2xlOiAoKSA9PiB7XG4gICAgICBfc2V0QkdNdXNpYyghX0JHTXVzaWMpO1xuICAgICAgLy8gd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKFwiYmdNdXNpY1wiLCBfQkdNdXNpYy50b1N0cmluZygpKTtcbiAgICB9LFxuICB9O1xuXG4gIGNvbnN0IHJlc3RhcnRHYW1lID0gKCkgPT4ge1xuICAgIHJlbWFpbmluZ1N0YXRlWzFdKDEwKTtcbiAgICAvLyByb3VuZFN0YXRlWzFdKDMpO1xuICAgIGlzU3VibWl0aW5nU3RhdGVbMV0oZmFsc2UpO1xuICAgIG1hdGNoZWRTdGF0ZVsxXSgtMSk7XG4gIH07XG5cbiAgcmV0dXJuIChcbiAgICA8R2xvYmFsQ29udGV4dC5Qcm92aWRlclxuICAgICAgdmFsdWU9e3tcbiAgICAgICAgcmVtYWluaW5nU3RhdGUsXG4gICAgICAgIHNjb3JlU3RhdGUsXG4gICAgICAgIHJvdW5kU3RhdGUsXG4gICAgICAgIGlzU3VibWl0aW5nU3RhdGUsXG4gICAgICAgIG1hdGNoZWRTdGF0ZSxcbiAgICAgICAgdGFiU3RhdGUsXG4gICAgICAgIHJlc3RhcnRHYW1lLFxuICAgICAgICB1c2VybmFtZTogdXNlcm5hbWUsXG4gICAgICAgIEJHTXVzaWNTdGF0ZSxcbiAgICAgIH19XG4gICAgPlxuICAgICAgPEJHTXVzaWMgc3RhdGU9e0JHTXVzaWNTdGF0ZS5zdGF0ZX0gLz5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L0dsb2JhbENvbnRleHQuUHJvdmlkZXI+XG4gICk7XG59O1xuXG5leHBvcnQgY29uc3QgdXNlR2xvYmFsQ29udGV4dCA9ICgpID0+IHVzZUNvbnRleHQoR2xvYmFsQ29udGV4dCk7XG4iXSwibmFtZXMiOlsiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJ1c2VTdGF0ZSIsIkJHTXVzaWMiLCJHbG9iYWxDb250ZXh0IiwiR2xvYmFsQ29udGV4dFByb3ZpZGVyIiwiY2hpbGRyZW4iLCJyZW1haW5pbmdTdGF0ZSIsInNjb3JlU3RhdGUiLCJyb3VuZFN0YXRlIiwidGFiU3RhdGUiLCJpc1N1Ym1pdGluZ1N0YXRlIiwibWF0Y2hlZFN0YXRlIiwidXNlcm5hbWUiLCJfQkdNdXNpYyIsIl9zZXRCR011c2ljIiwiQkdNdXNpY1N0YXRlIiwic3RhdGUiLCJ0b2dnbGUiLCJyZXN0YXJ0R2FtZSIsIlByb3ZpZGVyIiwidmFsdWUiLCJ1c2VHbG9iYWxDb250ZXh0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./app/Context/store.tsx\n"));

/***/ }),

/***/ "(app-client)/./app/components/BGMusic.tsx":
/*!************************************!*\
  !*** ./app/components/BGMusic.tsx ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-client)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-client)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\nvar _s = $RefreshSig$();\n\nfunction BGMusic(props) {\n    _s();\n    const canPlay = props.state;\n    const audioRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        var _audioRef_current, _audioRef_current1;\n        canPlay ? audioRef === null || audioRef === void 0 ? void 0 : (_audioRef_current = audioRef.current) === null || _audioRef_current === void 0 ? void 0 : _audioRef_current.play() : audioRef === null || audioRef === void 0 ? void 0 : (_audioRef_current1 = audioRef.current) === null || _audioRef_current1 === void 0 ? void 0 : _audioRef_current1.pause();\n    }, [\n        canPlay\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"absolute\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"audio\", {\n            ref: audioRef,\n            autoPlay: canPlay,\n            loop: true,\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"source\", {\n                src: \"/bg.mpga\",\n                type: \"audio/mpeg\"\n            }, void 0, false, {\n                fileName: \"G:\\\\object_hunt\\\\app\\\\components\\\\BGMusic.tsx\",\n                lineNumber: 24,\n                columnNumber: 9\n            }, this)\n        }, void 0, false, {\n            fileName: \"G:\\\\object_hunt\\\\app\\\\components\\\\BGMusic.tsx\",\n            lineNumber: 23,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"G:\\\\object_hunt\\\\app\\\\components\\\\BGMusic.tsx\",\n        lineNumber: 22,\n        columnNumber: 5\n    }, this);\n}\n_s(BGMusic, \"+byXHHf22FzALubYzgUeSQRtz1Y=\");\n_c = BGMusic;\n/* harmony default export */ __webpack_exports__[\"default\"] = (BGMusic);\nvar _c;\n$RefreshReg$(_c, \"BGMusic\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vYXBwL2NvbXBvbmVudHMvQkdNdXNpYy50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBTWU7QUFNZixTQUFTRyxRQUFRQyxLQUFZOztJQUMzQixNQUFNQyxVQUFVRCxNQUFNRTtJQUN0QixNQUFNQyxXQUFXTCw2Q0FBTUEsQ0FBbUI7SUFFMUNELGdEQUFTQSxDQUFDO1lBQ0VNLG1CQUE0QkE7UUFBdENGLFVBQVVFLHFCQUFBQSxzQkFBQUEsS0FBQUEsSUFBQUEsQ0FBQUEsb0JBQUFBLFNBQVVDLHFCQUFWRCwrQkFBQUEsS0FBQUEsSUFBQUEsa0JBQW1CRSxTQUFTRixxQkFBQUEsc0JBQUFBLEtBQUFBLElBQUFBLENBQUFBLHFCQUFBQSxTQUFVQyxxQkFBVkQsZ0NBQUFBLEtBQUFBLElBQUFBLG1CQUFtQkc7SUFDM0QsR0FBRztRQUFDTDtLQUFRO0lBRVoscUJBQ0UsOERBQUNNO1FBQUlDLFdBQVU7a0JBQ2IsNEVBQUNDO1lBQU1DLEtBQUtQO1lBQVVRLFVBQVVWO1lBQVNXLElBQUk7c0JBQzNDLDRFQUFDQztnQkFBT0MsS0FBSztnQkFBWUMsTUFBSzs7Ozs7Ozs7Ozs7Ozs7OztBQUl0QztHQWZTaEI7S0FBQUE7QUFpQlQsK0RBQWVBLE9BQU9BLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL2NvbXBvbmVudHMvQkdNdXNpYy50c3g/ZTFiYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHtcbiAgRGlzcGF0Y2gsXG4gIFNldFN0YXRlQWN0aW9uLFxuICB1c2VFZmZlY3QsXG4gIHVzZVJlZixcbiAgdXNlU3RhdGUsXG59IGZyb20gXCJyZWFjdFwiO1xuXG5pbnRlcmZhY2UgUHJvcHMge1xuICBzdGF0ZTogYm9vbGVhbjtcbn1cblxuZnVuY3Rpb24gQkdNdXNpYyhwcm9wczogUHJvcHMpIHtcbiAgY29uc3QgY2FuUGxheSA9IHByb3BzLnN0YXRlO1xuICBjb25zdCBhdWRpb1JlZiA9IHVzZVJlZjxIVE1MQXVkaW9FbGVtZW50PihudWxsKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNhblBsYXkgPyBhdWRpb1JlZj8uY3VycmVudD8ucGxheSgpIDogYXVkaW9SZWY/LmN1cnJlbnQ/LnBhdXNlKCk7XG4gIH0sIFtjYW5QbGF5XSk7XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cImFic29sdXRlXCI+XG4gICAgICA8YXVkaW8gcmVmPXthdWRpb1JlZn0gYXV0b1BsYXk9e2NhblBsYXl9IGxvb3A+XG4gICAgICAgIDxzb3VyY2Ugc3JjPXtcIi9iZy5tcGdhXCJ9IHR5cGU9XCJhdWRpby9tcGVnXCIgLz5cbiAgICAgIDwvYXVkaW8+XG4gICAgPC9kaXY+XG4gICk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJHTXVzaWM7XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJCR011c2ljIiwicHJvcHMiLCJjYW5QbGF5Iiwic3RhdGUiLCJhdWRpb1JlZiIsImN1cnJlbnQiLCJwbGF5IiwicGF1c2UiLCJkaXYiLCJjbGFzc05hbWUiLCJhdWRpbyIsInJlZiIsImF1dG9QbGF5IiwibG9vcCIsInNvdXJjZSIsInNyYyIsInR5cGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./app/components/BGMusic.tsx\n"));

/***/ }),

/***/ "(app-client)/./app/components/ImgSlider.tsx":
/*!**************************************!*\
  !*** ./app/components/ImgSlider.tsx ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-client)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var next_font_google_target_css_path_app_components_ImgSlider_tsx_import_Poppins_arguments_weight_400_500_600_700_subsets_latin_variableName_poppins___WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! next/font/google/target.css?{\"path\":\"app\\\\components\\\\ImgSlider.tsx\",\"import\":\"Poppins\",\"arguments\":[{\"weight\":[\"400\",\"500\",\"600\",\"700\"],\"subsets\":[\"latin\"]}],\"variableName\":\"poppins\"} */ \"(app-client)/./node_modules/next/font/google/target.css?{\\\"path\\\":\\\"app\\\\\\\\components\\\\\\\\ImgSlider.tsx\\\",\\\"import\\\":\\\"Poppins\\\",\\\"arguments\\\":[{\\\"weight\\\":[\\\"400\\\",\\\"500\\\",\\\"600\\\",\\\"700\\\"],\\\"subsets\\\":[\\\"latin\\\"]}],\\\"variableName\\\":\\\"poppins\\\"}\");\n/* harmony import */ var next_font_google_target_css_path_app_components_ImgSlider_tsx_import_Poppins_arguments_weight_400_500_600_700_subsets_latin_variableName_poppins___WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(next_font_google_target_css_path_app_components_ImgSlider_tsx_import_Poppins_arguments_weight_400_500_600_700_subsets_latin_variableName_poppins___WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-client)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_slideshow_image__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-slideshow-image */ \"(app-client)/./node_modules/react-slideshow-image/dist/react-slideshow-image.esm.js\");\n/* harmony import */ var react_slideshow_image_dist_styles_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-slideshow-image/dist/styles.css */ \"(app-client)/./node_modules/react-slideshow-image/dist/styles.css\");\n/* harmony import */ var _public_images_not_found_png__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../public/images/not found.png */ \"(app-client)/./public/images/not found.png\");\n\n\n\n\n\n\nconst sliderContainerStyle = {\n    height: \"100%\",\n    overflow: \"hidden\"\n};\nconst spanStyle = {\n    padding: \"24px\",\n    background: \"#fff9\",\n    filter: \"\",\n    // borderRadius: \"1rem\",\n    fontSize: \"2rem\",\n    textShadow: \"2px 2px 2px #0005\",\n    color: \"#000000\"\n};\nconst divStyle = {\n    backgroundSize: \"cover\",\n    backgroundPosition: \"center\",\n    height: \"100%\",\n    width: \"100%\"\n};\nfunction ImgSlider(props) {\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            style: sliderContainerStyle,\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_slideshow_image__WEBPACK_IMPORTED_MODULE_2__.Slide, {\n                duration: 3000,\n                autoplay: true,\n                infinite: false,\n                arrows: false,\n                transitionDuration: 200,\n                easing: \"ease\",\n                children: props.data.map((entry, index)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"py-60\",\n                            style: {\n                                ...divStyle,\n                                backgroundImage: \"url(\".concat(entry.img ? entry.img : '\"'.concat(_public_images_not_found_png__WEBPACK_IMPORTED_MODULE_4__[\"default\"].src, '\"'), \")\")\n                            },\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                className: \"absolute bottom-0 p-4 backdrop-blur-md w-full text-2xl font-semibold text-primary \".concat((next_font_google_target_css_path_app_components_ImgSlider_tsx_import_Poppins_arguments_weight_400_500_600_700_subsets_latin_variableName_poppins___WEBPACK_IMPORTED_MODULE_5___default().className)),\n                                children: [\n                                    entry.name,\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"br\", {}, void 0, false, {\n                                        fileName: \"G:\\\\object_hunt\\\\app\\\\components\\\\ImgSlider.tsx\",\n                                        lineNumber: 85,\n                                        columnNumber: 19\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                        className: \"text-gray-800 p-1 rounded bg-slate-400 text-sm\",\n                                        children: entry.matched === true ? \"\\uD83C\\uDF89 They found it\" : \"Lol they even don't have a \".concat(props.objname, \".\")\n                                    }, void 0, false, {\n                                        fileName: \"G:\\\\object_hunt\\\\app\\\\components\\\\ImgSlider.tsx\",\n                                        lineNumber: 86,\n                                        columnNumber: 19\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"G:\\\\object_hunt\\\\app\\\\components\\\\ImgSlider.tsx\",\n                                lineNumber: 81,\n                                columnNumber: 17\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"G:\\\\object_hunt\\\\app\\\\components\\\\ImgSlider.tsx\",\n                            lineNumber: 72,\n                            columnNumber: 15\n                        }, this)\n                    }, index, false, {\n                        fileName: \"G:\\\\object_hunt\\\\app\\\\components\\\\ImgSlider.tsx\",\n                        lineNumber: 71,\n                        columnNumber: 13\n                    }, this))\n            }, void 0, false, {\n                fileName: \"G:\\\\object_hunt\\\\app\\\\components\\\\ImgSlider.tsx\",\n                lineNumber: 62,\n                columnNumber: 9\n            }, this)\n        }, void 0, false, {\n            fileName: \"G:\\\\object_hunt\\\\app\\\\components\\\\ImgSlider.tsx\",\n            lineNumber: 61,\n            columnNumber: 7\n        }, this)\n    }, void 0, false);\n}\n_c = ImgSlider;\n/* harmony default export */ __webpack_exports__[\"default\"] = (ImgSlider);\nvar _c;\n$RefreshReg$(_c, \"ImgSlider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vYXBwL2NvbXBvbmVudHMvSW1nU2xpZGVyLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBU01BO0FBUm9CO0FBRW9CO0FBRUM7QUFFVztBQU8xRCxNQUFNSSx1QkFBdUI7SUFDM0JDLFFBQVE7SUFDUkMsVUFBVTtBQUNaO0FBRUEsTUFBTUMsWUFBWTtJQUNoQkMsU0FBUztJQUNUQyxZQUFZO0lBQ1pDLFFBQVE7SUFDUix3QkFBd0I7SUFDeEJDLFVBQVU7SUFDVkMsWUFBWTtJQUNaQyxPQUFPO0FBQ1Q7QUFFQSxNQUFNQyxXQUFXO0lBQ2ZDLGdCQUFnQjtJQUNoQkMsb0JBQW9CO0lBQ3BCWCxRQUFRO0lBQ1JZLE9BQU87QUFFVDtBQXNCQSxTQUFTQyxVQUFVQyxLQUFZO0lBQzdCLHFCQUNFO2tCQUNFLDRFQUFDQztZQUFJQyxPQUFPakI7c0JBQ1YsNEVBQUNGLHdEQUFLQTtnQkFDSm9CLFVBQVU7Z0JBQ1ZDLFVBQVU7Z0JBQ1ZDLFVBQVU7Z0JBQ1ZDLFFBQVE7Z0JBQ1JDLG9CQUFvQjtnQkFDcEJDLFFBQU87MEJBRU5SLE1BQU1TLEtBQUtDLElBQUksQ0FBQ0MsT0FBT0Msc0JBQ3RCLDhEQUFDWDtrQ0FDQyw0RUFBQ0E7NEJBQ0NZLFdBQVU7NEJBQ1ZYLE9BQU87Z0NBQ0wsR0FBR1AsUUFBUTtnQ0FDWG1CLGlCQUFpQixPQUVoQixPQURDSCxNQUFNSSxNQUFNSixNQUFNSSxNQUFNLElBQWtCLE9BQWQvQixvRUFBU0EsQ0FBQ2dDLEtBQUksTUFDM0M7NEJBQ0g7c0NBRUEsNEVBQUNDO2dDQUNDSixXQUFXLHFGQUF1RyxPQUFsQmhDLG9NQUFpQmdDOztvQ0FFaEhGLE1BQU1PO2tEQUNQLDhEQUFDQzs7Ozs7a0RBQ0QsOERBQUNDO3dDQUFFUCxXQUFVO2tEQUNWRixNQUFNVSxZQUFZLE9BQ2QsK0JBQ0QsOEJBQTRDLE9BQWRyQixNQUFNc0IsU0FBUTs7Ozs7Ozs7Ozs7Ozs7Ozs7dUJBbEI5Q1Y7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpRHRCO0tBOURTYjtBQWdFVCwrREFBZUEsU0FBU0EsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvY29tcG9uZW50cy9JbWdTbGlkZXIudHN4PzZmYWYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUG9wcGlucyB9IGZyb20gXCJuZXh0L2ZvbnQvZ29vZ2xlXCI7XG5pbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5cbmltcG9ydCB7IFNsaWRlIH0gZnJvbSBcInJlYWN0LXNsaWRlc2hvdy1pbWFnZVwiO1xuXG5pbXBvcnQgXCJyZWFjdC1zbGlkZXNob3ctaW1hZ2UvZGlzdC9zdHlsZXMuY3NzXCI7XG5cbmltcG9ydCBub3RfZm91bmQgZnJvbSBcIi4uLy4uL3B1YmxpYy9pbWFnZXMvbm90IGZvdW5kLnBuZ1wiO1xuXG5jb25zdCBwb3BwaW5zID0gUG9wcGlucyh7XG4gIHdlaWdodDogW1wiNDAwXCIsIFwiNTAwXCIsIFwiNjAwXCIsIFwiNzAwXCJdLFxuICBzdWJzZXRzOiBbXCJsYXRpblwiXSxcbn0pO1xuXG5jb25zdCBzbGlkZXJDb250YWluZXJTdHlsZSA9IHtcbiAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgb3ZlcmZsb3c6IFwiaGlkZGVuXCIsXG59O1xuXG5jb25zdCBzcGFuU3R5bGUgPSB7XG4gIHBhZGRpbmc6IFwiMjRweFwiLFxuICBiYWNrZ3JvdW5kOiBcIiNmZmY5XCIsXG4gIGZpbHRlcjogXCJcIixcbiAgLy8gYm9yZGVyUmFkaXVzOiBcIjFyZW1cIixcbiAgZm9udFNpemU6IFwiMnJlbVwiLFxuICB0ZXh0U2hhZG93OiBcIjJweCAycHggMnB4ICMwMDA1XCIsXG4gIGNvbG9yOiBcIiMwMDAwMDBcIixcbn07XG5cbmNvbnN0IGRpdlN0eWxlID0ge1xuICBiYWNrZ3JvdW5kU2l6ZTogXCJjb3ZlclwiLFxuICBiYWNrZ3JvdW5kUG9zaXRpb246IFwiY2VudGVyXCIsXG4gIGhlaWdodDogXCIxMDAlXCIsXG4gIHdpZHRoOiBcIjEwMCVcIixcbiAgLy8gYm9yZGVyUmFkaXVzOiBcIjFyZW1cIixcbn07XG5cbi8vIGNvbnN0IHNsaWRlSW1hZ2VzID0gW1xuLy8gICB7XG4vLyAgICAgdXJsOiBcImh0dHBzOi8vaW1hZ2VzLnVuc3BsYXNoLmNvbS9waG90by0xNTA5NzIxNDM0MjcyLWI3OTE0N2UwZTcwOD9peGxpYj1yYi0xLjIuMSZpeGlkPWV5SmhjSEJmYVdRaU9qRXlNRGQ5JmF1dG89Zm9ybWF0JmZpdD1jcm9wJnc9MTUwMCZxPTgwXCIsXG4vLyAgICAgY2FwdGlvbjogXCJQbGF5ZXIgMVwiLFxuLy8gICB9LFxuLy8gICB7XG4vLyAgICAgdXJsOiBcImh0dHBzOi8vaW1hZ2VzLnVuc3BsYXNoLmNvbS9waG90by0xNTA2NzEwNTA3NTY1LTIwM2I5ZjI0NjY5Yj9peGxpYj1yYi0xLjIuMSZpeGlkPWV5SmhjSEJmYVdRaU9qRXlNRGQ5JmF1dG89Zm9ybWF0JmZpdD1jcm9wJnc9MTUzNiZxPTgwXCIsXG4vLyAgICAgY2FwdGlvbjogXCJQbGF5ZXIgMlwiLFxuLy8gICB9LFxuLy8gICB7XG4vLyAgICAgdXJsOiBcImh0dHBzOi8vaW1hZ2VzLnVuc3BsYXNoLmNvbS9waG90by0xNTM2OTg3MzMzNzA2LWZjOWFkZmIxMGQ5MT9peGxpYj1yYi0xLjIuMSZpeGlkPWV5SmhjSEJmYVdRaU9qRXlNRGQ5JmF1dG89Zm9ybWF0JmZpdD1jcm9wJnc9MTUwMCZxPTgwXCIsXG4vLyAgICAgY2FwdGlvbjogXCJQbGF5ZXIgM1wiLFxuLy8gICB9LFxuLy8gXTtcblxuaW50ZXJmYWNlIFByb3BzIHtcbiAgZGF0YTogQXJyYXk8eyBpbWc6IHN0cmluZzsgbmFtZTogc3RyaW5nOyBtYXRjaGVkOiBib29sZWFuIHwgdW5kZWZpbmVkIH0+O1xuICBvYmpuYW1lOiBzdHJpbmc7XG59XG5cbmZ1bmN0aW9uIEltZ1NsaWRlcihwcm9wczogUHJvcHMpIHtcbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAgPGRpdiBzdHlsZT17c2xpZGVyQ29udGFpbmVyU3R5bGV9PlxuICAgICAgICA8U2xpZGVcbiAgICAgICAgICBkdXJhdGlvbj17MzAwMH1cbiAgICAgICAgICBhdXRvcGxheT17dHJ1ZX1cbiAgICAgICAgICBpbmZpbml0ZT17ZmFsc2V9XG4gICAgICAgICAgYXJyb3dzPXtmYWxzZX1cbiAgICAgICAgICB0cmFuc2l0aW9uRHVyYXRpb249ezIwMH1cbiAgICAgICAgICBlYXNpbmc9XCJlYXNlXCJcbiAgICAgICAgPlxuICAgICAgICAgIHtwcm9wcy5kYXRhLm1hcCgoZW50cnksIGluZGV4KSA9PiAoXG4gICAgICAgICAgICA8ZGl2IGtleT17aW5kZXh9PlxuICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwicHktNjBcIlxuICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAuLi5kaXZTdHlsZSxcbiAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRJbWFnZTogYHVybCgke1xuICAgICAgICAgICAgICAgICAgICBlbnRyeS5pbWcgPyBlbnRyeS5pbWcgOiBgXCIke25vdF9mb3VuZC5zcmN9XCJgXG4gICAgICAgICAgICAgICAgICB9KWAsXG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDxzcGFuXG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2BhYnNvbHV0ZSBib3R0b20tMCBwLTQgYmFja2Ryb3AtYmx1ci1tZCB3LWZ1bGwgdGV4dC0yeGwgZm9udC1zZW1pYm9sZCB0ZXh0LXByaW1hcnkgJHtwb3BwaW5zLmNsYXNzTmFtZX1gfVxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgIHtlbnRyeS5uYW1lfVxuICAgICAgICAgICAgICAgICAgPGJyIC8+XG4gICAgICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LWdyYXktODAwIHAtMSByb3VuZGVkIGJnLXNsYXRlLTQwMCB0ZXh0LXNtXCI+XG4gICAgICAgICAgICAgICAgICAgIHtlbnRyeS5tYXRjaGVkID09PSB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgPyBg8J+OiSBUaGV5IGZvdW5kIGl0YFxuICAgICAgICAgICAgICAgICAgICAgIDogYExvbCB0aGV5IGV2ZW4gZG9uJ3QgaGF2ZSBhICR7cHJvcHMub2JqbmFtZX0uYH1cbiAgICAgICAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICB7Lyoge2VudHJ5Lm1hdGNoZWQgPT09IHRydWUgPyAoXG4gICAgICAgICAgICAgICAgPGxhYmVsIGtleT17aW5kZXh9PlxuICAgICAgICAgICAgICAgICAge1wiIFwifVxuICAgICAgICAgICAgICAgICAgVGhleSBmb3VuZHtcIiBcIn1cbiAgICAgICAgICAgICAgICAgIDxzcGFuXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17YHRleHQtcHJpbWFyeSBjYXBpdGFsaXplIG10LTMgJHtwb3BwaW5zLmNsYXNzTmFtZX1gfVxuICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICB7cHJvcHMub2JqbmFtZSB8fCBcIk9iamVjdFwifVxuICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvbGFiZWw+XG4gICAgICAgICAgICAgICkgOiAoXG4gICAgICAgICAgICAgICAgPGxhYmVsIGtleT17aW5kZXh9PlxuICAgICAgICAgICAgICAgICAge1wiIFwifVxuICAgICAgICAgICAgICAgICAgTE9MLCBUaGV5IGNhbid0IGV2ZW4gZmluZHtcIiBcIn1cbiAgICAgICAgICAgICAgICAgIDxzcGFuXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17YHRleHQtcHJpbWFyeSBjYXBpdGFsaXplIG10LTMgJHtwb3BwaW5zLmNsYXNzTmFtZX1gfVxuICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICB7cHJvcHMub2JqbmFtZSB8fCBcIk9iamVjdFwifSBhcm91bmQgdGhlbVxuICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvbGFiZWw+XG4gICAgICAgICAgICAgICl9ICovfVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgKSl9XG4gICAgICAgIDwvU2xpZGU+XG4gICAgICA8L2Rpdj5cbiAgICA8Lz5cbiAgKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgSW1nU2xpZGVyO1xuIl0sIm5hbWVzIjpbInBvcHBpbnMiLCJSZWFjdCIsIlNsaWRlIiwibm90X2ZvdW5kIiwic2xpZGVyQ29udGFpbmVyU3R5bGUiLCJoZWlnaHQiLCJvdmVyZmxvdyIsInNwYW5TdHlsZSIsInBhZGRpbmciLCJiYWNrZ3JvdW5kIiwiZmlsdGVyIiwiZm9udFNpemUiLCJ0ZXh0U2hhZG93IiwiY29sb3IiLCJkaXZTdHlsZSIsImJhY2tncm91bmRTaXplIiwiYmFja2dyb3VuZFBvc2l0aW9uIiwid2lkdGgiLCJJbWdTbGlkZXIiLCJwcm9wcyIsImRpdiIsInN0eWxlIiwiZHVyYXRpb24iLCJhdXRvcGxheSIsImluZmluaXRlIiwiYXJyb3dzIiwidHJhbnNpdGlvbkR1cmF0aW9uIiwiZWFzaW5nIiwiZGF0YSIsIm1hcCIsImVudHJ5IiwiaW5kZXgiLCJjbGFzc05hbWUiLCJiYWNrZ3JvdW5kSW1hZ2UiLCJpbWciLCJzcmMiLCJzcGFuIiwibmFtZSIsImJyIiwicCIsIm1hdGNoZWQiLCJvYmpuYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./app/components/ImgSlider.tsx\n"));

/***/ }),

/***/ "(app-client)/./app/components/Modal.tsx":
/*!**********************************!*\
  !*** ./app/components/Modal.tsx ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-client)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var next_font_google_target_css_path_app_components_Modal_tsx_import_Bungee_arguments_weight_400_subsets_latin_variableName_font1___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/font/google/target.css?{\"path\":\"app\\\\components\\\\Modal.tsx\",\"import\":\"Bungee\",\"arguments\":[{\"weight\":\"400\",\"subsets\":[\"latin\"]}],\"variableName\":\"font1\"} */ \"(app-client)/./node_modules/next/font/google/target.css?{\\\"path\\\":\\\"app\\\\\\\\components\\\\\\\\Modal.tsx\\\",\\\"import\\\":\\\"Bungee\\\",\\\"arguments\\\":[{\\\"weight\\\":\\\"400\\\",\\\"subsets\\\":[\\\"latin\\\"]}],\\\"variableName\\\":\\\"font1\\\"}\");\n/* harmony import */ var next_font_google_target_css_path_app_components_Modal_tsx_import_Bungee_arguments_weight_400_subsets_latin_variableName_font1___WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_font_google_target_css_path_app_components_Modal_tsx_import_Bungee_arguments_weight_400_subsets_latin_variableName_font1___WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-client)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\nvar _s = $RefreshSig$();\n\n\n\nfunction Modal(props) {\n    _s();\n    const [isOpen, setIsOpen] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(props.defaultOpen || false);\n    // const router = useRouter();\n    // const animation = useSpring({\n    //   config: {\n    //     duration: 250\n    //   },\n    //   opacity: isOpen ? 1 : 0,\n    //   transform: isOpen ? `translateY(0)` : `translateY(-100%)`\n    // });\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            props.defaultOpen || /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                onClick: ()=>setIsOpen(!isOpen),\n                className: \"btn \".concat(props.buttonClassName, \" \").concat((next_font_google_target_css_path_app_components_Modal_tsx_import_Bungee_arguments_weight_400_subsets_latin_variableName_font1___WEBPACK_IMPORTED_MODULE_2___default().className)),\n                children: props.btnname\n            }, void 0, false, {\n                fileName: \"G:\\\\object_hunt\\\\app\\\\components\\\\Modal.tsx\",\n                lineNumber: 47,\n                columnNumber: 9\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                type: \"checkbox\",\n                id: props.id,\n                checked: isOpen,\n                defaultChecked: props.defaultOpen,\n                onChange: (e)=>{},\n                className: \"modal-toggle\"\n            }, void 0, false, {\n                fileName: \"G:\\\\object_hunt\\\\app\\\\components\\\\Modal.tsx\",\n                lineNumber: 55,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"modal \".concat(props.modalClassName),\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"modal-box bg-base border-2 nobar broder-white \".concat((next_font_google_target_css_path_app_components_Modal_tsx_import_Bungee_arguments_weight_400_subsets_latin_variableName_font1___WEBPACK_IMPORTED_MODULE_2___default().className)),\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                            className: \"font-bold text-2xl text-primary\",\n                            children: props.title\n                        }, void 0, false, {\n                            fileName: \"G:\\\\object_hunt\\\\app\\\\components\\\\Modal.tsx\",\n                            lineNumber: 69,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"flex flex-col mt-3\",\n                            children: props.children\n                        }, void 0, false, {\n                            fileName: \"G:\\\\object_hunt\\\\app\\\\components\\\\Modal.tsx\",\n                            lineNumber: 70,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"modal-action flex justify-between\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    children: props.actions\n                                }, void 0, false, {\n                                    fileName: \"G:\\\\object_hunt\\\\app\\\\components\\\\Modal.tsx\",\n                                    lineNumber: 72,\n                                    columnNumber: 13\n                                }, this),\n                                props.customClose ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                    onClick: ()=>{\n                                        window.location.href = props.customClose && (props === null || props === void 0 ? void 0 : props.customClose[1]) || \"/\";\n                                    // router.push(\n                                    //   (props.customClose && props.customClose[1]) || \"/\"\n                                    // );\n                                    // router.refresh();\n                                    },\n                                    className: \"btn btn-error \".concat((next_font_google_target_css_path_app_components_Modal_tsx_import_Bungee_arguments_weight_400_subsets_latin_variableName_font1___WEBPACK_IMPORTED_MODULE_2___default().className)),\n                                    children: props.customClose[0]\n                                }, void 0, false, {\n                                    fileName: \"G:\\\\object_hunt\\\\app\\\\components\\\\Modal.tsx\",\n                                    lineNumber: 75,\n                                    columnNumber: 15\n                                }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                        onClick: ()=>setIsOpen(false),\n                                        className: \"btn btn-error \".concat((next_font_google_target_css_path_app_components_Modal_tsx_import_Bungee_arguments_weight_400_subsets_latin_variableName_font1___WEBPACK_IMPORTED_MODULE_2___default().className)),\n                                        children: \"Close\"\n                                    }, void 0, false, {\n                                        fileName: \"G:\\\\object_hunt\\\\app\\\\components\\\\Modal.tsx\",\n                                        lineNumber: 90,\n                                        columnNumber: 17\n                                    }, this)\n                                }, void 0, false)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"G:\\\\object_hunt\\\\app\\\\components\\\\Modal.tsx\",\n                            lineNumber: 71,\n                            columnNumber: 11\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"G:\\\\object_hunt\\\\app\\\\components\\\\Modal.tsx\",\n                    lineNumber: 66,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"G:\\\\object_hunt\\\\app\\\\components\\\\Modal.tsx\",\n                lineNumber: 64,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true);\n}\n_s(Modal, \"HuT1Om9eFxNU++idrWA42Fm2DZk=\");\n_c = Modal;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Modal);\nvar _c;\n$RefreshReg$(_c, \"Modal\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vYXBwL2NvbXBvbmVudHMvTW9kYWwudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBS01BO0FBS0FDO0FBVmtDO0FBK0J4QyxTQUFTRyxNQUFNQyxLQUFZOztJQUN6QixNQUFNLENBQUNDLFFBQVFDLFVBQVUsR0FBR0osK0NBQVFBLENBQUNFLE1BQU1HLGVBQWU7SUFDMUQsOEJBQThCO0lBRTlCLGdDQUFnQztJQUNoQyxjQUFjO0lBQ2Qsb0JBQW9CO0lBQ3BCLE9BQU87SUFDUCw2QkFBNkI7SUFDN0IsOERBQThEO0lBQzlELE1BQU07SUFFTixxQkFDRTs7WUFDR0gsTUFBTUcsNkJBQ0wsOERBQUNDO2dCQUNDQyxTQUFTLElBQU1ILFVBQVUsQ0FBQ0Q7Z0JBQzFCSyxXQUFXLE9BQWdDWCxPQUF6QkssTUFBTU8saUJBQWdCLEtBQW1CLE9BQWhCWixpTEFBZVc7MEJBRXpETixNQUFNUTs7Ozs7OzBCQUlYLDhEQUFDQztnQkFDQ0MsTUFBSztnQkFDTEMsSUFBSVgsTUFBTVc7Z0JBQ1ZDLFNBQVNYO2dCQUNUWSxnQkFBZ0JiLE1BQU1HO2dCQUN0QlcsVUFBVSxDQUFDQyxLQUFPO2dCQUNsQlQsV0FBVTs7Ozs7OzBCQUdaLDhEQUFDVTtnQkFBSVYsV0FBVyxTQUE4QixPQUFyQk4sTUFBTWlCOzBCQUU3Qiw0RUFBQ0Q7b0JBQ0NWLFdBQVcsaURBQWlFLE9BQWhCWCxpTEFBZVc7O3NDQUUzRSw4REFBQ1k7NEJBQUdaLFdBQVU7c0NBQW1DTixNQUFNbUI7Ozs7OztzQ0FDdkQsOERBQUNIOzRCQUFJVixXQUFVO3NDQUFzQk4sTUFBTW9COzs7Ozs7c0NBQzNDLDhEQUFDSjs0QkFBSVYsV0FBVTs7OENBQ2IsOERBQUNVOzhDQUFLaEIsTUFBTXFCOzs7Ozs7Z0NBRVhyQixNQUFNc0IsNEJBQ0wsOERBQUNsQjtvQ0FDQ0MsU0FBUzt3Q0FDUGtCLE9BQU9DLFNBQVNDLE9BQ2QsTUFBT0gsZ0JBQWV0QixrQkFBQUEsbUJBQUFBLEtBQUFBLElBQUFBLE1BQU9zQixXQUFXLENBQUMsRUFBRSxLQUFLO29DQUNsRCxlQUFlO29DQUNmLHVEQUF1RDtvQ0FDdkQsS0FBSztvQ0FDTCxvQkFBb0I7b0NBQ3RCO29DQUNBaEIsV0FBVyxpQkFBaUMsT0FBaEJYLGlMQUFlVzs4Q0FFMUNOLE1BQU1zQixXQUFXLENBQUMsRUFBRTs7Ozs7eURBR3ZCOzhDQUNFLDRFQUFDbEI7d0NBQ0NDLFNBQVMsSUFBTUgsVUFBVTt3Q0FDekJJLFdBQVcsaUJBQWlDLE9BQWhCWCxpTEFBZVc7a0RBQzVDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQVdqQjtHQXhFU1A7S0FBQUE7QUEwRVQsK0RBQWVBLEtBQUtBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL2NvbXBvbmVudHMvTW9kYWwudHN4PzI0ZjQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XG4vLyBpbXBvcnQgeyB1c2VSb3V0ZXIgfSBmcm9tIFwibmV4dC9uYXZpZ2F0aW9uXCI7XG5cbmltcG9ydCB7IEJ1bmdlZSwgUG9wcGlucyB9IGZyb20gXCJuZXh0L2ZvbnQvZ29vZ2xlXCI7XG5cbmNvbnN0IGZvbnQxID0gQnVuZ2VlKHtcbiAgd2VpZ2h0OiBcIjQwMFwiLFxuICBzdWJzZXRzOiBbXCJsYXRpblwiXSxcbn0pO1xuXG5jb25zdCBmb250MiA9IFBvcHBpbnMoe1xuICB3ZWlnaHQ6IFwiNDAwXCIsXG4gIHN1YnNldHM6IFtcImxhdGluXCJdLFxufSk7XG5cbi8vIGltcG9ydCB7IHVzZVNwcmluZywgYW5pbWF0ZWQgfSBmcm9tICdAcmVhY3Qtc3ByaW5nL3dlYidcbi8vIGltcG9ydCBzdHlsZWQgZnJvbSAnc3R5bGVkLWNvbXBvbmVudHMnO1xuXG5pbnRlcmZhY2UgUHJvcHMge1xuICBpZDogc3RyaW5nO1xuICB0aXRsZTogc3RyaW5nO1xuICBidG5uYW1lOiBhbnk7XG4gIGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGU7XG4gIG1vZGFsQ2xhc3NOYW1lPzogc3RyaW5nO1xuICBidXR0b25DbGFzc05hbWU/OiBzdHJpbmc7XG4gIGFjdGlvbnM/OiBKU1guRWxlbWVudDtcbiAgZW5hYmxlPzogYm9vbGVhbjtcbiAgZGVmYXVsdE9wZW4/OiBib29sZWFuO1xuICBjdXN0b21DbG9zZT86IHN0cmluZ1tdO1xufVxuXG5mdW5jdGlvbiBNb2RhbChwcm9wczogUHJvcHMpIHtcbiAgY29uc3QgW2lzT3Blbiwgc2V0SXNPcGVuXSA9IHVzZVN0YXRlKHByb3BzLmRlZmF1bHRPcGVuIHx8IGZhbHNlKTtcbiAgLy8gY29uc3Qgcm91dGVyID0gdXNlUm91dGVyKCk7XG5cbiAgLy8gY29uc3QgYW5pbWF0aW9uID0gdXNlU3ByaW5nKHtcbiAgLy8gICBjb25maWc6IHtcbiAgLy8gICAgIGR1cmF0aW9uOiAyNTBcbiAgLy8gICB9LFxuICAvLyAgIG9wYWNpdHk6IGlzT3BlbiA/IDEgOiAwLFxuICAvLyAgIHRyYW5zZm9ybTogaXNPcGVuID8gYHRyYW5zbGF0ZVkoMClgIDogYHRyYW5zbGF0ZVkoLTEwMCUpYFxuICAvLyB9KTtcblxuICByZXR1cm4gKFxuICAgIDw+XG4gICAgICB7cHJvcHMuZGVmYXVsdE9wZW4gfHwgKFxuICAgICAgICA8bGFiZWxcbiAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRJc09wZW4oIWlzT3Blbil9XG4gICAgICAgICAgY2xhc3NOYW1lPXtgYnRuICR7cHJvcHMuYnV0dG9uQ2xhc3NOYW1lfSAke2ZvbnQxLmNsYXNzTmFtZX1gfVxuICAgICAgICA+XG4gICAgICAgICAge3Byb3BzLmJ0bm5hbWV9XG4gICAgICAgIDwvbGFiZWw+XG4gICAgICApfVxuXG4gICAgICA8aW5wdXRcbiAgICAgICAgdHlwZT1cImNoZWNrYm94XCJcbiAgICAgICAgaWQ9e3Byb3BzLmlkfVxuICAgICAgICBjaGVja2VkPXtpc09wZW59XG4gICAgICAgIGRlZmF1bHRDaGVja2VkPXtwcm9wcy5kZWZhdWx0T3Blbn1cbiAgICAgICAgb25DaGFuZ2U9eyhlKSA9PiB7fX1cbiAgICAgICAgY2xhc3NOYW1lPVwibW9kYWwtdG9nZ2xlXCJcbiAgICAgIC8+XG5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtgbW9kYWwgJHtwcm9wcy5tb2RhbENsYXNzTmFtZX1gfT5cbiAgICAgICAgey8qIDxhbmltYXRlZC5kaXYgc3R5bGU9e2FuaW1hdGlvbn0+ICovfVxuICAgICAgICA8ZGl2XG4gICAgICAgICAgY2xhc3NOYW1lPXtgbW9kYWwtYm94IGJnLWJhc2UgYm9yZGVyLTIgbm9iYXIgYnJvZGVyLXdoaXRlICR7Zm9udDEuY2xhc3NOYW1lfWB9XG4gICAgICAgID5cbiAgICAgICAgICA8aDMgY2xhc3NOYW1lPVwiZm9udC1ib2xkIHRleHQtMnhsIHRleHQtcHJpbWFyeVwiPntwcm9wcy50aXRsZX08L2gzPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBtdC0zXCI+e3Byb3BzLmNoaWxkcmVufTwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibW9kYWwtYWN0aW9uIGZsZXgganVzdGlmeS1iZXR3ZWVuXCI+XG4gICAgICAgICAgICA8ZGl2Pntwcm9wcy5hY3Rpb25zfTwvZGl2PlxuXG4gICAgICAgICAgICB7cHJvcHMuY3VzdG9tQ2xvc2UgPyAoXG4gICAgICAgICAgICAgIDxsYWJlbFxuICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHtcbiAgICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID1cbiAgICAgICAgICAgICAgICAgICAgKHByb3BzLmN1c3RvbUNsb3NlICYmIHByb3BzPy5jdXN0b21DbG9zZVsxXSkgfHwgXCIvXCI7XG4gICAgICAgICAgICAgICAgICAvLyByb3V0ZXIucHVzaChcbiAgICAgICAgICAgICAgICAgIC8vICAgKHByb3BzLmN1c3RvbUNsb3NlICYmIHByb3BzLmN1c3RvbUNsb3NlWzFdKSB8fCBcIi9cIlxuICAgICAgICAgICAgICAgICAgLy8gKTtcbiAgICAgICAgICAgICAgICAgIC8vIHJvdXRlci5yZWZyZXNoKCk7XG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2BidG4gYnRuLWVycm9yICR7Zm9udDEuY2xhc3NOYW1lfWB9XG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICB7cHJvcHMuY3VzdG9tQ2xvc2VbMF19XG4gICAgICAgICAgICAgIDwvbGFiZWw+XG4gICAgICAgICAgICApIDogKFxuICAgICAgICAgICAgICA8PlxuICAgICAgICAgICAgICAgIDxsYWJlbFxuICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0SXNPcGVuKGZhbHNlKX1cbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17YGJ0biBidG4tZXJyb3IgJHtmb250MS5jbGFzc05hbWV9YH1cbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICBDbG9zZVxuICAgICAgICAgICAgICAgIDwvbGFiZWw+XG4gICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgKX1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIHsvKiA8L2FuaW1hdGVkLmRpdj4gKi99XG4gICAgICA8L2Rpdj5cbiAgICA8Lz5cbiAgKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgTW9kYWw7XG4iXSwibmFtZXMiOlsiZm9udDEiLCJmb250MiIsIlJlYWN0IiwidXNlU3RhdGUiLCJNb2RhbCIsInByb3BzIiwiaXNPcGVuIiwic2V0SXNPcGVuIiwiZGVmYXVsdE9wZW4iLCJsYWJlbCIsIm9uQ2xpY2siLCJjbGFzc05hbWUiLCJidXR0b25DbGFzc05hbWUiLCJidG5uYW1lIiwiaW5wdXQiLCJ0eXBlIiwiaWQiLCJjaGVja2VkIiwiZGVmYXVsdENoZWNrZWQiLCJvbkNoYW5nZSIsImUiLCJkaXYiLCJtb2RhbENsYXNzTmFtZSIsImgzIiwidGl0bGUiLCJjaGlsZHJlbiIsImFjdGlvbnMiLCJjdXN0b21DbG9zZSIsIndpbmRvdyIsImxvY2F0aW9uIiwiaHJlZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./app/components/Modal.tsx\n"));

/***/ }),

/***/ "(app-client)/./app/components/Room/Capture.tsx":
/*!*****************************************!*\
  !*** ./app/components/Room/Capture.tsx ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-client)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var next_font_google_target_css_path_app_components_Room_Capture_tsx_import_Poppins_arguments_weight_500_subsets_latin_variableName_poppins___WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! next/font/google/target.css?{\"path\":\"app\\\\components\\\\Room\\\\Capture.tsx\",\"import\":\"Poppins\",\"arguments\":[{\"weight\":\"500\",\"subsets\":[\"latin\"]}],\"variableName\":\"poppins\"} */ \"(app-client)/./node_modules/next/font/google/target.css?{\\\"path\\\":\\\"app\\\\\\\\components\\\\\\\\Room\\\\\\\\Capture.tsx\\\",\\\"import\\\":\\\"Poppins\\\",\\\"arguments\\\":[{\\\"weight\\\":\\\"500\\\",\\\"subsets\\\":[\\\"latin\\\"]}],\\\"variableName\\\":\\\"poppins\\\"}\");\n/* harmony import */ var next_font_google_target_css_path_app_components_Room_Capture_tsx_import_Poppins_arguments_weight_500_subsets_latin_variableName_poppins___WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(next_font_google_target_css_path_app_components_Room_Capture_tsx_import_Poppins_arguments_weight_500_subsets_latin_variableName_poppins___WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-client)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_webcam__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-webcam */ \"(app-client)/./node_modules/react-webcam/dist/react-webcam.js\");\n/* harmony import */ var react_webcam__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_webcam__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _Context_store__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../Context/store */ \"(app-client)/./app/Context/store.tsx\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\nconst videoConstraints = {\n    width: 720,\n    height: 720,\n    facingMode: \"user\"\n};\nconst videoConstraints2 = {\n    width: 720,\n    height: 720,\n    facingMode: \"environment\"\n};\nconst Capture = (props)=>{\n    _s();\n    const { matchedState, isSubmitingState } = (0,_Context_store__WEBPACK_IMPORTED_MODULE_3__.useGlobalContext)();\n    const [camearaState, setCameraState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [imgIsCaptured, setImgIsCaptured] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // const [isSubmiting, setIsSubmiting] = props.CaptureState;\n    // const [matched, setMatched] = props.MatchedState;\n    const webcamRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const captureScreenRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const captureImage = ()=>{\n        var // stop video\n        _webcamRef_current, _webcamRef_current_video;\n        (_webcamRef_current = webcamRef.current) === null || _webcamRef_current === void 0 ? void 0 : (_webcamRef_current_video = _webcamRef_current.video) === null || _webcamRef_current_video === void 0 ? void 0 : _webcamRef_current_video.pause();\n        // hide the capture button and show the send button\n        setImgIsCaptured(true);\n    };\n    const submitImage = ()=>{\n        var _webcamRef_current_getScreenshot, _webcamRef_current;\n        isSubmitingState[1](true);\n        const imageData = (_webcamRef_current_getScreenshot = (_webcamRef_current = webcamRef.current) === null || _webcamRef_current === void 0 ? void 0 : _webcamRef_current.getScreenshot()) === null || _webcamRef_current_getScreenshot === void 0 ? void 0 : _webcamRef_current_getScreenshot.replace(\"data:image/jpeg;base64,\", \"\");\n        props.submitImage(imageData);\n        // call isSubmitingState[1](true) after 3 seconds\n        setTimeout(()=>{\n            isSubmitingState[1](true);\n        }, 3000);\n    // retakeImage();\n    // props?.socket?.emit(\"image\", { imgData: imageData });\n    // send form data to axios\n    // const formData = new FormData();\n    // formData.append(\"imgdata\", imageData!);\n    // axios\n    //   .post(\"http://127.0.0.1:8000/upload/\", formData)\n    //   .then(function (response) {\n    //     if (response.data.matched) {\n    //       isSubmitingState[1](false);\n    //       setImgIsCaptured(false);\n    //       webcamRef.current?.video?.play();\n    //       matchedState[1](response.data.matched);\n    //       console.log(response.data.matched);\n    //     }\n    //   })\n    //   .catch(function (error) {\n    //     console.log(error);\n    //   });\n    };\n    const retakeImage = ()=>{\n        var _webcamRef_current, _webcamRef_current_video;\n        (_webcamRef_current = webcamRef.current) === null || _webcamRef_current === void 0 ? void 0 : (_webcamRef_current_video = _webcamRef_current.video) === null || _webcamRef_current_video === void 0 ? void 0 : _webcamRef_current_video.play();\n        setImgIsCaptured(false);\n        isSubmitingState[1](false);\n    };\n    // useState(() => {\n    //   retakeImage();\n    // });\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (props.canRetake) {\n            // console.log(\"retake\");\n            retakeImage();\n        }\n    // else {\n    //   console.log(\"no retake\");\n    // }\n    }, [\n        props.canRetake\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: matchedState[0] == -1 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            id: \"capture\",\n            className: \"flex flex-col justify-end m-1 mt-2 p-2 bg-stone-800 aspect-square rounded-lg\",\n            ref: captureScreenRef,\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((react_webcam__WEBPACK_IMPORTED_MODULE_2___default()), {\n                className: \"rounded-md shadow-md bg-slate-800 aspect-square\",\n                alt: \"Loading...\",\n                ref: webcamRef,\n                audio: false,\n                height: 720,\n                screenshotFormat: \"image/jpeg\",\n                width: 720,\n                videoConstraints: camearaState ? videoConstraints : videoConstraints2,\n                children: (param)=>{\n                    let { getScreenshot } = param;\n                    if (imgIsCaptured) {\n                        if (isSubmitingState[0]) {\n                            return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"flex flex-col bg-slate-700 mt-2 rounded-md p-3 items-center gap-2\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"progress\", {\n                                    className: \"progress progress-primary w-full p-0 m-0\"\n                                }, void 0, false, {\n                                    fileName: \"G:\\\\object_hunt\\\\app\\\\components\\\\Room\\\\Capture.tsx\",\n                                    lineNumber: 140,\n                                    columnNumber: 23\n                                }, undefined)\n                            }, void 0, false, {\n                                fileName: \"G:\\\\object_hunt\\\\app\\\\components\\\\Room\\\\Capture.tsx\",\n                                lineNumber: 136,\n                                columnNumber: 21\n                            }, undefined);\n                        }\n                        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"flex gap-2\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                    className: \"btn btn-sm flex-1 btn-secondary mt-2 \".concat((next_font_google_target_css_path_app_components_Room_Capture_tsx_import_Poppins_arguments_weight_500_subsets_latin_variableName_poppins___WEBPACK_IMPORTED_MODULE_4___default().className)),\n                                    onClick: submitImage,\n                                    children: \"Submit\"\n                                }, void 0, false, {\n                                    fileName: \"G:\\\\object_hunt\\\\app\\\\components\\\\Room\\\\Capture.tsx\",\n                                    lineNumber: 146,\n                                    columnNumber: 21\n                                }, undefined),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                    className: \"btn btn-sm w-2/6 btn-error mt-2 \".concat((next_font_google_target_css_path_app_components_Room_Capture_tsx_import_Poppins_arguments_weight_500_subsets_latin_variableName_poppins___WEBPACK_IMPORTED_MODULE_4___default().className)),\n                                    onClick: retakeImage,\n                                    children: \"Retake\"\n                                }, void 0, false, {\n                                    fileName: \"G:\\\\object_hunt\\\\app\\\\components\\\\Room\\\\Capture.tsx\",\n                                    lineNumber: 152,\n                                    columnNumber: 21\n                                }, undefined)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"G:\\\\object_hunt\\\\app\\\\components\\\\Room\\\\Capture.tsx\",\n                            lineNumber: 145,\n                            columnNumber: 19\n                        }, undefined);\n                    } else {\n                        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                    className: \"btn btn-sm btn-secondary mt-2  \".concat((next_font_google_target_css_path_app_components_Room_Capture_tsx_import_Poppins_arguments_weight_500_subsets_latin_variableName_poppins___WEBPACK_IMPORTED_MODULE_4___default().className)),\n                                    style: {\n                                        textShadow: \"2px 2px 2px #0004\"\n                                    },\n                                    onClick: captureImage,\n                                    children: \"Capture\"\n                                }, void 0, false, {\n                                    fileName: \"G:\\\\object_hunt\\\\app\\\\components\\\\Room\\\\Capture.tsx\",\n                                    lineNumber: 163,\n                                    columnNumber: 19\n                                }, undefined),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                    className: \"btn btn-sm btn-secondary mt-2 \".concat((next_font_google_target_css_path_app_components_Room_Capture_tsx_import_Poppins_arguments_weight_500_subsets_latin_variableName_poppins___WEBPACK_IMPORTED_MODULE_4___default().className)),\n                                    style: {\n                                        textShadow: \"2px 2px 2px #0004\"\n                                    },\n                                    onClick: ()=>{\n                                        setCameraState(!camearaState);\n                                    },\n                                    children: \"Rotate Camera\"\n                                }, void 0, false, {\n                                    fileName: \"G:\\\\object_hunt\\\\app\\\\components\\\\Room\\\\Capture.tsx\",\n                                    lineNumber: 170,\n                                    columnNumber: 19\n                                }, undefined)\n                            ]\n                        }, void 0, true);\n                    }\n                }\n            }, void 0, false, {\n                fileName: \"G:\\\\object_hunt\\\\app\\\\components\\\\Room\\\\Capture.tsx\",\n                lineNumber: 121,\n                columnNumber: 11\n            }, undefined)\n        }, void 0, false, {\n            fileName: \"G:\\\\object_hunt\\\\app\\\\components\\\\Room\\\\Capture.tsx\",\n            lineNumber: 116,\n            columnNumber: 9\n        }, undefined) || /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            children: [\n                \"Your image \",\n                matchedState[0],\n                \"% matched\"\n            ]\n        }, void 0, true, {\n            fileName: \"G:\\\\object_hunt\\\\app\\\\components\\\\Room\\\\Capture.tsx\",\n            lineNumber: 182,\n            columnNumber: 13\n        }, undefined)\n    }, void 0, false);\n};\n_s(Capture, \"XUkx6tcBNw7xq5B9JdsbJJYhSt4=\", false, function() {\n    return [\n        _Context_store__WEBPACK_IMPORTED_MODULE_3__.useGlobalContext\n    ];\n});\n_c = Capture;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Capture);\nvar _c;\n$RefreshReg$(_c, \"Capture\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vYXBwL2NvbXBvbmVudHMvUm9vbS9DYXB0dXJlLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQVdNQTtBQUtBQztBQWQwRDtBQUM5QjtBQUVxQjtBQWdCdkQsTUFBTU8sbUJBQW1CO0lBQ3ZCQyxPQUFPO0lBQ1BDLFFBQVE7SUFDUkMsWUFBWTtBQUNkO0FBRUEsTUFBTUMsb0JBQW9CO0lBQ3hCSCxPQUFPO0lBQ1BDLFFBQVE7SUFDUkMsWUFBWTtBQUNkO0FBT0EsTUFBTUUsVUFBVSxDQUFDQzs7SUFDZixNQUFNLEVBQUVDLFlBQVksRUFBRUMsZ0JBQWdCLEVBQUUsR0FBR1QsZ0VBQWdCQTtJQUMzRCxNQUFNLENBQUNVLGNBQWNDLGVBQWUsR0FBR2IsK0NBQVFBLENBQUM7SUFDaEQsTUFBTSxDQUFDYyxlQUFlQyxpQkFBaUIsR0FBR2YsK0NBQVFBLENBQUM7SUFFbkQsNERBQTREO0lBQzVELG9EQUFvRDtJQUVwRCxNQUFNZ0IsWUFBWWpCLDZDQUFNQSxDQUFTO0lBQ2pDLE1BQU1rQixtQkFBbUJsQiw2Q0FBTUEsQ0FBaUI7SUFFaEQsTUFBTW1CLGVBQWU7WUFDbkIsYUFBYTtRQUNiRjtRQUFBQSxDQUFBQSxxQkFBQUEsVUFBVUcscUJBQVZILGdDQUFBQSxLQUFBQSxJQUFBQSw0QkFBQUEsbUJBQW1CSSx5REFBbkJKLEtBQUFBLElBQUFBLHlCQUEwQks7UUFFMUIsbURBQW1EO1FBQ25ETixpQkFBaUI7SUFDbkI7SUFFQSxNQUFNTyxjQUFjO1lBRUFOLGtDQUFBQTtRQURsQkwsZ0JBQWdCLENBQUMsRUFBRSxDQUFDO1FBQ3BCLE1BQU1ZLFlBQVlQLENBQUFBLG1DQUFBQSxDQUFBQSxxQkFBQUEsVUFBVUcscUJBQVZILGdDQUFBQSxLQUFBQSxJQUFBQSxtQkFDZFEsNkJBRGNSLDhDQUFBQSxLQUFBQSxJQUFBQSxpQ0FFZFMsUUFBUSwyQkFBMkI7UUFDdkNoQixNQUFNYSxZQUFZQztRQUVsQixpREFBaUQ7UUFDakRHLFdBQVc7WUFDVGYsZ0JBQWdCLENBQUMsRUFBRSxDQUFDO1FBQ3RCLEdBQUc7SUFFSCxpQkFBaUI7SUFDakIsd0RBQXdEO0lBRXhELDBCQUEwQjtJQUMxQixtQ0FBbUM7SUFDbkMsMENBQTBDO0lBRTFDLFFBQVE7SUFDUixxREFBcUQ7SUFDckQsZ0NBQWdDO0lBQ2hDLG1DQUFtQztJQUNuQyxvQ0FBb0M7SUFDcEMsaUNBQWlDO0lBQ2pDLDBDQUEwQztJQUMxQyxnREFBZ0Q7SUFDaEQsNENBQTRDO0lBQzVDLFFBQVE7SUFDUixPQUFPO0lBQ1AsOEJBQThCO0lBQzlCLDBCQUEwQjtJQUMxQixRQUFRO0lBQ1Y7SUFFQSxNQUFNZ0IsY0FBYztZQUNsQlg7UUFBQUEsQ0FBQUEscUJBQUFBLFVBQVVHLHFCQUFWSCxnQ0FBQUEsS0FBQUEsSUFBQUEsNEJBQUFBLG1CQUFtQkkseURBQW5CSixLQUFBQSxJQUFBQSx5QkFBMEJZO1FBQzFCYixpQkFBaUI7UUFDakJKLGdCQUFnQixDQUFDLEVBQUUsQ0FBQztJQUN0QjtJQUVBLG1CQUFtQjtJQUNuQixtQkFBbUI7SUFDbkIsTUFBTTtJQUVOYixnREFBU0EsQ0FBQztRQUNSLElBQUlXLE1BQU1vQixXQUFXO1lBQ25CLHlCQUF5QjtZQUN6QkY7UUFDRjtJQUNBLFNBQVM7SUFDVCw4QkFBOEI7SUFDOUIsSUFBSTtJQUNOLEdBQUc7UUFBQ2xCLE1BQU1vQjtLQUFVO0lBRXBCLHFCQUNFO2tCQUNHLFlBQWEsQ0FBQyxFQUFFLElBQUksQ0FBQyxtQkFDcEIsOERBQUNDO1lBQ0NDLElBQUc7WUFDSEMsV0FBVTtZQUNWQyxLQUFLaEI7c0JBRUwsNEVBQUNoQixxREFBTUE7Z0JBQ0wrQixXQUFVO2dCQUNWRSxLQUFJO2dCQUNKRCxLQUFLakI7Z0JBQ0xtQixPQUFPO2dCQUNQOUIsUUFBUTtnQkFDUitCLGtCQUFpQjtnQkFDakJoQyxPQUFPO2dCQUNQRCxrQkFBa0JTLGVBQWVULG1CQUFtQkk7MEJBR25EO3dCQUFDLEVBQUVpQixhQUFhLEVBQUU7b0JBQ2pCLElBQUlWLGVBQWU7d0JBQ2pCLElBQUlILGdCQUFnQixDQUFDLEVBQUUsRUFBRTs0QkFDdkIscUJBQ0UsOERBQUNtQjtnQ0FBSUUsV0FBVTswQ0FJYiw0RUFBQ0s7b0NBQVNMLFdBQVU7Ozs7Ozs7Ozs7O3dCQUcxQjt3QkFDQSxxQkFDRSw4REFBQ0Y7NEJBQUlFLFdBQVU7OzhDQUNiLDhEQUFDTTtvQ0FDQ04sV0FBVyx3Q0FBMEQsT0FBbEJwQywyTEFBaUJvQztvQ0FDcEVPLFNBQVNqQjs4Q0FDVjs7Ozs7OzhDQUdELDhEQUFDZ0I7b0NBQ0NOLFdBQVcsbUNBQXFELE9BQWxCcEMsMkxBQWlCb0M7b0NBQy9ETyxTQUFTWjs4Q0FDVjs7Ozs7Ozs7Ozs7O29CQUtQLE9BQU87d0JBQ0wscUJBQ0U7OzhDQUNBLDhEQUFDVztvQ0FDQ04sV0FBVyxrQ0FBb0QsT0FBbEJwQywyTEFBaUJvQztvQ0FDOURRLE9BQU87d0NBQUVDLFlBQVk7b0NBQW9CO29DQUN6Q0YsU0FBU3JCOzhDQUNWOzs7Ozs7OENBR0QsOERBQUNvQjtvQ0FDQ04sV0FBVyxpQ0FBbUQsT0FBbEJwQywyTEFBaUJvQztvQ0FDN0RRLE9BQU87d0NBQUNDLFlBQVk7b0NBQW1CO29DQUN2Q0YsU0FBUzt3Q0FBTzFCLGVBQWUsQ0FBQ0Q7b0NBQWE7OENBQUc7Ozs7Ozs7O29CQUt0RDtnQkFDRjs7Ozs7Ozs7Ozt1Q0FHQSw4REFBQ2tCOztnQkFBSTtnQkFBWXBCLFlBQVksQ0FBQyxFQUFFO2dCQUFDOzs7Ozs7OztBQUc3QztHQWxKTUY7O1FBQ3VDTiw0REFBZ0JBOzs7S0FEdkRNO0FBb0pOLCtEQUFlQSxPQUFPQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2FwcC9jb21wb25lbnRzL1Jvb20vQ2FwdHVyZS50c3g/ZjA2MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxuaW1wb3J0IFJlYWN0LCB7IHVzZSwgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgV2ViY2FtIGZyb20gXCJyZWFjdC13ZWJjYW1cIjtcblxuaW1wb3J0IHsgdXNlR2xvYmFsQ29udGV4dCB9IGZyb20gXCIuLi8uLi9Db250ZXh0L3N0b3JlXCI7XG5pbXBvcnQgeyBCdW5nZWUsIFBvcHBpbnMgfSBmcm9tIFwibmV4dC9mb250L2dvb2dsZVwiO1xuXG4vLyBjb25zdCBmZXRjaGVyID0gKGFyZzogYW55LCAuLi5hcmdzOiBhbnkpID0+XG4vLyAgIGZldGNoKGFyZywgLi4uYXJncykudGhlbigocmVzKSA9PiByZXMuanNvbigpKTtcblxuY29uc3QgYnVuZ2VlID0gQnVuZ2VlKHtcbiAgd2VpZ2h0OiBcIjQwMFwiLFxuICBzdWJzZXRzOiBbXCJsYXRpblwiXSxcbn0pO1xuXG5jb25zdCBwb3BwaW5zID0gUG9wcGlucyh7XG4gIHdlaWdodDogXCI1MDBcIixcbiAgc3Vic2V0czogW1wibGF0aW5cIl0sXG59KTtcblxuY29uc3QgdmlkZW9Db25zdHJhaW50cyA9IHtcbiAgd2lkdGg6IDcyMCxcbiAgaGVpZ2h0OiA3MjAsXG4gIGZhY2luZ01vZGU6IFwidXNlclwiLFxufTtcblxuY29uc3QgdmlkZW9Db25zdHJhaW50czIgPSB7XG4gIHdpZHRoOiA3MjAsXG4gIGhlaWdodDogNzIwLFxuICBmYWNpbmdNb2RlOiBcImVudmlyb25tZW50XCIsXG59OyBcblxuaW50ZXJmYWNlIFByb3BzIHtcbiAgc3VibWl0SW1hZ2U6IChpbWdEYXRhPzogc3RyaW5nKSA9PiB2b2lkO1xuICBjYW5SZXRha2U6IGJvb2xlYW47XG59XG5cbmNvbnN0IENhcHR1cmUgPSAocHJvcHM6IFByb3BzKSA9PiB7XG4gIGNvbnN0IHsgbWF0Y2hlZFN0YXRlLCBpc1N1Ym1pdGluZ1N0YXRlIH0gPSB1c2VHbG9iYWxDb250ZXh0KCk7XG4gIGNvbnN0IFtjYW1lYXJhU3RhdGUsIHNldENhbWVyYVN0YXRlXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2ltZ0lzQ2FwdHVyZWQsIHNldEltZ0lzQ2FwdHVyZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBcbiAgLy8gY29uc3QgW2lzU3VibWl0aW5nLCBzZXRJc1N1Ym1pdGluZ10gPSBwcm9wcy5DYXB0dXJlU3RhdGU7XG4gIC8vIGNvbnN0IFttYXRjaGVkLCBzZXRNYXRjaGVkXSA9IHByb3BzLk1hdGNoZWRTdGF0ZTtcblxuICBjb25zdCB3ZWJjYW1SZWYgPSB1c2VSZWY8V2ViY2FtPihudWxsKTtcbiAgY29uc3QgY2FwdHVyZVNjcmVlblJlZiA9IHVzZVJlZjxIVE1MRGl2RWxlbWVudD4obnVsbCk7XG5cbiAgY29uc3QgY2FwdHVyZUltYWdlID0gKCkgPT4ge1xuICAgIC8vIHN0b3AgdmlkZW9cbiAgICB3ZWJjYW1SZWYuY3VycmVudD8udmlkZW8/LnBhdXNlKCk7XG5cbiAgICAvLyBoaWRlIHRoZSBjYXB0dXJlIGJ1dHRvbiBhbmQgc2hvdyB0aGUgc2VuZCBidXR0b25cbiAgICBzZXRJbWdJc0NhcHR1cmVkKHRydWUpO1xuICB9O1xuXG4gIGNvbnN0IHN1Ym1pdEltYWdlID0gKCkgPT4ge1xuICAgIGlzU3VibWl0aW5nU3RhdGVbMV0odHJ1ZSk7XG4gICAgY29uc3QgaW1hZ2VEYXRhID0gd2ViY2FtUmVmLmN1cnJlbnRcbiAgICAgID8uZ2V0U2NyZWVuc2hvdCgpXG4gICAgICA/LnJlcGxhY2UoXCJkYXRhOmltYWdlL2pwZWc7YmFzZTY0LFwiLCBcIlwiKTtcbiAgICBwcm9wcy5zdWJtaXRJbWFnZShpbWFnZURhdGEpO1xuXG4gICAgLy8gY2FsbCBpc1N1Ym1pdGluZ1N0YXRlWzFdKHRydWUpIGFmdGVyIDMgc2Vjb25kc1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaXNTdWJtaXRpbmdTdGF0ZVsxXSh0cnVlKTtcbiAgICB9LCAzMDAwKTtcbiAgICBcbiAgICAvLyByZXRha2VJbWFnZSgpO1xuICAgIC8vIHByb3BzPy5zb2NrZXQ/LmVtaXQoXCJpbWFnZVwiLCB7IGltZ0RhdGE6IGltYWdlRGF0YSB9KTtcblxuICAgIC8vIHNlbmQgZm9ybSBkYXRhIHRvIGF4aW9zXG4gICAgLy8gY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAvLyBmb3JtRGF0YS5hcHBlbmQoXCJpbWdkYXRhXCIsIGltYWdlRGF0YSEpO1xuXG4gICAgLy8gYXhpb3NcbiAgICAvLyAgIC5wb3N0KFwiaHR0cDovLzEyNy4wLjAuMTo4MDAwL3VwbG9hZC9cIiwgZm9ybURhdGEpXG4gICAgLy8gICAudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAvLyAgICAgaWYgKHJlc3BvbnNlLmRhdGEubWF0Y2hlZCkge1xuICAgIC8vICAgICAgIGlzU3VibWl0aW5nU3RhdGVbMV0oZmFsc2UpO1xuICAgIC8vICAgICAgIHNldEltZ0lzQ2FwdHVyZWQoZmFsc2UpO1xuICAgIC8vICAgICAgIHdlYmNhbVJlZi5jdXJyZW50Py52aWRlbz8ucGxheSgpO1xuICAgIC8vICAgICAgIG1hdGNoZWRTdGF0ZVsxXShyZXNwb25zZS5kYXRhLm1hdGNoZWQpO1xuICAgIC8vICAgICAgIGNvbnNvbGUubG9nKHJlc3BvbnNlLmRhdGEubWF0Y2hlZCk7XG4gICAgLy8gICAgIH1cbiAgICAvLyAgIH0pXG4gICAgLy8gICAuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgLy8gICAgIGNvbnNvbGUubG9nKGVycm9yKTtcbiAgICAvLyAgIH0pO1xuICB9O1xuXG4gIGNvbnN0IHJldGFrZUltYWdlID0gKCkgPT4ge1xuICAgIHdlYmNhbVJlZi5jdXJyZW50Py52aWRlbz8ucGxheSgpO1xuICAgIHNldEltZ0lzQ2FwdHVyZWQoZmFsc2UpO1xuICAgIGlzU3VibWl0aW5nU3RhdGVbMV0oZmFsc2UpO1xuICB9O1xuXG4gIC8vIHVzZVN0YXRlKCgpID0+IHtcbiAgLy8gICByZXRha2VJbWFnZSgpO1xuICAvLyB9KTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChwcm9wcy5jYW5SZXRha2UpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKFwicmV0YWtlXCIpO1xuICAgICAgcmV0YWtlSW1hZ2UoKTtcbiAgICB9XG4gICAgLy8gZWxzZSB7XG4gICAgLy8gICBjb25zb2xlLmxvZyhcIm5vIHJldGFrZVwiKTtcbiAgICAvLyB9XG4gIH0sIFtwcm9wcy5jYW5SZXRha2VdKTtcblxuICByZXR1cm4gKFxuICAgIDw+XG4gICAgICB7KG1hdGNoZWRTdGF0ZVswXSA9PSAtMSAmJiAoXG4gICAgICAgIDxkaXZcbiAgICAgICAgICBpZD1cImNhcHR1cmVcIlxuICAgICAgICAgIGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2wganVzdGlmeS1lbmQgbS0xIG10LTIgcC0yIGJnLXN0b25lLTgwMCBhc3BlY3Qtc3F1YXJlIHJvdW5kZWQtbGdcIlxuICAgICAgICAgIHJlZj17Y2FwdHVyZVNjcmVlblJlZn1cbiAgICAgICAgPlxuICAgICAgICAgIDxXZWJjYW1cbiAgICAgICAgICAgIGNsYXNzTmFtZT1cInJvdW5kZWQtbWQgc2hhZG93LW1kIGJnLXNsYXRlLTgwMCBhc3BlY3Qtc3F1YXJlXCJcbiAgICAgICAgICAgIGFsdD1cIkxvYWRpbmcuLi5cIlxuICAgICAgICAgICAgcmVmPXt3ZWJjYW1SZWZ9XG4gICAgICAgICAgICBhdWRpbz17ZmFsc2V9XG4gICAgICAgICAgICBoZWlnaHQ9ezcyMH1cbiAgICAgICAgICAgIHNjcmVlbnNob3RGb3JtYXQ9XCJpbWFnZS9qcGVnXCJcbiAgICAgICAgICAgIHdpZHRoPXs3MjB9XG4gICAgICAgICAgICB2aWRlb0NvbnN0cmFpbnRzPXtjYW1lYXJhU3RhdGUgPyB2aWRlb0NvbnN0cmFpbnRzIDogdmlkZW9Db25zdHJhaW50czJ9XG4gICAgICAgICAgPlxuICAgICAgICAgICAgey8qIEB0cy1pZ25vcmUgKi99XG4gICAgICAgICAgICB7KHsgZ2V0U2NyZWVuc2hvdCB9KSA9PiB7XG4gICAgICAgICAgICAgIGlmIChpbWdJc0NhcHR1cmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzU3VibWl0aW5nU3RhdGVbMF0pIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBiZy1zbGF0ZS03MDAgbXQtMiByb3VuZGVkLW1kIHAtMyBpdGVtcy1jZW50ZXIgZ2FwLTJcIj5cbiAgICAgICAgICAgICAgICAgICAgICB7LyogPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LXByaW1hcnkgdGV4dC1zbSBwLTAgbS0wIGZvbnQtYm9sZFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFVQTE9BRElORy4uLi4uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4gKi99XG4gICAgICAgICAgICAgICAgICAgICAgPHByb2dyZXNzIGNsYXNzTmFtZT1cInByb2dyZXNzIHByb2dyZXNzLXByaW1hcnkgdy1mdWxsIHAtMCBtLTBcIj48L3Byb2dyZXNzPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZ2FwLTJcIj5cbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17YGJ0biBidG4tc20gZmxleC0xIGJ0bi1zZWNvbmRhcnkgbXQtMiAke3BvcHBpbnMuY2xhc3NOYW1lfWB9XG4gICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17c3VibWl0SW1hZ2V9XG4gICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICBTdWJtaXRcbiAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2BidG4gYnRuLXNtIHctMi82IGJ0bi1lcnJvciBtdC0yICR7cG9wcGlucy5jbGFzc05hbWV9YH1cbiAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXtyZXRha2VJbWFnZX1cbiAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgIFJldGFrZVxuICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17YGJ0biBidG4tc20gYnRuLXNlY29uZGFyeSBtdC0yICAke3BvcHBpbnMuY2xhc3NOYW1lfWB9XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7IHRleHRTaGFkb3c6IFwiMnB4IDJweCAycHggIzAwMDRcIiB9fVxuICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXtjYXB0dXJlSW1hZ2V9XG4gICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIENhcHR1cmVcbiAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2BidG4gYnRuLXNtIGJ0bi1zZWNvbmRhcnkgbXQtMiAke3BvcHBpbnMuY2xhc3NOYW1lfWB9XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7dGV4dFNoYWRvdzogXCIycHggMnB4IDJweCAjMDAwNFwifX1cbiAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4ge3NldENhbWVyYVN0YXRlKCFjYW1lYXJhU3RhdGUpfX0+XG4gICAgICAgICAgICAgICAgICAgIFJvdGF0ZSBDYW1lcmFcbiAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfX1cbiAgICAgICAgICA8L1dlYmNhbT5cbiAgICAgICAgPC9kaXY+XG4gICAgICApKSB8fCA8ZGl2PllvdXIgaW1hZ2Uge21hdGNoZWRTdGF0ZVswXX0lIG1hdGNoZWQ8L2Rpdj59XG4gICAgPC8+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBDYXB0dXJlO1xuIl0sIm5hbWVzIjpbImJ1bmdlZSIsInBvcHBpbnMiLCJSZWFjdCIsInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZVN0YXRlIiwiV2ViY2FtIiwidXNlR2xvYmFsQ29udGV4dCIsInZpZGVvQ29uc3RyYWludHMiLCJ3aWR0aCIsImhlaWdodCIsImZhY2luZ01vZGUiLCJ2aWRlb0NvbnN0cmFpbnRzMiIsIkNhcHR1cmUiLCJwcm9wcyIsIm1hdGNoZWRTdGF0ZSIsImlzU3VibWl0aW5nU3RhdGUiLCJjYW1lYXJhU3RhdGUiLCJzZXRDYW1lcmFTdGF0ZSIsImltZ0lzQ2FwdHVyZWQiLCJzZXRJbWdJc0NhcHR1cmVkIiwid2ViY2FtUmVmIiwiY2FwdHVyZVNjcmVlblJlZiIsImNhcHR1cmVJbWFnZSIsImN1cnJlbnQiLCJ2aWRlbyIsInBhdXNlIiwic3VibWl0SW1hZ2UiLCJpbWFnZURhdGEiLCJnZXRTY3JlZW5zaG90IiwicmVwbGFjZSIsInNldFRpbWVvdXQiLCJyZXRha2VJbWFnZSIsInBsYXkiLCJjYW5SZXRha2UiLCJkaXYiLCJpZCIsImNsYXNzTmFtZSIsInJlZiIsImFsdCIsImF1ZGlvIiwic2NyZWVuc2hvdEZvcm1hdCIsInByb2dyZXNzIiwiYnV0dG9uIiwib25DbGljayIsInN0eWxlIiwidGV4dFNoYWRvdyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./app/components/Room/Capture.tsx\n"));

/***/ }),

/***/ "(app-client)/./app/components/Room/Chat.tsx":
/*!**************************************!*\
  !*** ./app/components/Room/Chat.tsx ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-client)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var next_font_google_target_css_path_app_components_Room_Chat_tsx_import_Bungee_arguments_weight_400_subsets_latin_variableName_bungee___WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/font/google/target.css?{\"path\":\"app\\\\components\\\\Room\\\\Chat.tsx\",\"import\":\"Bungee\",\"arguments\":[{\"weight\":\"400\",\"subsets\":[\"latin\"]}],\"variableName\":\"bungee\"} */ \"(app-client)/./node_modules/next/font/google/target.css?{\\\"path\\\":\\\"app\\\\\\\\components\\\\\\\\Room\\\\\\\\Chat.tsx\\\",\\\"import\\\":\\\"Bungee\\\",\\\"arguments\\\":[{\\\"weight\\\":\\\"400\\\",\\\"subsets\\\":[\\\"latin\\\"]}],\\\"variableName\\\":\\\"bungee\\\"}\");\n/* harmony import */ var next_font_google_target_css_path_app_components_Room_Chat_tsx_import_Bungee_arguments_weight_400_subsets_latin_variableName_bungee___WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(next_font_google_target_css_path_app_components_Room_Chat_tsx_import_Bungee_arguments_weight_400_subsets_latin_variableName_bungee___WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var next_font_google_target_css_path_app_components_Room_Chat_tsx_import_Poppins_arguments_weight_500_subsets_latin_variableName_poppins___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/font/google/target.css?{\"path\":\"app\\\\components\\\\Room\\\\Chat.tsx\",\"import\":\"Poppins\",\"arguments\":[{\"weight\":\"500\",\"subsets\":[\"latin\"]}],\"variableName\":\"poppins\"} */ \"(app-client)/./node_modules/next/font/google/target.css?{\\\"path\\\":\\\"app\\\\\\\\components\\\\\\\\Room\\\\\\\\Chat.tsx\\\",\\\"import\\\":\\\"Poppins\\\",\\\"arguments\\\":[{\\\"weight\\\":\\\"500\\\",\\\"subsets\\\":[\\\"latin\\\"]}],\\\"variableName\\\":\\\"poppins\\\"}\");\n/* harmony import */ var next_font_google_target_css_path_app_components_Room_Chat_tsx_import_Poppins_arguments_weight_500_subsets_latin_variableName_poppins___WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_font_google_target_css_path_app_components_Room_Chat_tsx_import_Poppins_arguments_weight_500_subsets_latin_variableName_poppins___WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-client)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\nvar _s = $RefreshSig$();\n\n\n\nconst Chat = (props)=>{\n    _s();\n    const chatListRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        var // @ts-ignore\n        _chatListRef_current, _chatListRef_current1;\n        chatListRef === null || chatListRef === void 0 ? void 0 : (_chatListRef_current = chatListRef.current) === null || _chatListRef_current === void 0 ? void 0 : _chatListRef_current.scrollTo(0, chatListRef === null || chatListRef === void 0 ? void 0 : (_chatListRef_current1 = chatListRef.current) === null || _chatListRef_current1 === void 0 ? void 0 : _chatListRef_current1.scrollHeight);\n    }, [\n        props.msgs\n    ]);\n    // return (\n    //   <div className=\"pl-1 pr-1 h-full\">\n    //     <div\n    //       id=\"chat-list\"\n    //       ref={chatListRef}\n    //       className={`flex flex-col gap-1 bg-base-200 w-full h-1/4 nobar mb-1.5 overflow-x-scroll ${poppins.className}`}\n    //     >\n    //       {props.msgs.map((m: { username: string; message: string }, idx) => {\n    //         return (\n    //           m.username && (\n    //             <div className=\"bg-base-200 p-1\" key={idx}>\n    //               {m.username}: {m.message}\n    //             </div>\n    //           )\n    //         );\n    //       })}\n    //     </div>\n    //     <input\n    //       type=\"text\"\n    //       value={props.msg}\n    //       onKeyDown={(e) => {\n    //         if (e.key === \"Enter\") {\n    //           props?.sendMsg();\n    //         }\n    //       }}\n    //       onChange={(e) => props.setMsg(e.target.value)}\n    //       placeholder=\"Type message here\"\n    //       className={`input leading-none rounded w-full bg-base-200 mb-2 stext-mg text-white ${poppins.className}`}\n    //     />\n    //   </div>\n    // );\n    // };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        id: \"chat\",\n        className: \"flex flex-col m-2 p-2 h-full\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"text-primary text-left text-xl font-bold p-1\",\n                children: \"CHAT\"\n            }, void 0, false, {\n                fileName: \"G:\\\\object_hunt\\\\app\\\\components\\\\Room\\\\Chat.tsx\",\n                lineNumber: 64,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                id: \"chat-list\",\n                ref: chatListRef,\n                className: \"flex flex-col gap-1 w-full p-2 overflow-auto h-44\",\n                children: props.msgs.map((m, idx)=>m.username && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: (next_font_google_target_css_path_app_components_Room_Chat_tsx_import_Poppins_arguments_weight_500_subsets_latin_variableName_poppins___WEBPACK_IMPORTED_MODULE_2___default().className),\n                        children: [\n                            m.username,\n                            \": \",\n                            m.message\n                        ]\n                    }, idx, true, {\n                        fileName: \"G:\\\\object_hunt\\\\app\\\\components\\\\Room\\\\Chat.tsx\",\n                        lineNumber: 71,\n                        columnNumber: 11\n                    }, undefined))\n            }, void 0, false, {\n                fileName: \"G:\\\\object_hunt\\\\app\\\\components\\\\Room\\\\Chat.tsx\",\n                lineNumber: 65,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"flex gap-2 items-center justify-between mt-2\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                        type: \"text\",\n                        placeholder: \"Type here\",\n                        value: props.msg,\n                        onKeyDown: (e)=>{\n                            if (e.key === \"Enter\") {\n                                props.sendMsg();\n                            }\n                        },\n                        onChange: (e)=>props.setMsg(e.target.value),\n                        className: \"input bg-slate-600 input-bordered w-full \".concat((next_font_google_target_css_path_app_components_Room_Chat_tsx_import_Poppins_arguments_weight_500_subsets_latin_variableName_poppins___WEBPACK_IMPORTED_MODULE_2___default().className))\n                    }, void 0, false, {\n                        fileName: \"G:\\\\object_hunt\\\\app\\\\components\\\\Room\\\\Chat.tsx\",\n                        lineNumber: 77,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        className: \"btn btn-primary \".concat((next_font_google_target_css_path_app_components_Room_Chat_tsx_import_Bungee_arguments_weight_400_subsets_latin_variableName_bungee___WEBPACK_IMPORTED_MODULE_3___default().className)),\n                        onClick: props.sendMsg,\n                        children: \"Send\"\n                    }, void 0, false, {\n                        fileName: \"G:\\\\object_hunt\\\\app\\\\components\\\\Room\\\\Chat.tsx\",\n                        lineNumber: 89,\n                        columnNumber: 9\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"G:\\\\object_hunt\\\\app\\\\components\\\\Room\\\\Chat.tsx\",\n                lineNumber: 76,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"G:\\\\object_hunt\\\\app\\\\components\\\\Room\\\\Chat.tsx\",\n        lineNumber: 63,\n        columnNumber: 5\n    }, undefined);\n};\n_s(Chat, \"/JjMiEc4sEjx3DiG+4jrWXzooqI=\");\n_c = Chat;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Chat);\nvar _c;\n$RefreshReg$(_c, \"Chat\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vYXBwL2NvbXBvbmVudHMvUm9vbS9DaGF0LnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBR01BO0FBS0FDO0FBUjJDO0FBb0JqRCxNQUFNSSxPQUFPLENBQUNDOztJQUNaLE1BQU1DLGNBQWNILDZDQUFNQSxDQUFDO0lBRTNCRCxnREFBU0EsQ0FBQztZQUNSLGFBQWE7UUFDYkksc0JBQWtDQTtRQUFsQ0Esd0JBQUFBLHlCQUFBQSxLQUFBQSxJQUFBQSxDQUFBQSx1QkFBQUEsWUFBYUMscUJBQWJELGtDQUFBQSxLQUFBQSxJQUFBQSxxQkFBc0JFLFNBQVMsR0FBR0Ysd0JBQUFBLHlCQUFBQSxLQUFBQSxJQUFBQSxDQUFBQSx3QkFBQUEsWUFBYUMscUJBQWJELG1DQUFBQSxLQUFBQSxJQUFBQSxzQkFBc0JHO0lBQzFELEdBQUc7UUFBQ0osTUFBTUs7S0FBSztJQUVmLFdBQVc7SUFDWCx1Q0FBdUM7SUFDdkMsV0FBVztJQUNYLHVCQUF1QjtJQUN2QiwwQkFBMEI7SUFDMUIsdUhBQXVIO0lBQ3ZILFFBQVE7SUFDUiw2RUFBNkU7SUFDN0UsbUJBQW1CO0lBQ25CLDRCQUE0QjtJQUM1QiwwREFBMEQ7SUFDMUQsMENBQTBDO0lBQzFDLHFCQUFxQjtJQUNyQixjQUFjO0lBQ2QsYUFBYTtJQUNiLFlBQVk7SUFDWixhQUFhO0lBRWIsYUFBYTtJQUNiLG9CQUFvQjtJQUNwQiwwQkFBMEI7SUFDMUIsNEJBQTRCO0lBQzVCLG1DQUFtQztJQUNuQyw4QkFBOEI7SUFDOUIsWUFBWTtJQUNaLFdBQVc7SUFDWCx1REFBdUQ7SUFDdkQsd0NBQXdDO0lBQ3hDLGtIQUFrSDtJQUNsSCxTQUFTO0lBQ1QsV0FBVztJQUNYLEtBQUs7SUFDTCxLQUFLO0lBQ0wscUJBQ0UsOERBQUNDO1FBQUlDLElBQUc7UUFBT0MsV0FBVTs7MEJBQ3ZCLDhEQUFDRjtnQkFBSUUsV0FBVTswQkFBK0M7Ozs7OzswQkFDOUQsOERBQUNGO2dCQUNDQyxJQUFHO2dCQUNIRSxLQUFLUjtnQkFDTE8sV0FBVTswQkFFVFIsTUFBTUssS0FBS0ssSUFBSSxDQUFDQyxHQUEwQ0MsTUFBUUQsRUFBRUUsMEJBQ25FLDhEQUFDUDt3QkFBSUUsV0FBV2Isd0xBQWlCYTs7NEJBQzlCRyxFQUFFRTs0QkFBUzs0QkFBR0YsRUFBRUc7O3VCQURxQkY7Ozs7Ozs7Ozs7MEJBSzVDLDhEQUFDTjtnQkFBSUUsV0FBVTs7a0NBQ2IsOERBQUNPO3dCQUNDQyxNQUFLO3dCQUNMQyxhQUFZO3dCQUNaQyxPQUFPbEIsTUFBTW1CO3dCQUNiQyxXQUFXLENBQUNDOzRCQUNWLElBQUlBLEVBQUVDLFFBQVEsU0FBUztnQ0FDckJ0QixNQUFNdUI7NEJBQ1I7d0JBQ0Y7d0JBQ0FDLFVBQVUsQ0FBQ0gsSUFBTXJCLE1BQU15QixPQUFPSixFQUFFSyxPQUFPUjt3QkFDdkNWLFdBQVcsNENBQThELE9BQWxCYix3TEFBaUJhOzs7Ozs7a0NBRTFFLDhEQUFDbUI7d0JBQU9uQixXQUFXLG1CQUFvQyxPQUFqQmQsc0xBQWdCYzt3QkFBSW9CLFNBQVM1QixNQUFNdUI7a0NBQVM7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1CMUY7R0F2Rk14QjtLQUFBQTtBQXlGTiwrREFBZUEsSUFBSUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvY29tcG9uZW50cy9Sb29tL0NoYXQudHN4PzEyMDAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBCdW5nZWUsIFBvcHBpbnMgfSBmcm9tIFwibmV4dC9mb250L2dvb2dsZVwiO1xuXG5jb25zdCBidW5nZWUgPSBCdW5nZWUoe1xuICB3ZWlnaHQ6IFwiNDAwXCIsXG4gIHN1YnNldHM6IFtcImxhdGluXCJdLFxufSk7XG5cbmNvbnN0IHBvcHBpbnMgPSBQb3BwaW5zKHtcbiAgd2VpZ2h0OiBcIjUwMFwiLFxuICBzdWJzZXRzOiBbXCJsYXRpblwiXSxcbn0pO1xuXG5pbnRlcmZhY2UgUHJvcHMge1xuICBtc2c6IHN0cmluZztcbiAgbXNnczogeyB1c2VybmFtZTogc3RyaW5nOyBtZXNzYWdlOiBzdHJpbmcgfVtdO1xuICBzZXRNc2c6IChtc2c6IHN0cmluZykgPT4gdm9pZDtcbiAgc2VuZE1zZzogKCkgPT4gdm9pZDtcbn1cblxuY29uc3QgQ2hhdCA9IChwcm9wczogUHJvcHMpID0+IHtcbiAgY29uc3QgY2hhdExpc3RSZWYgPSB1c2VSZWYobnVsbCk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY2hhdExpc3RSZWY/LmN1cnJlbnQ/LnNjcm9sbFRvKDAsIGNoYXRMaXN0UmVmPy5jdXJyZW50Py5zY3JvbGxIZWlnaHQpO1xuICB9LCBbcHJvcHMubXNnc10pO1xuXG4gIC8vIHJldHVybiAoXG4gIC8vICAgPGRpdiBjbGFzc05hbWU9XCJwbC0xIHByLTEgaC1mdWxsXCI+XG4gIC8vICAgICA8ZGl2XG4gIC8vICAgICAgIGlkPVwiY2hhdC1saXN0XCJcbiAgLy8gICAgICAgcmVmPXtjaGF0TGlzdFJlZn1cbiAgLy8gICAgICAgY2xhc3NOYW1lPXtgZmxleCBmbGV4LWNvbCBnYXAtMSBiZy1iYXNlLTIwMCB3LWZ1bGwgaC0xLzQgbm9iYXIgbWItMS41IG92ZXJmbG93LXgtc2Nyb2xsICR7cG9wcGlucy5jbGFzc05hbWV9YH1cbiAgLy8gICAgID5cbiAgLy8gICAgICAge3Byb3BzLm1zZ3MubWFwKChtOiB7IHVzZXJuYW1lOiBzdHJpbmc7IG1lc3NhZ2U6IHN0cmluZyB9LCBpZHgpID0+IHtcbiAgLy8gICAgICAgICByZXR1cm4gKFxuICAvLyAgICAgICAgICAgbS51c2VybmFtZSAmJiAoXG4gIC8vICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYmctYmFzZS0yMDAgcC0xXCIga2V5PXtpZHh9PlxuICAvLyAgICAgICAgICAgICAgIHttLnVzZXJuYW1lfToge20ubWVzc2FnZX1cbiAgLy8gICAgICAgICAgICAgPC9kaXY+XG4gIC8vICAgICAgICAgICApXG4gIC8vICAgICAgICAgKTtcbiAgLy8gICAgICAgfSl9XG4gIC8vICAgICA8L2Rpdj5cblxuICAvLyAgICAgPGlucHV0XG4gIC8vICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgLy8gICAgICAgdmFsdWU9e3Byb3BzLm1zZ31cbiAgLy8gICAgICAgb25LZXlEb3duPXsoZSkgPT4ge1xuICAvLyAgICAgICAgIGlmIChlLmtleSA9PT0gXCJFbnRlclwiKSB7XG4gIC8vICAgICAgICAgICBwcm9wcz8uc2VuZE1zZygpO1xuICAvLyAgICAgICAgIH1cbiAgLy8gICAgICAgfX1cbiAgLy8gICAgICAgb25DaGFuZ2U9eyhlKSA9PiBwcm9wcy5zZXRNc2coZS50YXJnZXQudmFsdWUpfVxuICAvLyAgICAgICBwbGFjZWhvbGRlcj1cIlR5cGUgbWVzc2FnZSBoZXJlXCJcbiAgLy8gICAgICAgY2xhc3NOYW1lPXtgaW5wdXQgbGVhZGluZy1ub25lIHJvdW5kZWQgdy1mdWxsIGJnLWJhc2UtMjAwIG1iLTIgc3RleHQtbWcgdGV4dC13aGl0ZSAke3BvcHBpbnMuY2xhc3NOYW1lfWB9XG4gIC8vICAgICAvPlxuICAvLyAgIDwvZGl2PlxuICAvLyApO1xuICAvLyB9O1xuICByZXR1cm4gKFxuICAgIDxkaXYgaWQ9XCJjaGF0XCIgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBtLTIgcC0yIGgtZnVsbFwiPlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LXByaW1hcnkgdGV4dC1sZWZ0IHRleHQteGwgZm9udC1ib2xkIHAtMVwiPkNIQVQ8L2Rpdj5cbiAgICAgIDxkaXZcbiAgICAgICAgaWQ9XCJjaGF0LWxpc3RcIlxuICAgICAgICByZWY9e2NoYXRMaXN0UmVmfVxuICAgICAgICBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIGdhcC0xIHctZnVsbCBwLTIgb3ZlcmZsb3ctYXV0byBoLTQ0XCJcbiAgICAgID5cbiAgICAgICAge3Byb3BzLm1zZ3MubWFwKChtOiB7IHVzZXJuYW1lOiBzdHJpbmc7IG1lc3NhZ2U6IHN0cmluZyB9LCBpZHgpID0+IG0udXNlcm5hbWUgJiYgKFxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtwb3BwaW5zLmNsYXNzTmFtZX0ga2V5PXtpZHh9PlxuICAgICAgICAgICAge20udXNlcm5hbWV9OiB7bS5tZXNzYWdlfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApKX1cbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGdhcC0yIGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWJldHdlZW4gbXQtMlwiPlxuICAgICAgICA8aW5wdXRcbiAgICAgICAgICB0eXBlPVwidGV4dFwiXG4gICAgICAgICAgcGxhY2Vob2xkZXI9XCJUeXBlIGhlcmVcIlxuICAgICAgICAgIHZhbHVlPXtwcm9wcy5tc2d9XG4gICAgICAgICAgb25LZXlEb3duPXsoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGUua2V5ID09PSBcIkVudGVyXCIpIHtcbiAgICAgICAgICAgICAgcHJvcHMuc2VuZE1zZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH19XG4gICAgICAgICAgb25DaGFuZ2U9eyhlKSA9PiBwcm9wcy5zZXRNc2coZS50YXJnZXQudmFsdWUpfVxuICAgICAgICAgIGNsYXNzTmFtZT17YGlucHV0IGJnLXNsYXRlLTYwMCBpbnB1dC1ib3JkZXJlZCB3LWZ1bGwgJHtwb3BwaW5zLmNsYXNzTmFtZX1gfVxuICAgICAgICAvPlxuICAgICAgICA8YnV0dG9uIGNsYXNzTmFtZT17YGJ0biBidG4tcHJpbWFyeSAke2J1bmdlZS5jbGFzc05hbWV9YH0gb25DbGljaz17cHJvcHMuc2VuZE1zZ30+XG4gICAgICAgICAgU2VuZFxuICAgICAgICA8L2J1dHRvbj5cblxuICAgICAgICB7LyogPGJ1dHRvbiBjbGFzc05hbWU9XCJidG5cIiBvbkNsaWNrPXtSZWNpdmVTdGF0ZX0+U1RBVEU8L2J1dHRvbj4gKi99XG5cbiAgICAgICAgey8qIDxpbnB1dFxuICAgICAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cIlR5cGUgaGVyZVwiXG4gICAgICAgICAgICAgICAgdmFsdWU9e21lc3NhZ2V9XG4gICAgICAgICAgICAgICAgb25DaGFuZ2U9eyhlKSA9PiBzZXRNZXNzYWdlKGUudGFyZ2V0LnZhbHVlKX1cbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJpbnB1dCBiZy1zbGF0ZS02MDAgaW5wdXQtYm9yZGVyZWQgdy1mdWxsXCJcbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8YnV0dG9uIGNsYXNzTmFtZT1cImJ0biBidG4tcHJpbWFyeVwiIG9uQ2xpY2s9e3NlbmRNZXNzYWdlfT5cbiAgICAgICAgICAgICAgICBTZW5kXG4gICAgICAgICAgICA8L2J1dHRvbj4gKi99XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IENoYXQ7XG4iXSwibmFtZXMiOlsiYnVuZ2VlIiwicG9wcGlucyIsIlJlYWN0IiwidXNlRWZmZWN0IiwidXNlUmVmIiwiQ2hhdCIsInByb3BzIiwiY2hhdExpc3RSZWYiLCJjdXJyZW50Iiwic2Nyb2xsVG8iLCJzY3JvbGxIZWlnaHQiLCJtc2dzIiwiZGl2IiwiaWQiLCJjbGFzc05hbWUiLCJyZWYiLCJtYXAiLCJtIiwiaWR4IiwidXNlcm5hbWUiLCJtZXNzYWdlIiwiaW5wdXQiLCJ0eXBlIiwicGxhY2Vob2xkZXIiLCJ2YWx1ZSIsIm1zZyIsIm9uS2V5RG93biIsImUiLCJrZXkiLCJzZW5kTXNnIiwib25DaGFuZ2UiLCJzZXRNc2ciLCJ0YXJnZXQiLCJidXR0b24iLCJvbkNsaWNrIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./app/components/Room/Chat.tsx\n"));

/***/ }),

/***/ "(app-client)/./app/components/Room/Leaderboard.tsx":
/*!*********************************************!*\
  !*** ./app/components/Room/Leaderboard.tsx ***!
  \*********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-client)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-client)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n// import { useGlobalContext } from \"@/app/Context/store\";\n\nfunction Leaderboard(props) {\n    _s();\n    const curPlayer = 0;\n    // const [leaderboard, setLeaderboard] = dat;\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n    // setPlayers(...players, [{ name: \"soham\", score: 200 }, { name: \"vineet\", score: 100 }]);\n    // console.log(players);\n    }, []);\n    // for (const name in props.players[0]) {\n    //     players.push(name);\n    // }\n    // props.players[0].map((player: string, idx: React.Key) => {\n    //     players.push(player);\n    // });\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"overflow-x-scroll rounded bg-base-200 m-1 mt-2 nobar lg:h-40 sm:h-72\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"table\", {\n            className: \"table center border-separate bg-base-200 p-1 rounded-lg table-pin-rows\",\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"thead\", {\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"tr\", {\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"th\", {\n                                className: \"text-primary font-semibold\",\n                                children: \"#\"\n                            }, void 0, false, {\n                                fileName: \"G:\\\\object_hunt\\\\app\\\\components\\\\Room\\\\Leaderboard.tsx\",\n                                lineNumber: 33,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"th\", {\n                                className: \"text-primary font-semibold\",\n                                children: \"Name\"\n                            }, void 0, false, {\n                                fileName: \"G:\\\\object_hunt\\\\app\\\\components\\\\Room\\\\Leaderboard.tsx\",\n                                lineNumber: 34,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"th\", {\n                                className: \"text-primary font-semibold\",\n                                children: \"Score\"\n                            }, void 0, false, {\n                                fileName: \"G:\\\\object_hunt\\\\app\\\\components\\\\Room\\\\Leaderboard.tsx\",\n                                lineNumber: 35,\n                                columnNumber: 13\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"G:\\\\object_hunt\\\\app\\\\components\\\\Room\\\\Leaderboard.tsx\",\n                        lineNumber: 32,\n                        columnNumber: 11\n                    }, this)\n                }, void 0, false, {\n                    fileName: \"G:\\\\object_hunt\\\\app\\\\components\\\\Room\\\\Leaderboard.tsx\",\n                    lineNumber: 31,\n                    columnNumber: 9\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"tbody\", {\n                    children: props.data && Object.entries(props.data).map((param, idx)=>{\n                        let [key, player] = param;\n                        /*#__PURE__*/ return (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"tr\", {\n                            className: idx === curPlayer && \"bg-primary text-black\" || \"\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                    children: idx + 1\n                                }, void 0, false, {\n                                    fileName: \"G:\\\\object_hunt\\\\app\\\\components\\\\Room\\\\Leaderboard.tsx\",\n                                    lineNumber: 44,\n                                    columnNumber: 15\n                                }, this),\n                                (player === null || player === void 0 ? void 0 : player.name) ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                    children: player === null || player === void 0 ? void 0 : player.name\n                                }, void 0, false, {\n                                    fileName: \"G:\\\\object_hunt\\\\app\\\\components\\\\Room\\\\Leaderboard.tsx\",\n                                    lineNumber: 45,\n                                    columnNumber: 31\n                                }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                    children: \"---\"\n                                }, void 0, false, {\n                                    fileName: \"G:\\\\object_hunt\\\\app\\\\components\\\\Room\\\\Leaderboard.tsx\",\n                                    lineNumber: 45,\n                                    columnNumber: 57\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                    children: player === null || player === void 0 ? void 0 : player.score\n                                }, void 0, false, {\n                                    fileName: \"G:\\\\object_hunt\\\\app\\\\components\\\\Room\\\\Leaderboard.tsx\",\n                                    lineNumber: 46,\n                                    columnNumber: 16\n                                }, this)\n                            ]\n                        }, idx, true, {\n                            fileName: \"G:\\\\object_hunt\\\\app\\\\components\\\\Room\\\\Leaderboard.tsx\",\n                            lineNumber: 40,\n                            columnNumber: 13\n                        }, this);\n                    })\n                }, void 0, false, {\n                    fileName: \"G:\\\\object_hunt\\\\app\\\\components\\\\Room\\\\Leaderboard.tsx\",\n                    lineNumber: 38,\n                    columnNumber: 9\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"G:\\\\object_hunt\\\\app\\\\components\\\\Room\\\\Leaderboard.tsx\",\n            lineNumber: 30,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"G:\\\\object_hunt\\\\app\\\\components\\\\Room\\\\Leaderboard.tsx\",\n        lineNumber: 29,\n        columnNumber: 5\n    }, this);\n}\n_s(Leaderboard, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\n_c = Leaderboard;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Leaderboard);\nvar _c;\n$RefreshReg$(_c, \"Leaderboard\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vYXBwL2NvbXBvbmVudHMvUm9vbS9MZWFkZXJib2FyZC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBRUEsMERBQTBEO0FBQ2pCO0FBTXpDLFNBQVNFLFlBQVlDLEtBQVk7O0lBQy9CLE1BQU1DLFlBQVk7SUFFbEIsNkNBQTZDO0lBRTdDSCxnREFBU0EsQ0FBQztJQUNSLDJGQUEyRjtJQUMzRix3QkFBd0I7SUFDMUIsR0FBRyxFQUFFO0lBRUwseUNBQXlDO0lBQ3pDLDBCQUEwQjtJQUMxQixJQUFJO0lBRUosNkRBQTZEO0lBQzdELDRCQUE0QjtJQUM1QixNQUFNO0lBRU4scUJBQ0UsOERBQUNJO1FBQUlDLFdBQVU7a0JBQ2IsNEVBQUNDO1lBQU1ELFdBQVU7OzhCQUNmLDhEQUFDRTs4QkFDQyw0RUFBQ0M7OzBDQUNDLDhEQUFDQztnQ0FBR0osV0FBVTswQ0FBNkI7Ozs7OzswQ0FDM0MsOERBQUNJO2dDQUFHSixXQUFVOzBDQUE2Qjs7Ozs7OzBDQUMzQyw4REFBQ0k7Z0NBQUdKLFdBQVU7MENBQTZCOzs7Ozs7Ozs7Ozs7Ozs7Ozs4QkFHL0MsOERBQUNLOzhCQUNFUixNQUFNUyxRQUFRQyxPQUFPQyxRQUFRWCxNQUFNUyxNQUFNRyxJQUFJLFFBQWdCQzs0QkFBZixDQUFDQyxLQUFLQyxPQUFPO3NDQUMxRCxxRUFBQ1Q7NEJBRUNILFdBQVcsUUFBU0YsYUFBYywyQkFBMkI7OzhDQUU3RCw4REFBQ2U7OENBQUlILE1BQU07Ozs7OztnQ0FDVkUsQ0FBQUEsbUJBQUFBLG9CQUFBQSxLQUFBQSxJQUFBQSxPQUFRRSxJQUFHLGtCQUFJLDhEQUFDRDs4Q0FBSUQsbUJBQUFBLG9CQUFBQSxLQUFBQSxJQUFBQSxPQUFRRTs7Ozs7eURBQWEsOERBQUNEOzhDQUFHOzs7Ozs7OENBQzdDLDhEQUFDQTs4Q0FBSUQsbUJBQUFBLG9CQUFBQSxLQUFBQSxJQUFBQSxPQUFRRzs7Ozs7OzsyQkFMVEw7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFZbkI7R0EzQ1NkO0tBQUFBO0FBNkNULCtEQUFlQSxXQUFXQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2FwcC9jb21wb25lbnRzL1Jvb20vTGVhZGVyYm9hcmQudHN4PzgyMzgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cbi8vIGltcG9ydCB7IHVzZUdsb2JhbENvbnRleHQgfSBmcm9tIFwiQC9hcHAvQ29udGV4dC9zdG9yZVwiO1xuaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCB9IGZyb20gXCJyZWFjdFwiO1xuXG5pbnRlcmZhY2UgUHJvcHMge1xuICBkYXRhOiBhbnlbXTtcbn1cblxuZnVuY3Rpb24gTGVhZGVyYm9hcmQocHJvcHM6IFByb3BzKSB7XG4gIGNvbnN0IGN1clBsYXllciA9IDA7XG5cbiAgLy8gY29uc3QgW2xlYWRlcmJvYXJkLCBzZXRMZWFkZXJib2FyZF0gPSBkYXQ7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBzZXRQbGF5ZXJzKC4uLnBsYXllcnMsIFt7IG5hbWU6IFwic29oYW1cIiwgc2NvcmU6IDIwMCB9LCB7IG5hbWU6IFwidmluZWV0XCIsIHNjb3JlOiAxMDAgfV0pO1xuICAgIC8vIGNvbnNvbGUubG9nKHBsYXllcnMpO1xuICB9LCBbXSk7XG5cbiAgLy8gZm9yIChjb25zdCBuYW1lIGluIHByb3BzLnBsYXllcnNbMF0pIHtcbiAgLy8gICAgIHBsYXllcnMucHVzaChuYW1lKTtcbiAgLy8gfVxuXG4gIC8vIHByb3BzLnBsYXllcnNbMF0ubWFwKChwbGF5ZXI6IHN0cmluZywgaWR4OiBSZWFjdC5LZXkpID0+IHtcbiAgLy8gICAgIHBsYXllcnMucHVzaChwbGF5ZXIpO1xuICAvLyB9KTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwib3ZlcmZsb3cteC1zY3JvbGwgcm91bmRlZCBiZy1iYXNlLTIwMCBtLTEgbXQtMiBub2JhciBsZzpoLTQwIHNtOmgtNzJcIj5cbiAgICAgIDx0YWJsZSBjbGFzc05hbWU9XCJ0YWJsZSBjZW50ZXIgYm9yZGVyLXNlcGFyYXRlIGJnLWJhc2UtMjAwIHAtMSByb3VuZGVkLWxnIHRhYmxlLXBpbi1yb3dzXCI+XG4gICAgICAgIDx0aGVhZD5cbiAgICAgICAgICA8dHI+XG4gICAgICAgICAgICA8dGggY2xhc3NOYW1lPVwidGV4dC1wcmltYXJ5IGZvbnQtc2VtaWJvbGRcIj4jPC90aD5cbiAgICAgICAgICAgIDx0aCBjbGFzc05hbWU9XCJ0ZXh0LXByaW1hcnkgZm9udC1zZW1pYm9sZFwiPk5hbWU8L3RoPlxuICAgICAgICAgICAgPHRoIGNsYXNzTmFtZT1cInRleHQtcHJpbWFyeSBmb250LXNlbWlib2xkXCI+U2NvcmU8L3RoPlxuICAgICAgICAgIDwvdHI+XG4gICAgICAgIDwvdGhlYWQ+XG4gICAgICAgIDx0Ym9keT5cbiAgICAgICAgICB7cHJvcHMuZGF0YSAmJiBPYmplY3QuZW50cmllcyhwcm9wcy5kYXRhKS5tYXAoKFtrZXksIHBsYXllcl0sIGlkeCkgPT4gKFxuICAgICAgICAgICAgPHRyXG4gICAgICAgICAgICAgIGtleT17aWR4fVxuICAgICAgICAgICAgICBjbGFzc05hbWU9eyhpZHggPT09IGN1clBsYXllciAmJiBgYmctcHJpbWFyeSB0ZXh0LWJsYWNrYCkgfHwgXCJcIn1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgPHRkPntpZHggKyAxfTwvdGQ+XG4gICAgICAgICAgICAgIHtwbGF5ZXI/Lm5hbWUgPyA8dGQ+e3BsYXllcj8ubmFtZX08L3RkPiA6IDx0ZD4tLS08L3RkPn1cbiAgICAgICAgICAgICAgezx0ZD57cGxheWVyPy5zY29yZX08L3RkPn1cbiAgICAgICAgICAgIDwvdHI+XG4gICAgICAgICAgKSl9XG4gICAgICAgIDwvdGJvZHk+XG4gICAgICA8L3RhYmxlPlxuICAgIDwvZGl2PlxuICApO1xufVxuXG5leHBvcnQgZGVmYXVsdCBMZWFkZXJib2FyZDtcbiJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZUVmZmVjdCIsIkxlYWRlcmJvYXJkIiwicHJvcHMiLCJjdXJQbGF5ZXIiLCJkaXYiLCJjbGFzc05hbWUiLCJ0YWJsZSIsInRoZWFkIiwidHIiLCJ0aCIsInRib2R5IiwiZGF0YSIsIk9iamVjdCIsImVudHJpZXMiLCJtYXAiLCJpZHgiLCJrZXkiLCJwbGF5ZXIiLCJ0ZCIsIm5hbWUiLCJzY29yZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./app/components/Room/Leaderboard.tsx\n"));

/***/ }),

/***/ "(app-client)/./app/g/page.tsx":
/*!************************!*\
  !*** ./app/g/page.tsx ***!
  \************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-client)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var next_font_google_target_css_path_app_g_page_tsx_import_Bungee_arguments_weight_400_subsets_latin_variableName_font___WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! next/font/google/target.css?{\"path\":\"app\\\\g\\\\page.tsx\",\"import\":\"Bungee\",\"arguments\":[{\"weight\":\"400\",\"subsets\":[\"latin\"]}],\"variableName\":\"font\"} */ \"(app-client)/./node_modules/next/font/google/target.css?{\\\"path\\\":\\\"app\\\\\\\\g\\\\\\\\page.tsx\\\",\\\"import\\\":\\\"Bungee\\\",\\\"arguments\\\":[{\\\"weight\\\":\\\"400\\\",\\\"subsets\\\":[\\\"latin\\\"]}],\\\"variableName\\\":\\\"font\\\"}\");\n/* harmony import */ var next_font_google_target_css_path_app_g_page_tsx_import_Bungee_arguments_weight_400_subsets_latin_variableName_font___WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(next_font_google_target_css_path_app_g_page_tsx_import_Bungee_arguments_weight_400_subsets_latin_variableName_font___WEBPACK_IMPORTED_MODULE_11__);\n/* harmony import */ var next_font_google_target_css_path_app_g_page_tsx_import_Poppins_arguments_weight_400_500_600_700_subsets_latin_variableName_poppins___WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! next/font/google/target.css?{\"path\":\"app\\\\g\\\\page.tsx\",\"import\":\"Poppins\",\"arguments\":[{\"weight\":[\"400\",\"500\",\"600\",\"700\"],\"subsets\":[\"latin\"]}],\"variableName\":\"poppins\"} */ \"(app-client)/./node_modules/next/font/google/target.css?{\\\"path\\\":\\\"app\\\\\\\\g\\\\\\\\page.tsx\\\",\\\"import\\\":\\\"Poppins\\\",\\\"arguments\\\":[{\\\"weight\\\":[\\\"400\\\",\\\"500\\\",\\\"600\\\",\\\"700\\\"],\\\"subsets\\\":[\\\"latin\\\"]}],\\\"variableName\\\":\\\"poppins\\\"}\");\n/* harmony import */ var next_font_google_target_css_path_app_g_page_tsx_import_Poppins_arguments_weight_400_500_600_700_subsets_latin_variableName_poppins___WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(next_font_google_target_css_path_app_g_page_tsx_import_Poppins_arguments_weight_400_500_600_700_subsets_latin_variableName_poppins___WEBPACK_IMPORTED_MODULE_10__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-client)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/navigation */ \"(app-client)/./node_modules/next/navigation.js\");\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_navigation__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _lib_coly__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/lib/coly */ \"(app-client)/./lib/coly.ts\");\n/* harmony import */ var _components_Modal__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../components/Modal */ \"(app-client)/./app/components/Modal.tsx\");\n/* harmony import */ var _Context_store__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Context/store */ \"(app-client)/./app/Context/store.tsx\");\n/* harmony import */ var _components_ImgSlider__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../components/ImgSlider */ \"(app-client)/./app/components/ImgSlider.tsx\");\n/* harmony import */ var _components_Room_Capture__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../components/Room/Capture */ \"(app-client)/./app/components/Room/Capture.tsx\");\n/* harmony import */ var _components_Room_Chat__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../components/Room/Chat */ \"(app-client)/./app/components/Room/Chat.tsx\");\n/* harmony import */ var _components_Room_Leaderboard__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../components/Room/Leaderboard */ \"(app-client)/./app/components/Room/Leaderboard.tsx\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n// import TabManager from \"../components/TabManager\";\n// Logical components\n// import { useGlobalContext } from \"../Context/store\";\n// import useGameState from \"../components/useGameState\";\n\n\n\n\n\n\nconst prevTime = new Date().getTime();\nconst getCurTime = ()=>{\n    return Math.round((new Date().getTime() - prevTime) / 600);\n};\nconst page = ()=>{\n    _s();\n    // Multiplayer\n    const searchParams = (0,next_navigation__WEBPACK_IMPORTED_MODULE_2__.useSearchParams)();\n    const [roomId, setRoomId] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const [isRC, setIsRC] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [room, setRoom] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    // Chat\n    const [msg, setMsg] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const [msgs, setMsgs] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([\n        {\n            username: \"\",\n            message: \"\"\n        }\n    ]);\n    // Leaderboard\n    const [leaderboard, setLeaderboard] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([\n        {\n            username: \"\",\n            score: 0\n        }\n    ]);\n    // Tab Manager\n    const [activeTab, setActiveTab] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    // const [players, setPlayers] = useState([\"\"]);\n    const [objname, setObjname] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const [score, setScore] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [round, setRound] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [time, setTime] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [canRetakeImage, setCanRetakeImage] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    // const [myId, setMyId] = useState(\"\");\n    const [ready, setReady] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [gameState, setGameState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"started\");\n    // const [gameState, setGameState] = useState(\"waiting\");\n    const [roundState, setRoundState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const slideImages = [\n        {\n            url: \"https://images.unsplash.com/photo-1509721434272-b79147e0e708?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1500&q=80\",\n            caption: \"Player 1\"\n        },\n        {\n            url: \"https://images.unsplash.com/photo-1506710507565-203b9f24669b?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1536&q=80\",\n            caption: \"Player 2\"\n        },\n        {\n            url: \"https://images.unsplash.com/photo-1536987333706-fc9adfb10d91?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1500&q=80\",\n            caption: \"Player 3\"\n        }\n    ];\n    const [playersResponse, setPlayersResponse] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([\n        {\n            img: \"\",\n            name: \"\",\n            matched: undefined\n        }\n    ]);\n    const Ready = ()=>{\n        console.log(\"ROOM OBJ\", room);\n        if (ready) return;\n        console.log(\"Ready\", getCurTime());\n        room.send(\"ready\");\n        setReady(true);\n    };\n    const GameStarts = (payload)=>{\n        console.log(\"Game Starts\");\n        setGameState(\"started\");\n        setLeaderboard(payload.leaderboard);\n    };\n    const GameEnds = (payload)=>{\n        console.log(\"Game Ends\");\n        setGameState(\"ended\");\n        setLeaderboard(payload.leaderboard);\n        setActiveTab(1);\n    };\n    const RoundStarts = (payload)=>{\n        console.log(\"Round Starts\", getCurTime(), payload.curRound);\n        setRoundState(\"started\");\n        setCanRetakeImage(true);\n        setObjname(payload.objname);\n        setRound(payload.curRound + 1);\n        startCounter(payload.time);\n    };\n    const RoundEnds = (payload)=>{\n        console.log(\"Round Ends\", getCurTime(), payload.curScore);\n        console.log(payload.imgs);\n        setRoundState(\"ended\");\n        // console.log(payload);\n        setCanRetakeImage(false);\n        setPlayersResponse(payload.imgs);\n        setLeaderboard(payload.leaderboard);\n        setScore(payload.curScore);\n    };\n    const submitImage = (image)=>{\n        console.log(\"Sending image\", image === null || image === void 0 ? void 0 : image.substring(0, 3));\n        room.send(\"img\", image);\n    };\n    const sendMsg = ()=>{\n        if (!msg) return;\n        if (!room) return;\n        console.log(\"Sending msg\", msg);\n        room.send(\"chat\", msg);\n        // room.send(\"chat\", {username: localStorage.getItem(\"username\"), message: msg});\n        setMsg(\"\");\n    };\n    const appendMsgs = (msg)=>{\n        // append msg to msgs using setMsgs\n        msgs.push(msg);\n        setMsgs(msgs.slice());\n        console.log(msgs);\n    };\n    // useEffect(() => {\n    //   router.refresh();\n    //   console.log(\"ROUTER REFRESH\");\n    // }\n    // , [msgs]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const id = searchParams.get(\"id\") || undefined;\n        const isRoomCreator = searchParams.get(\"rc\") || false;\n        setRoomId(id || \"\");\n        setIsRC(isRoomCreator === \"true\" ? true : false);\n        console.log(\"ID\", id);\n        console.log(\"isRoomCreator\", isRoomCreator);\n        onJoin(id);\n        function GameplaySetup(_room, isRoomCreator) {\n            console.log(\"JOINED ROOM\", _room);\n            setRoom(_room);\n            if (isRoomCreator) {\n                console.log(\"ROOM ID\", _room.id);\n                setRoomId(_room.id);\n            } else {\n                // call Ready() after 5 seconds\n                setTimeout(()=>{\n                    if (ready) return;\n                    console.log(\"AUTO READY\", getCurTime());\n                    _room.send(\"ready\");\n                    setReady(true);\n                }, 5000);\n            }\n            _room.onMessage(\"gameStarts\", (payload)=>GameStarts(payload));\n            _room.onMessage(\"gameEnds\", (payload)=>GameEnds(payload));\n            _room.onMessage(\"roundStarts\", (payload)=>{\n                RoundStarts(payload);\n            });\n            _room.onMessage(\"roundEnds\", (payload)=>{\n                RoundEnds(payload);\n            });\n            _room.onMessage(\"chat\", (msg)=>{\n                appendMsgs(msg);\n            });\n        }\n        function onJoin(id) {\n            if (id) {\n                _lib_coly__WEBPACK_IMPORTED_MODULE_3__[\"default\"].client.joinById(id).then((_room)=>{\n                    GameplaySetup(_room, false);\n                // setRoom(_room);\n                // console.log(\"JOINED ROOM\", _room);\n                }).catch((e)=>{\n                    alert(\"Error: joining room, try again with valid room id\");\n                    console.log(\"JOIN ERROR\", e);\n                });\n            } else {\n                _lib_coly__WEBPACK_IMPORTED_MODULE_3__[\"default\"].client.joinOrCreate(\"my_room\", {\n                    username: localStorage.getItem(\"username\")\n                }).then((_room)=>{\n                    const _isRC = searchParams.get(\"rc\") === \"true\" || false;\n                    console.log(\"IS RC\", _isRC);\n                    GameplaySetup(_room, _isRC);\n                // room.onMessage(\"img\", (message: string) => {\n                //   console.log(\"IMG \" + message);\n                // });\n                // room.onMessage(\"ready\", OnReadyMsgs);\n                }).catch((e)=>{\n                    alert(\"Error: joining room, try again with valid room id\");\n                    console.log(\"JOIN ERROR\", e);\n                });\n            }\n        }\n        // function OnChatMsgs(message: string) {}\n        // function OnImgMsgs(message: string) {}\n        // function OnReadyMsgs(message: string) {}\n        // function onConnect() {\n        //   setIsConnected(true);\n        // }\n        // function onDisconnect() {\n        //   setIsConnected(false);\n        // }\n        // function onMessage(data: any) {\n        //   setMsgs(data);\n        // }\n        // function onRoundStart(data: any) {\n        //   setRoundState(\"started\");\n        //   console.log(data);\n        //   setObjname(data.objectname);\n        //   setScore(data.score);\n        //   setRound(data.round);\n        //   startCounter(data.time);\n        // }\n        // function onRoundEnd(data: any) {\n        //   setRoundState(\"ended\");\n        //   tabState[1](1);\n        //   let players_res: { name: any; data: any }[] = [];\n        //   const dataa = data.data;\n        //   // Object.keys(dataa).forEach((key) => {\n        //   //   // players_res.push({ name: key, data: dataa[key] });\n        //   // });\n        //   setPlayersResponse(dataa);\n        //   console.log(dataa);\n        //   // setPlayersResponse(players_res);\n        // }\n        // function onLeaderboard(data: any) {\n        //   setLeaderboard(data);\n        // }\n        // function onGameState(data: any) {\n        //   setGameState(data);\n        //   console.log(\"Game State: \", data);\n        // }\n        // socket.on(\"connect\", onConnect);\n        // socket.on(\"disconnect\", onDisconnect);\n        // socket.on(\"gamestate\", onGameState);\n        // socket.on(\"message\", onMessage);\n        // socket.on(\"roundstart\", onRoundStart);\n        // socket.on(\"roundend\", onRoundEnd);\n        // socket.on(\"leaderboard\", onLeaderboard);\n        // connect();\n        return ()=>{\n        // socket.off(\"connect\", onConnect);\n        // socket.off(\"disconnect\", onDisconnect);\n        // socket.off(\"gamestate\", onGameState);\n        // socket.off(\"message\", onMessage);\n        // socket.off(\"roundstart\", onRoundStart);\n        // socket.off(\"roundend\", onRoundEnd);\n        // socket.off(\"leaderboard\", onLeaderboard);\n        };\n    }, []);\n    // function connect() {\n    //   try {\n    //     socket.connect();\n    //     socket.emit(\"join\", localStorage.getItem(\"username\") || \"unknown\");\n    //     socket.emit(\"ready\", ready);\n    //     setIsConnected(true);\n    //   } catch (err) {\n    //     alert(\"Error connecting to server\");\n    //     console.log(err);\n    //   }\n    // }\n    // function disconnect() {\n    //   socket.disconnect();\n    //   setIsConnected(false);\n    // }\n    async function startCounter(delay) {\n        for(let i = delay; i >= 0; i--){\n            setTime(i);\n            await new Promise((resolve)=>setTimeout(resolve, 1000));\n        }\n    // for (let i = 0; i <= delay; i++) {\n    //   setTime(delay - i);\n    //   await new Promise((resolve) => setTimeout(resolve, 1000));\n    // }\n    }\n    const { username } = (0,_Context_store__WEBPACK_IMPORTED_MODULE_5__.useGlobalContext)();\n    // const setMsg = (msg: string) => {\n    //   updateMsg(msg);\n    // };\n    // const setMsgs = (msgs: string[]) => {\n    //   // updateMsgs(msgs);\n    // };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"relative h-full\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"\".concat((next_font_google_target_css_path_app_g_page_tsx_import_Poppins_arguments_weight_400_500_600_700_subsets_latin_variableName_poppins___WEBPACK_IMPORTED_MODULE_10___default().className))\n            }, void 0, false, {\n                fileName: \"G:\\\\object_hunt\\\\app\\\\g\\\\page.tsx\",\n                lineNumber: 364,\n                columnNumber: 7\n            }, undefined),\n            gameState === \"waiting\" && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Modal__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n                customClose: [\n                    \"Quit\",\n                    \"/menu\"\n                ],\n                enable: true,\n                defaultOpen: true,\n                actions: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    children: ready ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"font-semibold text-lg \".concat((next_font_google_target_css_path_app_g_page_tsx_import_Poppins_arguments_weight_400_500_600_700_subsets_latin_variableName_poppins___WEBPACK_IMPORTED_MODULE_10___default().className)),\n                        children: \"Wait for others\"\n                    }, void 0, false, void 0, void 0) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        disabled: !room,\n                        className: \"btn btn-secondary font-bold \".concat((next_font_google_target_css_path_app_g_page_tsx_import_Poppins_arguments_weight_400_500_600_700_subsets_latin_variableName_poppins___WEBPACK_IMPORTED_MODULE_10___default().className)),\n                        onClick: ()=>{\n                            Ready();\n                        },\n                        children: \"Ready\"\n                    }, void 0, false, void 0, void 0)\n                }, void 0, false, void 0, void 0),\n                id: \"a\",\n                btnname: \"LOL\",\n                title: \"Object Hunt\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"flex flex-col gap-2\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                            className: \"text-2xl\",\n                            children: \"Are you ready to Play?\"\n                        }, void 0, false, {\n                            fileName: \"G:\\\\object_hunt\\\\app\\\\g\\\\page.tsx\",\n                            lineNumber: 394,\n                            columnNumber: 13\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                            className: \"font-bold \".concat((next_font_google_target_css_path_app_g_page_tsx_import_Poppins_arguments_weight_400_500_600_700_subsets_latin_variableName_poppins___WEBPACK_IMPORTED_MODULE_10___default().className)),\n                            children: \"Click on the below button and wait for the other players\"\n                        }, void 0, false, {\n                            fileName: \"G:\\\\object_hunt\\\\app\\\\g\\\\page.tsx\",\n                            lineNumber: 395,\n                            columnNumber: 13\n                        }, undefined),\n                        isRC && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                            className: \"font-bold \".concat((next_font_google_target_css_path_app_g_page_tsx_import_Poppins_arguments_weight_400_500_600_700_subsets_latin_variableName_poppins___WEBPACK_IMPORTED_MODULE_10___default().className)),\n                            children: [\n                                \"Room Id:\",\n                                \" \",\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                    onClick: ()=>{\n                                        navigator.clipboard.writeText(roomId);\n                                    },\n                                    className: \"text-primary bg-zinc-800 p-1 rounded-md \".concat((next_font_google_target_css_path_app_g_page_tsx_import_Poppins_arguments_weight_400_500_600_700_subsets_latin_variableName_poppins___WEBPACK_IMPORTED_MODULE_10___default().className)),\n                                    children: roomId\n                                }, void 0, false, {\n                                    fileName: \"G:\\\\object_hunt\\\\app\\\\g\\\\page.tsx\",\n                                    lineNumber: 401,\n                                    columnNumber: 17\n                                }, undefined)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"G:\\\\object_hunt\\\\app\\\\g\\\\page.tsx\",\n                            lineNumber: 399,\n                            columnNumber: 15\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"G:\\\\object_hunt\\\\app\\\\g\\\\page.tsx\",\n                    lineNumber: 393,\n                    columnNumber: 11\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"G:\\\\object_hunt\\\\app\\\\g\\\\page.tsx\",\n                lineNumber: 366,\n                columnNumber: 9\n            }, undefined),\n            gameState === \"ended\" && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Modal__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n                customClose: [\n                    \"Quit\",\n                    \"/menu\"\n                ],\n                enable: true,\n                defaultOpen: true,\n                id: \"gameended\",\n                btnname: \"LOL\",\n                title: \"Game Ended\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Room_Leaderboard__WEBPACK_IMPORTED_MODULE_9__[\"default\"], {\n                    data: leaderboard\n                }, void 0, false, {\n                    fileName: \"G:\\\\object_hunt\\\\app\\\\g\\\\page.tsx\",\n                    lineNumber: 424,\n                    columnNumber: 11\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"G:\\\\object_hunt\\\\app\\\\g\\\\page.tsx\",\n                lineNumber: 416,\n                columnNumber: 9\n            }, undefined),\n            roundState === \"ended\" && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Modal__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n                enable: true,\n                defaultOpen: true,\n                id: \"RoundEnd\",\n                title: \"Round End\",\n                btnname: \"lol\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ImgSlider__WEBPACK_IMPORTED_MODULE_6__[\"default\"], {\n                    data: playersResponse,\n                    objname: objname\n                }, void 0, false, {\n                    fileName: \"G:\\\\object_hunt\\\\app\\\\g\\\\page.tsx\",\n                    lineNumber: 436,\n                    columnNumber: 11\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"G:\\\\object_hunt\\\\app\\\\g\\\\page.tsx\",\n                lineNumber: 429,\n                columnNumber: 9\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"my-2\"\n            }, void 0, false, {\n                fileName: \"G:\\\\object_hunt\\\\app\\\\g\\\\page.tsx\",\n                lineNumber: 440,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"bg-base-200 p-2 m-1 rounded-md flex justify-between\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"text-xl \".concat((next_font_google_target_css_path_app_g_page_tsx_import_Bungee_arguments_weight_400_subsets_latin_variableName_font___WEBPACK_IMPORTED_MODULE_11___default().className)),\n                        children: [\n                            \"Find a\",\n                            \" \",\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                className: \"text-primary capitalize \".concat((next_font_google_target_css_path_app_g_page_tsx_import_Bungee_arguments_weight_400_subsets_latin_variableName_font___WEBPACK_IMPORTED_MODULE_11___default().className)),\n                                children: objname || \"Object\"\n                            }, void 0, false, {\n                                fileName: \"G:\\\\object_hunt\\\\app\\\\g\\\\page.tsx\",\n                                lineNumber: 447,\n                                columnNumber: 11\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"G:\\\\object_hunt\\\\app\\\\g\\\\page.tsx\",\n                        lineNumber: 445,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"text-xl \".concat((next_font_google_target_css_path_app_g_page_tsx_import_Poppins_arguments_weight_400_500_600_700_subsets_latin_variableName_poppins___WEBPACK_IMPORTED_MODULE_10___default().className)),\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {}, void 0, false),\n                            time,\n                            \"s left\"\n                        ]\n                    }, void 0, true, {\n                        fileName: \"G:\\\\object_hunt\\\\app\\\\g\\\\page.tsx\",\n                        lineNumber: 451,\n                        columnNumber: 9\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"G:\\\\object_hunt\\\\app\\\\g\\\\page.tsx\",\n                lineNumber: 444,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"flex justify-between text-md m-1 bg-base-200 p-2 \".concat((next_font_google_target_css_path_app_g_page_tsx_import_Poppins_arguments_weight_400_500_600_700_subsets_latin_variableName_poppins___WEBPACK_IMPORTED_MODULE_10___default().className), \" rounded-md\"),\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        children: [\n                            \"Score: \",\n                            score\n                        ]\n                    }, void 0, true, {\n                        fileName: \"G:\\\\object_hunt\\\\app\\\\g\\\\page.tsx\",\n                        lineNumber: 463,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        children: [\n                            \"Round: \",\n                            round\n                        ]\n                    }, void 0, true, {\n                        fileName: \"G:\\\\object_hunt\\\\app\\\\g\\\\page.tsx\",\n                        lineNumber: 464,\n                        columnNumber: 9\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"G:\\\\object_hunt\\\\app\\\\g\\\\page.tsx\",\n                lineNumber: 460,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"h-full bg-red-500\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Room_Capture__WEBPACK_IMPORTED_MODULE_7__[\"default\"], {\n                        submitImage: submitImage,\n                        canRetake: canRetakeImage\n                    }, void 0, false, {\n                        fileName: \"G:\\\\object_hunt\\\\app\\\\g\\\\page.tsx\",\n                        lineNumber: 468,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"tabs tabs-boxed m-1 mt-1.5\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                className: activeTab == 0 && \"tab-active tab w-1/2 \".concat((next_font_google_target_css_path_app_g_page_tsx_import_Bungee_arguments_weight_400_subsets_latin_variableName_font___WEBPACK_IMPORTED_MODULE_11___default().className)) || \"tab w-1/2 \".concat((next_font_google_target_css_path_app_g_page_tsx_import_Bungee_arguments_weight_400_subsets_latin_variableName_font___WEBPACK_IMPORTED_MODULE_11___default().className)),\n                                onClick: ()=>setActiveTab(0),\n                                children: \"Chat\"\n                            }, void 0, false, {\n                                fileName: \"G:\\\\object_hunt\\\\app\\\\g\\\\page.tsx\",\n                                lineNumber: 470,\n                                columnNumber: 11\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                className: activeTab == 1 && \"tab-active tab w-1/2 \".concat((next_font_google_target_css_path_app_g_page_tsx_import_Bungee_arguments_weight_400_subsets_latin_variableName_font___WEBPACK_IMPORTED_MODULE_11___default().className)) || \"tab w-1/2 \".concat((next_font_google_target_css_path_app_g_page_tsx_import_Bungee_arguments_weight_400_subsets_latin_variableName_font___WEBPACK_IMPORTED_MODULE_11___default().className)),\n                                onClick: ()=>setActiveTab(1),\n                                children: \"Leaderboard\"\n                            }, void 0, false, {\n                                fileName: \"G:\\\\object_hunt\\\\app\\\\g\\\\page.tsx\",\n                                lineNumber: 479,\n                                columnNumber: 11\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"G:\\\\object_hunt\\\\app\\\\g\\\\page.tsx\",\n                        lineNumber: 469,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"bg-blue-500 h-full w-full flex-1\",\n                        children: [\n                            activeTab == 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Room_Chat__WEBPACK_IMPORTED_MODULE_8__[\"default\"], {\n                                msg: msg,\n                                msgs: msgs,\n                                setMsg: setMsg,\n                                sendMsg: sendMsg\n                            }, void 0, false, {\n                                fileName: \"G:\\\\object_hunt\\\\app\\\\g\\\\page.tsx\",\n                                lineNumber: 491,\n                                columnNumber: 13\n                            }, undefined),\n                            activeTab == 1 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Room_Leaderboard__WEBPACK_IMPORTED_MODULE_9__[\"default\"], {\n                                data: leaderboard\n                            }, void 0, false, {\n                                fileName: \"G:\\\\object_hunt\\\\app\\\\g\\\\page.tsx\",\n                                lineNumber: 493,\n                                columnNumber: 30\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"G:\\\\object_hunt\\\\app\\\\g\\\\page.tsx\",\n                        lineNumber: 489,\n                        columnNumber: 9\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"G:\\\\object_hunt\\\\app\\\\g\\\\page.tsx\",\n                lineNumber: 467,\n                columnNumber: 7\n            }, undefined),\n             false && /*#__PURE__*/ 0\n        ]\n    }, void 0, true, {\n        fileName: \"G:\\\\object_hunt\\\\app\\\\g\\\\page.tsx\",\n        lineNumber: 363,\n        columnNumber: 5\n    }, undefined);\n};\n_s(page, \"6kU3kg+AFZK3HUdcfHgzd3gIGSA=\", false, function() {\n    return [\n        next_navigation__WEBPACK_IMPORTED_MODULE_2__.useSearchParams,\n        _Context_store__WEBPACK_IMPORTED_MODULE_5__.useGlobalContext\n    ];\n});\n/* harmony default export */ __webpack_exports__[\"default\"] = (page);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vYXBwL2cvcGFnZS50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVCTUE7QUFLQUM7QUExQjZDO0FBRVU7QUFFL0I7QUFFOUIscURBQXFEO0FBRXJELHFCQUFxQjtBQUNyQix1REFBdUQ7QUFDdkQseURBQXlEO0FBRWpCO0FBQ1k7QUFDSjtBQUdDO0FBQ047QUFDYztBQVl6RCxNQUFNWSxXQUFXLElBQUlDLE9BQU9DO0FBRTVCLE1BQU1DLGFBQWE7SUFDakIsT0FBT0MsS0FBS0MsTUFBTSxDQUFDLElBQUlKLE9BQU9DLFlBQVlGLFFBQU8sSUFBSztBQUN4RDtBQUVBLE1BQU1NLE9BQU87O0lBQ1gsY0FBYztJQUNkLE1BQU1DLGVBQWVmLGdFQUFlQTtJQUNwQyxNQUFNLENBQUNnQixRQUFRQyxVQUFVLEdBQUdsQiwrQ0FBUUEsQ0FBQztJQUNyQyxNQUFNLENBQUNtQixNQUFNQyxRQUFRLEdBQUdwQiwrQ0FBUUEsQ0FBQztJQUVqQyxNQUFNLENBQUNxQixNQUFNQyxRQUFRLEdBQUd0QiwrQ0FBUUEsQ0FBQyxDQUFDO0lBRWxDLE9BQU87SUFDUCxNQUFNLENBQUN1QixLQUFLQyxPQUFPLEdBQUd4QiwrQ0FBUUEsQ0FBQztJQUMvQixNQUFNLENBQUN5QixNQUFNQyxRQUFRLEdBQUcxQiwrQ0FBUUEsQ0FBQztRQUFDO1lBQUUyQixVQUFVO1lBQUlDLFNBQVM7UUFBRztLQUFFO0lBRWhFLGNBQWM7SUFDZCxNQUFNLENBQUNDLGFBQWFDLGVBQWUsR0FBRzlCLCtDQUFRQSxDQUFDO1FBQUM7WUFBRTJCLFVBQVU7WUFBSUksT0FBTztRQUFFO0tBQUU7SUFFM0UsY0FBYztJQUNkLE1BQU0sQ0FBQ0MsV0FBV0MsYUFBYSxHQUFHakMsK0NBQVFBLENBQUM7SUFFM0MsZ0RBQWdEO0lBRWhELE1BQU0sQ0FBQ2tDLFNBQVNDLFdBQVcsR0FBR25DLCtDQUFRQSxDQUFDO0lBQ3ZDLE1BQU0sQ0FBQytCLE9BQU9LLFNBQVMsR0FBR3BDLCtDQUFRQSxDQUFDO0lBQ25DLE1BQU0sQ0FBQ2MsT0FBT3VCLFNBQVMsR0FBR3JDLCtDQUFRQSxDQUFDO0lBQ25DLE1BQU0sQ0FBQ3NDLE1BQU1DLFFBQVEsR0FBR3ZDLCtDQUFRQSxDQUFDO0lBRWpDLE1BQU0sQ0FBQ3dDLGdCQUFnQkMsa0JBQWtCLEdBQUd6QywrQ0FBUUEsQ0FBQztJQUVyRCx3Q0FBd0M7SUFFeEMsTUFBTSxDQUFDMEMsT0FBT0MsU0FBUyxHQUFHM0MsK0NBQVFBLENBQUM7SUFFbkMsTUFBTSxDQUFDNEMsV0FBV0MsYUFBYSxHQUFHN0MsK0NBQVFBLENBQUM7SUFDM0MseURBQXlEO0lBRXpELE1BQU0sQ0FBQzhDLFlBQVlDLGNBQWMsR0FBRy9DLCtDQUFRQSxDQUFDO0lBRTdDLE1BQU1nRCxjQUFjO1FBQ2xCO1lBQ0VDLEtBQUs7WUFDTEMsU0FBUztRQUNYO1FBQ0E7WUFDRUQsS0FBSztZQUNMQyxTQUFTO1FBQ1g7UUFDQTtZQUNFRCxLQUFLO1lBQ0xDLFNBQVM7UUFDWDtLQUNEO0lBRUQsTUFBTSxDQUFDQyxpQkFBaUJDLG1CQUFtQixHQUFHcEQsK0NBQVFBLENBQUM7UUFDckQ7WUFBRXFELEtBQUs7WUFBSUMsTUFBTTtZQUFJQyxTQUFTQztRQUFVO0tBQ3pDO0lBRUQsTUFBTUMsUUFBUTtRQUNaQyxRQUFRQyxJQUFJLFlBQVl0QztRQUV4QixJQUFJcUIsT0FBTztRQUNYZ0IsUUFBUUMsSUFBSSxTQUFTL0M7UUFDckJTLEtBQUt1QyxLQUFLO1FBQ1ZqQixTQUFTO0lBQ1g7SUFFQSxNQUFNa0IsYUFBYSxDQUFDQztRQUNsQkosUUFBUUMsSUFBSTtRQUNaZCxhQUFhO1FBQ2JmLGVBQWVnQyxRQUFRakM7SUFDekI7SUFFQSxNQUFNa0MsV0FBVyxDQUFDRDtRQUNoQkosUUFBUUMsSUFBSTtRQUNaZCxhQUFhO1FBQ2JmLGVBQWVnQyxRQUFRakM7UUFDdkJJLGFBQWE7SUFDZjtJQUVBLE1BQU0rQixjQUFjLENBQUNGO1FBS25CSixRQUFRQyxJQUFJLGdCQUFnQi9DLGNBQWNrRCxRQUFRRztRQUNsRGxCLGNBQWM7UUFDZE4sa0JBQWtCO1FBQ2xCTixXQUFXMkIsUUFBUTVCO1FBQ25CRyxTQUFTeUIsUUFBUUcsV0FBVztRQUM1QkMsYUFBYUosUUFBUXhCO0lBQ3ZCO0lBRUEsTUFBTTZCLFlBQVksQ0FBQ0w7UUFLakJKLFFBQVFDLElBQUksY0FBYy9DLGNBQWNrRCxRQUFRTTtRQUNoRFYsUUFBUUMsSUFBSUcsUUFBUU87UUFDcEJ0QixjQUFjO1FBQ2Qsd0JBQXdCO1FBQ3hCTixrQkFBa0I7UUFDbEJXLG1CQUFtQlUsUUFBUU87UUFDM0J2QyxlQUFlZ0MsUUFBUWpDO1FBQ3ZCTyxTQUFTMEIsUUFBUU07SUFDbkI7SUFFQSxNQUFNRSxjQUFjLENBQUNDO1FBQ25CYixRQUFRQyxJQUFJLGlCQUFpQlksa0JBQUFBLG1CQUFBQSxLQUFBQSxJQUFBQSxNQUFPQyxVQUFVLEdBQUc7UUFDakRuRCxLQUFLdUMsS0FBSyxPQUFPVztJQUNuQjtJQUVBLE1BQU1FLFVBQVU7UUFDZCxJQUFJLENBQUNsRCxLQUFLO1FBQ1YsSUFBSSxDQUFDRixNQUFNO1FBQ1hxQyxRQUFRQyxJQUFJLGVBQWVwQztRQUMzQkYsS0FBS3VDLEtBQUssUUFBUXJDO1FBQ2xCLGlGQUFpRjtRQUNqRkMsT0FBTztJQUNUO0lBRUEsTUFBTWtELGFBQWEsQ0FBQ25EO1FBQ2xCLG1DQUFtQztRQUNuQ0UsS0FBS2tELEtBQUtwRDtRQUNWRyxRQUFRRCxLQUFLbUQ7UUFDYmxCLFFBQVFDLElBQUlsQztJQUNkO0lBRUEsb0JBQW9CO0lBQ3BCLHNCQUFzQjtJQUN0QixtQ0FBbUM7SUFDbkMsSUFBSTtJQUNKLGFBQWE7SUFFYjFCLGdEQUFTQSxDQUFDO1FBQ1IsTUFBTThFLEtBQUs3RCxhQUFhOEQsSUFBSSxTQUFTdEI7UUFDckMsTUFBTXVCLGdCQUFnQi9ELGFBQWE4RCxJQUFJLFNBQVM7UUFDaEQ1RCxVQUFVMkQsTUFBTTtRQUNoQnpELFFBQVEyRCxrQkFBa0IsU0FBUyxPQUFPO1FBQzFDckIsUUFBUUMsSUFBSSxNQUFNa0I7UUFDbEJuQixRQUFRQyxJQUFJLGlCQUFpQm9CO1FBQzdCQyxPQUFPSDtRQUVQLFNBQVNJLGNBQWNDLEtBQWdCLEVBQUVILGFBQXNCO1lBQzdEckIsUUFBUUMsSUFBSSxlQUFldUI7WUFFM0I1RCxRQUFRNEQ7WUFFUixJQUFJSCxlQUFlO2dCQUNqQnJCLFFBQVFDLElBQUksV0FBV3VCLE1BQU1MO2dCQUM3QjNELFVBQVVnRSxNQUFNTDtZQUNsQixPQUFPO2dCQUNMLCtCQUErQjtnQkFDL0JNLFdBQVc7b0JBQ1QsSUFBSXpDLE9BQU87b0JBQ1hnQixRQUFRQyxJQUFJLGNBQWMvQztvQkFDMUJzRSxNQUFNdEIsS0FBSztvQkFDWGpCLFNBQVM7Z0JBQ1gsR0FBRztZQUNMO1lBRUF1QyxNQUFNRSxVQUFVLGNBQWMsQ0FBQ3RCLFVBQWlCRCxXQUFXQztZQUUzRG9CLE1BQU1FLFVBQVUsWUFBWSxDQUFDdEIsVUFBaUJDLFNBQVNEO1lBRXZEb0IsTUFBTUUsVUFDSixlQUNBLENBQUN0QjtnQkFDQ0UsWUFBWUY7WUFDZDtZQUdGb0IsTUFBTUUsVUFBVSxhQUFhLENBQUN0QjtnQkFDNUJLLFVBQVVMO1lBQ1o7WUFFQW9CLE1BQU1FLFVBQVUsUUFBUSxDQUFDN0Q7Z0JBQ3ZCbUQsV0FBV25EO1lBQ2I7UUFDRjtRQUVBLFNBQVN5RCxPQUFPSCxFQUFXO1lBQ3pCLElBQUlBLElBQUk7Z0JBQ04zRSxpREFBSUEsQ0FBQ21GLE9BQ0ZDLFNBQVNULElBQ1RVLEtBQUssQ0FBQ0w7b0JBQ0xELGNBQWNDLE9BQU87Z0JBRXJCLGtCQUFrQjtnQkFDbEIscUNBQXFDO2dCQUN2QyxHQUNDTSxNQUFNLENBQUNDO29CQUNOQyxNQUFNO29CQUNOaEMsUUFBUUMsSUFBSSxjQUFjOEI7Z0JBQzVCO1lBQ0osT0FBTztnQkFDTHZGLGlEQUFJQSxDQUFDbUYsT0FDRk0sYUFBYSxXQUFXO29CQUN2QmhFLFVBQVVpRSxhQUFhQyxRQUFRO2dCQUNqQyxHQUNDTixLQUFLLENBQUNMO29CQUNMLE1BQU1ZLFFBQVE5RSxhQUFhOEQsSUFBSSxVQUFVLFVBQVU7b0JBQ25EcEIsUUFBUUMsSUFBSSxTQUFTbUM7b0JBQ3JCYixjQUFjQyxPQUFPWTtnQkFDckIsK0NBQStDO2dCQUMvQyxtQ0FBbUM7Z0JBQ25DLE1BQU07Z0JBQ04sd0NBQXdDO2dCQUMxQyxHQUNDTixNQUFNLENBQUNDO29CQUNOQyxNQUFNO29CQUNOaEMsUUFBUUMsSUFBSSxjQUFjOEI7Z0JBQzVCO1lBQ0o7UUFDRjtRQUVBLDBDQUEwQztRQUMxQyx5Q0FBeUM7UUFDekMsMkNBQTJDO1FBRTNDLHlCQUF5QjtRQUN6QiwwQkFBMEI7UUFDMUIsSUFBSTtRQUVKLDRCQUE0QjtRQUM1QiwyQkFBMkI7UUFDM0IsSUFBSTtRQUVKLGtDQUFrQztRQUNsQyxtQkFBbUI7UUFDbkIsSUFBSTtRQUVKLHFDQUFxQztRQUNyQyw4QkFBOEI7UUFDOUIsdUJBQXVCO1FBQ3ZCLGlDQUFpQztRQUNqQywwQkFBMEI7UUFDMUIsMEJBQTBCO1FBQzFCLDZCQUE2QjtRQUM3QixJQUFJO1FBRUosbUNBQW1DO1FBQ25DLDRCQUE0QjtRQUM1QixvQkFBb0I7UUFDcEIsc0RBQXNEO1FBQ3RELDZCQUE2QjtRQUM3Qiw2Q0FBNkM7UUFDN0MsK0RBQStEO1FBQy9ELFdBQVc7UUFFWCwrQkFBK0I7UUFDL0Isd0JBQXdCO1FBRXhCLHdDQUF3QztRQUN4QyxJQUFJO1FBRUosc0NBQXNDO1FBQ3RDLDBCQUEwQjtRQUMxQixJQUFJO1FBRUosb0NBQW9DO1FBQ3BDLHdCQUF3QjtRQUN4Qix1Q0FBdUM7UUFDdkMsSUFBSTtRQUVKLG1DQUFtQztRQUNuQyx5Q0FBeUM7UUFDekMsdUNBQXVDO1FBQ3ZDLG1DQUFtQztRQUNuQyx5Q0FBeUM7UUFDekMscUNBQXFDO1FBQ3JDLDJDQUEyQztRQUUzQyxhQUFhO1FBRWIsT0FBTztRQUNMLG9DQUFvQztRQUNwQywwQ0FBMEM7UUFDMUMsd0NBQXdDO1FBQ3hDLG9DQUFvQztRQUNwQywwQ0FBMEM7UUFDMUMsc0NBQXNDO1FBQ3RDLDRDQUE0QztRQUM5QztJQUNGLEdBQUcsRUFBRTtJQUVMLHVCQUF1QjtJQUN2QixVQUFVO0lBQ1Ysd0JBQXdCO0lBQ3hCLDBFQUEwRTtJQUMxRSxtQ0FBbUM7SUFDbkMsNEJBQTRCO0lBQzVCLG9CQUFvQjtJQUNwQiwyQ0FBMkM7SUFDM0Msd0JBQXdCO0lBQ3hCLE1BQU07SUFDTixJQUFJO0lBRUosMEJBQTBCO0lBQzFCLHlCQUF5QjtJQUN6QiwyQkFBMkI7SUFDM0IsSUFBSTtJQUVKLGVBQWV2QixhQUFhNkIsS0FBYTtRQUN2QyxJQUFLLElBQUlDLElBQUlELE9BQU9DLEtBQUssR0FBR0EsSUFBSztZQUMvQnpELFFBQVF5RDtZQUNSLE1BQU0sSUFBSUMsUUFBUSxDQUFDQyxVQUFZZixXQUFXZSxTQUFTO1FBQ3JEO0lBQ0EscUNBQXFDO0lBQ3JDLHdCQUF3QjtJQUN4QiwrREFBK0Q7SUFDL0QsSUFBSTtJQUNOO0lBRUEsTUFBTSxFQUFFdkUsUUFBUSxFQUFFLEdBQUd2QixnRUFBZ0JBO0lBRXJDLG9DQUFvQztJQUNwQyxvQkFBb0I7SUFDcEIsS0FBSztJQUVMLHdDQUF3QztJQUN4Qyx5QkFBeUI7SUFDekIsS0FBSztJQUVMLHFCQUNFLDhEQUFDK0Y7UUFBSUMsV0FBVTs7MEJBQ2IsOERBQUNEO2dCQUFJQyxXQUFXLEdBQXFCLE9BQWxCdkcsdUxBQWlCdUc7Ozs7OztZQUNuQ3hELGNBQWMsMkJBQ2IsOERBQUN6Qyx5REFBS0E7Z0JBQ0prRyxhQUFhO29CQUFDO29CQUFRO2lCQUFRO2dCQUM5QkMsUUFBUTtnQkFDUkMsYUFBYTtnQkFDYkMsdUJBQ0UsOERBQUNMOzhCQUNFekQsc0JBQ0MsOERBQUN5RDt3QkFBSUMsV0FBVyx5QkFBMkMsT0FBbEJ2Ryx1TEFBaUJ1RztrQ0FBSTtzRUFJOUQsOERBQUNLO3dCQUNDQyxVQUFVLENBQUNyRjt3QkFDWCtFLFdBQVcsK0JBQWlELE9BQWxCdkcsdUxBQWlCdUc7d0JBQzNETyxTQUFTOzRCQUNQbEQ7d0JBQ0Y7a0NBQ0Q7OztnQkFNUG9CLElBQUc7Z0JBQ0grQixTQUFTO2dCQUNUQyxPQUFPOzBCQUVQLDRFQUFDVjtvQkFBSUMsV0FBVTs7c0NBQ2IsOERBQUNVOzRCQUFFVixXQUFVO3NDQUFXOzs7Ozs7c0NBQ3hCLDhEQUFDVTs0QkFBRVYsV0FBVyxhQUErQixPQUFsQnZHLHVMQUFpQnVHO3NDQUFJOzs7Ozs7d0JBRy9DakYsc0JBQ0MsOERBQUMyRjs0QkFBRVYsV0FBVyxhQUErQixPQUFsQnZHLHVMQUFpQnVHOztnQ0FBSTtnQ0FDckM7OENBQ1QsOERBQUNXO29DQUNDSixTQUFTO3dDQUNQSyxVQUFVQyxVQUFVQyxVQUFVakc7b0NBQ2hDO29DQUNBbUYsV0FBVywyQ0FBNkQsT0FBbEJ2Ryx1TEFBaUJ1Rzs4Q0FFdEVuRjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUFRWjJCLGNBQWMseUJBQ2IsOERBQUN6Qyx5REFBS0E7Z0JBQ0prRyxhQUFhO29CQUFDO29CQUFRO2lCQUFRO2dCQUM5QkMsUUFBUTtnQkFDUkMsYUFBYTtnQkFDYjFCLElBQUc7Z0JBQ0grQixTQUFTO2dCQUNUQyxPQUFPOzBCQUVQLDRFQUFDckcsb0VBQVdBO29CQUFDMkcsTUFBTXRGOzs7Ozs7Ozs7OztZQUl0QmlCLGVBQWUseUJBQ2QsOERBQUMzQyx5REFBS0E7Z0JBQ0ptRyxRQUFRO2dCQUNSQyxhQUFhO2dCQUNiMUIsSUFBSTtnQkFDSmdDLE9BQU87Z0JBQ1BELFNBQVM7MEJBRVQsNEVBQUN2Ryw2REFBU0E7b0JBQUM4RyxNQUFNaEU7b0JBQWlCakIsU0FBU0E7Ozs7Ozs7Ozs7OzBCQUkvQyw4REFBQ2lFO2dCQUFJQyxXQUFVOzs7Ozs7MEJBSWYsOERBQUNEO2dCQUFJQyxXQUFVOztrQ0FDYiw4REFBQ0Q7d0JBQUlDLFdBQVcsV0FBMEIsT0FBZnhHLHVLQUFjd0c7OzRCQUFJOzRCQUNwQzswQ0FDUCw4REFBQ1c7Z0NBQUtYLFdBQVcsMkJBQTBDLE9BQWZ4Ryx1S0FBY3dHOzBDQUN2RGxFLFdBQVc7Ozs7Ozs7Ozs7OztrQ0FHaEIsOERBQUNpRTt3QkFBSUMsV0FBVyxXQUE2QixPQUFsQnZHLHVMQUFpQnVHOzswQ0FJMUM7NEJBQ0M5RDs0QkFBSzs7Ozs7Ozs7Ozs7OzswQkFJViw4REFBQzZEO2dCQUNDQyxXQUFXLG9EQUFzRSxPQUFsQnZHLHVMQUFpQnVHLEVBQUM7O2tDQUVqRiw4REFBQ0Q7OzRCQUFJOzRCQUFRcEU7Ozs7Ozs7a0NBQ2IsOERBQUNvRTs7NEJBQUk7NEJBQVFyRjs7Ozs7Ozs7Ozs7OzswQkFHZiw4REFBQ3FGO2dCQUFJQyxXQUFVOztrQ0FDYiw4REFBQzlGLGdFQUFPQTt3QkFBQ2dFLGFBQWFBO3dCQUFhOEMsV0FBVzVFOzs7Ozs7a0NBQzlDLDhEQUFDMkQ7d0JBQUlDLFdBQVU7OzBDQUNiLDhEQUFDaUI7Z0NBQ0NqQixXQUNFLGFBQWMsS0FBSyx3QkFBdUMsT0FBZnhHLHVLQUFjd0csS0FDekQsYUFBNEIsT0FBZnhHLHVLQUFjd0c7Z0NBRTdCTyxTQUFTLElBQU0xRSxhQUFhOzBDQUM3Qjs7Ozs7OzBDQUdELDhEQUFDb0Y7Z0NBQ0NqQixXQUNFLGFBQWMsS0FBSyx3QkFBdUMsT0FBZnhHLHVLQUFjd0csS0FDekQsYUFBNEIsT0FBZnhHLHVLQUFjd0c7Z0NBRTdCTyxTQUFTLElBQU0xRSxhQUFhOzBDQUM3Qjs7Ozs7Ozs7Ozs7O2tDQUlILDhEQUFDa0U7d0JBQUlDLFdBQVU7OzRCQUNacEUsYUFBYSxtQkFDWiw4REFBQ3pCLDZEQUFJQTtnQ0FBQ2dCLEtBQUtBO2dDQUFLRSxNQUFNQTtnQ0FBTUQsUUFBUUE7Z0NBQVFpRCxTQUFTQTs7Ozs7OzRCQUV0RHpDLGFBQWEsbUJBQUssOERBQUN4QixvRUFBV0E7Z0NBQUMyRyxNQUFNdEY7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQUl6QyxNQUFFLGtCQUNEOzs7Ozs7O0FBUVI7R0FsZE1kOztRQUVpQmQsNERBQWVBO1FBc1RmRyw0REFBZ0JBOzs7QUE0SnZDLCtEQUFlVyxJQUFJQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2FwcC9nL3BhZ2UudHN4P2IxMWMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cbmltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XG5cbmltcG9ydCB7IHVzZVJvdXRlciwgdXNlU2VhcmNoUGFyYW1zIH0gZnJvbSBcIm5leHQvbmF2aWdhdGlvblwiO1xuXG5pbXBvcnQgY29seSBmcm9tIFwiQC9saWIvY29seVwiO1xuXG4vLyBpbXBvcnQgVGFiTWFuYWdlciBmcm9tIFwiLi4vY29tcG9uZW50cy9UYWJNYW5hZ2VyXCI7XG5cbi8vIExvZ2ljYWwgY29tcG9uZW50c1xuLy8gaW1wb3J0IHsgdXNlR2xvYmFsQ29udGV4dCB9IGZyb20gXCIuLi9Db250ZXh0L3N0b3JlXCI7XG4vLyBpbXBvcnQgdXNlR2FtZVN0YXRlIGZyb20gXCIuLi9jb21wb25lbnRzL3VzZUdhbWVTdGF0ZVwiO1xuXG5pbXBvcnQgTW9kYWwgZnJvbSBcIi4uL2NvbXBvbmVudHMvTW9kYWxcIjtcbmltcG9ydCB7IHVzZUdsb2JhbENvbnRleHQgfSBmcm9tIFwiLi4vQ29udGV4dC9zdG9yZVwiO1xuaW1wb3J0IEltZ1NsaWRlciBmcm9tIFwiLi4vY29tcG9uZW50cy9JbWdTbGlkZXJcIjtcbmltcG9ydCB7IEJ1bmdlZSwgUG9wcGlucyB9IGZyb20gXCJuZXh0L2ZvbnQvZ29vZ2xlXCI7XG5pbXBvcnQgeyBSb29tIH0gZnJvbSBcImNvbHlzZXVzLmpzXCI7XG5pbXBvcnQgQ2FwdHVyZSBmcm9tIFwiLi4vY29tcG9uZW50cy9Sb29tL0NhcHR1cmVcIjtcbmltcG9ydCBDaGF0IGZyb20gXCIuLi9jb21wb25lbnRzL1Jvb20vQ2hhdFwiO1xuaW1wb3J0IExlYWRlcmJvYXJkIGZyb20gXCIuLi9jb21wb25lbnRzL1Jvb20vTGVhZGVyYm9hcmRcIjtcblxuY29uc3QgZm9udCA9IEJ1bmdlZSh7XG4gIHdlaWdodDogXCI0MDBcIixcbiAgc3Vic2V0czogW1wibGF0aW5cIl0sXG59KTtcblxuY29uc3QgcG9wcGlucyA9IFBvcHBpbnMoe1xuICB3ZWlnaHQ6IFtcIjQwMFwiLCBcIjUwMFwiLCBcIjYwMFwiLCBcIjcwMFwiXSxcbiAgc3Vic2V0czogW1wibGF0aW5cIl0sXG59KTtcblxuY29uc3QgcHJldlRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuY29uc3QgZ2V0Q3VyVGltZSA9ICgpID0+IHtcbiAgcmV0dXJuIE1hdGgucm91bmQoKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gcHJldlRpbWUpIC8gNjAwKTtcbn07XG5cbmNvbnN0IHBhZ2UgPSAoKSA9PiB7XG4gIC8vIE11bHRpcGxheWVyXG4gIGNvbnN0IHNlYXJjaFBhcmFtcyA9IHVzZVNlYXJjaFBhcmFtcygpO1xuICBjb25zdCBbcm9vbUlkLCBzZXRSb29tSWRdID0gdXNlU3RhdGUoXCJcIik7XG4gIGNvbnN0IFtpc1JDLCBzZXRJc1JDXSA9IHVzZVN0YXRlKGZhbHNlKTtcblxuICBjb25zdCBbcm9vbSwgc2V0Um9vbV0gPSB1c2VTdGF0ZSh7fSBhcyBSb29tPGFueT4pO1xuXG4gIC8vIENoYXRcbiAgY29uc3QgW21zZywgc2V0TXNnXSA9IHVzZVN0YXRlKFwiXCIpO1xuICBjb25zdCBbbXNncywgc2V0TXNnc10gPSB1c2VTdGF0ZShbeyB1c2VybmFtZTogXCJcIiwgbWVzc2FnZTogXCJcIiB9XSk7XG5cbiAgLy8gTGVhZGVyYm9hcmRcbiAgY29uc3QgW2xlYWRlcmJvYXJkLCBzZXRMZWFkZXJib2FyZF0gPSB1c2VTdGF0ZShbeyB1c2VybmFtZTogXCJcIiwgc2NvcmU6IDAgfV0pO1xuXG4gIC8vIFRhYiBNYW5hZ2VyXG4gIGNvbnN0IFthY3RpdmVUYWIsIHNldEFjdGl2ZVRhYl0gPSB1c2VTdGF0ZSgwKTtcblxuICAvLyBjb25zdCBbcGxheWVycywgc2V0UGxheWVyc10gPSB1c2VTdGF0ZShbXCJcIl0pO1xuXG4gIGNvbnN0IFtvYmpuYW1lLCBzZXRPYmpuYW1lXSA9IHVzZVN0YXRlKFwiXCIpO1xuICBjb25zdCBbc2NvcmUsIHNldFNjb3JlXSA9IHVzZVN0YXRlKDApO1xuICBjb25zdCBbcm91bmQsIHNldFJvdW5kXSA9IHVzZVN0YXRlKDApO1xuICBjb25zdCBbdGltZSwgc2V0VGltZV0gPSB1c2VTdGF0ZSgwKTtcblxuICBjb25zdCBbY2FuUmV0YWtlSW1hZ2UsIHNldENhblJldGFrZUltYWdlXSA9IHVzZVN0YXRlKHRydWUpO1xuXG4gIC8vIGNvbnN0IFtteUlkLCBzZXRNeUlkXSA9IHVzZVN0YXRlKFwiXCIpO1xuXG4gIGNvbnN0IFtyZWFkeSwgc2V0UmVhZHldID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gIGNvbnN0IFtnYW1lU3RhdGUsIHNldEdhbWVTdGF0ZV0gPSB1c2VTdGF0ZShcInN0YXJ0ZWRcIik7XG4gIC8vIGNvbnN0IFtnYW1lU3RhdGUsIHNldEdhbWVTdGF0ZV0gPSB1c2VTdGF0ZShcIndhaXRpbmdcIik7XG5cbiAgY29uc3QgW3JvdW5kU3RhdGUsIHNldFJvdW5kU3RhdGVdID0gdXNlU3RhdGUoXCJcIik7XG5cbiAgY29uc3Qgc2xpZGVJbWFnZXMgPSBbXG4gICAge1xuICAgICAgdXJsOiBcImh0dHBzOi8vaW1hZ2VzLnVuc3BsYXNoLmNvbS9waG90by0xNTA5NzIxNDM0MjcyLWI3OTE0N2UwZTcwOD9peGxpYj1yYi0xLjIuMSZpeGlkPWV5SmhjSEJmYVdRaU9qRXlNRGQ5JmF1dG89Zm9ybWF0JmZpdD1jcm9wJnc9MTUwMCZxPTgwXCIsXG4gICAgICBjYXB0aW9uOiBcIlBsYXllciAxXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICB1cmw6IFwiaHR0cHM6Ly9pbWFnZXMudW5zcGxhc2guY29tL3Bob3RvLTE1MDY3MTA1MDc1NjUtMjAzYjlmMjQ2NjliP2l4bGliPXJiLTEuMi4xJml4aWQ9ZXlKaGNIQmZhV1FpT2pFeU1EZDkmYXV0bz1mb3JtYXQmZml0PWNyb3Amdz0xNTM2JnE9ODBcIixcbiAgICAgIGNhcHRpb246IFwiUGxheWVyIDJcIixcbiAgICB9LFxuICAgIHtcbiAgICAgIHVybDogXCJodHRwczovL2ltYWdlcy51bnNwbGFzaC5jb20vcGhvdG8tMTUzNjk4NzMzMzcwNi1mYzlhZGZiMTBkOTE/aXhsaWI9cmItMS4yLjEmaXhpZD1leUpoY0hCZmFXUWlPakV5TURkOSZhdXRvPWZvcm1hdCZmaXQ9Y3JvcCZ3PTE1MDAmcT04MFwiLFxuICAgICAgY2FwdGlvbjogXCJQbGF5ZXIgM1wiLFxuICAgIH0sXG4gIF07XG5cbiAgY29uc3QgW3BsYXllcnNSZXNwb25zZSwgc2V0UGxheWVyc1Jlc3BvbnNlXSA9IHVzZVN0YXRlKFtcbiAgICB7IGltZzogXCJcIiwgbmFtZTogXCJcIiwgbWF0Y2hlZDogdW5kZWZpbmVkIH0sXG4gIF0pO1xuXG4gIGNvbnN0IFJlYWR5ID0gKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKFwiUk9PTSBPQkpcIiwgcm9vbSk7XG5cbiAgICBpZiAocmVhZHkpIHJldHVybjtcbiAgICBjb25zb2xlLmxvZyhcIlJlYWR5XCIsIGdldEN1clRpbWUoKSk7XG4gICAgcm9vbS5zZW5kKFwicmVhZHlcIik7XG4gICAgc2V0UmVhZHkodHJ1ZSk7XG4gIH07XG5cbiAgY29uc3QgR2FtZVN0YXJ0cyA9IChwYXlsb2FkOiBhbnkpID0+IHtcbiAgICBjb25zb2xlLmxvZyhcIkdhbWUgU3RhcnRzXCIpO1xuICAgIHNldEdhbWVTdGF0ZShcInN0YXJ0ZWRcIik7XG4gICAgc2V0TGVhZGVyYm9hcmQocGF5bG9hZC5sZWFkZXJib2FyZCk7XG4gIH07XG5cbiAgY29uc3QgR2FtZUVuZHMgPSAocGF5bG9hZDogYW55KSA9PiB7XG4gICAgY29uc29sZS5sb2coXCJHYW1lIEVuZHNcIik7XG4gICAgc2V0R2FtZVN0YXRlKFwiZW5kZWRcIik7XG4gICAgc2V0TGVhZGVyYm9hcmQocGF5bG9hZC5sZWFkZXJib2FyZCk7XG4gICAgc2V0QWN0aXZlVGFiKDEpO1xuICB9O1xuXG4gIGNvbnN0IFJvdW5kU3RhcnRzID0gKHBheWxvYWQ6IHtcbiAgICBjdXJSb3VuZDogbnVtYmVyO1xuICAgIG9iam5hbWU6IHN0cmluZztcbiAgICB0aW1lOiBudW1iZXI7XG4gIH0pID0+IHtcbiAgICBjb25zb2xlLmxvZyhcIlJvdW5kIFN0YXJ0c1wiLCBnZXRDdXJUaW1lKCksIHBheWxvYWQuY3VyUm91bmQpO1xuICAgIHNldFJvdW5kU3RhdGUoXCJzdGFydGVkXCIpO1xuICAgIHNldENhblJldGFrZUltYWdlKHRydWUpO1xuICAgIHNldE9iam5hbWUocGF5bG9hZC5vYmpuYW1lKTtcbiAgICBzZXRSb3VuZChwYXlsb2FkLmN1clJvdW5kICsgMSk7XG4gICAgc3RhcnRDb3VudGVyKHBheWxvYWQudGltZSk7XG4gIH07XG5cbiAgY29uc3QgUm91bmRFbmRzID0gKHBheWxvYWQ6IHtcbiAgICBsZWFkZXJib2FyZDogYW55O1xuICAgIGltZ3M6IGFueTtcbiAgICBjdXJTY29yZTogbnVtYmVyO1xuICB9KSA9PiB7XG4gICAgY29uc29sZS5sb2coXCJSb3VuZCBFbmRzXCIsIGdldEN1clRpbWUoKSwgcGF5bG9hZC5jdXJTY29yZSk7XG4gICAgY29uc29sZS5sb2cocGF5bG9hZC5pbWdzKTtcbiAgICBzZXRSb3VuZFN0YXRlKFwiZW5kZWRcIik7XG4gICAgLy8gY29uc29sZS5sb2cocGF5bG9hZCk7XG4gICAgc2V0Q2FuUmV0YWtlSW1hZ2UoZmFsc2UpO1xuICAgIHNldFBsYXllcnNSZXNwb25zZShwYXlsb2FkLmltZ3MpO1xuICAgIHNldExlYWRlcmJvYXJkKHBheWxvYWQubGVhZGVyYm9hcmQpO1xuICAgIHNldFNjb3JlKHBheWxvYWQuY3VyU2NvcmUpO1xuICB9O1xuXG4gIGNvbnN0IHN1Ym1pdEltYWdlID0gKGltYWdlPzogc3RyaW5nKSA9PiB7XG4gICAgY29uc29sZS5sb2coXCJTZW5kaW5nIGltYWdlXCIsIGltYWdlPy5zdWJzdHJpbmcoMCwgMykpO1xuICAgIHJvb20uc2VuZChcImltZ1wiLCBpbWFnZSk7XG4gIH07XG5cbiAgY29uc3Qgc2VuZE1zZyA9ICgpID0+IHtcbiAgICBpZiAoIW1zZykgcmV0dXJuO1xuICAgIGlmICghcm9vbSkgcmV0dXJuO1xuICAgIGNvbnNvbGUubG9nKFwiU2VuZGluZyBtc2dcIiwgbXNnKTtcbiAgICByb29tLnNlbmQoXCJjaGF0XCIsIG1zZyk7XG4gICAgLy8gcm9vbS5zZW5kKFwiY2hhdFwiLCB7dXNlcm5hbWU6IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwidXNlcm5hbWVcIiksIG1lc3NhZ2U6IG1zZ30pO1xuICAgIHNldE1zZyhcIlwiKTtcbiAgfTtcblxuICBjb25zdCBhcHBlbmRNc2dzID0gKG1zZzogeyB1c2VybmFtZTogc3RyaW5nOyBtZXNzYWdlOiBzdHJpbmcgfSkgPT4ge1xuICAgIC8vIGFwcGVuZCBtc2cgdG8gbXNncyB1c2luZyBzZXRNc2dzXG4gICAgbXNncy5wdXNoKG1zZyk7XG4gICAgc2V0TXNncyhtc2dzLnNsaWNlKCkpO1xuICAgIGNvbnNvbGUubG9nKG1zZ3MpO1xuICB9O1xuXG4gIC8vIHVzZUVmZmVjdCgoKSA9PiB7XG4gIC8vICAgcm91dGVyLnJlZnJlc2goKTtcbiAgLy8gICBjb25zb2xlLmxvZyhcIlJPVVRFUiBSRUZSRVNIXCIpO1xuICAvLyB9XG4gIC8vICwgW21zZ3NdKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGlkID0gc2VhcmNoUGFyYW1zLmdldChcImlkXCIpIHx8IHVuZGVmaW5lZDtcbiAgICBjb25zdCBpc1Jvb21DcmVhdG9yID0gc2VhcmNoUGFyYW1zLmdldChcInJjXCIpIHx8IGZhbHNlO1xuICAgIHNldFJvb21JZChpZCB8fCBcIlwiKTtcbiAgICBzZXRJc1JDKGlzUm9vbUNyZWF0b3IgPT09IFwidHJ1ZVwiID8gdHJ1ZSA6IGZhbHNlKTtcbiAgICBjb25zb2xlLmxvZyhcIklEXCIsIGlkKTtcbiAgICBjb25zb2xlLmxvZyhcImlzUm9vbUNyZWF0b3JcIiwgaXNSb29tQ3JlYXRvcik7XG4gICAgb25Kb2luKGlkKTtcblxuICAgIGZ1bmN0aW9uIEdhbWVwbGF5U2V0dXAoX3Jvb206IFJvb208YW55PiwgaXNSb29tQ3JlYXRvcjogYm9vbGVhbikge1xuICAgICAgY29uc29sZS5sb2coXCJKT0lORUQgUk9PTVwiLCBfcm9vbSk7XG5cbiAgICAgIHNldFJvb20oX3Jvb20pO1xuXG4gICAgICBpZiAoaXNSb29tQ3JlYXRvcikge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlJPT00gSURcIiwgX3Jvb20uaWQpO1xuICAgICAgICBzZXRSb29tSWQoX3Jvb20uaWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY2FsbCBSZWFkeSgpIGFmdGVyIDUgc2Vjb25kc1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpZiAocmVhZHkpIHJldHVybjtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIkFVVE8gUkVBRFlcIiwgZ2V0Q3VyVGltZSgpKTtcbiAgICAgICAgICBfcm9vbS5zZW5kKFwicmVhZHlcIik7XG4gICAgICAgICAgc2V0UmVhZHkodHJ1ZSk7XG4gICAgICAgIH0sIDUwMDApO1xuICAgICAgfVxuXG4gICAgICBfcm9vbS5vbk1lc3NhZ2UoXCJnYW1lU3RhcnRzXCIsIChwYXlsb2FkOiBhbnkpID0+IEdhbWVTdGFydHMocGF5bG9hZCkpO1xuXG4gICAgICBfcm9vbS5vbk1lc3NhZ2UoXCJnYW1lRW5kc1wiLCAocGF5bG9hZDogYW55KSA9PiBHYW1lRW5kcyhwYXlsb2FkKSk7XG5cbiAgICAgIF9yb29tLm9uTWVzc2FnZShcbiAgICAgICAgXCJyb3VuZFN0YXJ0c1wiLFxuICAgICAgICAocGF5bG9hZDogeyBjdXJSb3VuZDogbnVtYmVyOyBvYmpuYW1lOiBzdHJpbmc7IHRpbWU6IG51bWJlciB9KSA9PiB7XG4gICAgICAgICAgUm91bmRTdGFydHMocGF5bG9hZCk7XG4gICAgICAgIH1cbiAgICAgICk7XG5cbiAgICAgIF9yb29tLm9uTWVzc2FnZShcInJvdW5kRW5kc1wiLCAocGF5bG9hZDogYW55KSA9PiB7XG4gICAgICAgIFJvdW5kRW5kcyhwYXlsb2FkKTtcbiAgICAgIH0pO1xuXG4gICAgICBfcm9vbS5vbk1lc3NhZ2UoXCJjaGF0XCIsIChtc2c6IHsgdXNlcm5hbWU6IHN0cmluZzsgbWVzc2FnZTogc3RyaW5nIH0pID0+IHtcbiAgICAgICAgYXBwZW5kTXNncyhtc2cpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25Kb2luKGlkPzogc3RyaW5nKSB7XG4gICAgICBpZiAoaWQpIHtcbiAgICAgICAgY29seS5jbGllbnRcbiAgICAgICAgICAuam9pbkJ5SWQoaWQpXG4gICAgICAgICAgLnRoZW4oKF9yb29tKSA9PiB7XG4gICAgICAgICAgICBHYW1lcGxheVNldHVwKF9yb29tLCBmYWxzZSk7XG5cbiAgICAgICAgICAgIC8vIHNldFJvb20oX3Jvb20pO1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJKT0lORUQgUk9PTVwiLCBfcm9vbSk7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIGFsZXJ0KFwiRXJyb3I6IGpvaW5pbmcgcm9vbSwgdHJ5IGFnYWluIHdpdGggdmFsaWQgcm9vbSBpZFwiKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiSk9JTiBFUlJPUlwiLCBlKTtcbiAgICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbHkuY2xpZW50XG4gICAgICAgICAgLmpvaW5PckNyZWF0ZShcIm15X3Jvb21cIiwge1xuICAgICAgICAgICAgdXNlcm5hbWU6IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwidXNlcm5hbWVcIiksXG4gICAgICAgICAgfSlcbiAgICAgICAgICAudGhlbigoX3Jvb20pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IF9pc1JDID0gc2VhcmNoUGFyYW1zLmdldChcInJjXCIpID09PSBcInRydWVcIiB8fCBmYWxzZTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiSVMgUkNcIiwgX2lzUkMpO1xuICAgICAgICAgICAgR2FtZXBsYXlTZXR1cChfcm9vbSwgX2lzUkMpO1xuICAgICAgICAgICAgLy8gcm9vbS5vbk1lc3NhZ2UoXCJpbWdcIiwgKG1lc3NhZ2U6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgLy8gICBjb25zb2xlLmxvZyhcIklNRyBcIiArIG1lc3NhZ2UpO1xuICAgICAgICAgICAgLy8gfSk7XG4gICAgICAgICAgICAvLyByb29tLm9uTWVzc2FnZShcInJlYWR5XCIsIE9uUmVhZHlNc2dzKTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgYWxlcnQoXCJFcnJvcjogam9pbmluZyByb29tLCB0cnkgYWdhaW4gd2l0aCB2YWxpZCByb29tIGlkXCIpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJKT0lOIEVSUk9SXCIsIGUpO1xuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGZ1bmN0aW9uIE9uQ2hhdE1zZ3MobWVzc2FnZTogc3RyaW5nKSB7fVxuICAgIC8vIGZ1bmN0aW9uIE9uSW1nTXNncyhtZXNzYWdlOiBzdHJpbmcpIHt9XG4gICAgLy8gZnVuY3Rpb24gT25SZWFkeU1zZ3MobWVzc2FnZTogc3RyaW5nKSB7fVxuXG4gICAgLy8gZnVuY3Rpb24gb25Db25uZWN0KCkge1xuICAgIC8vICAgc2V0SXNDb25uZWN0ZWQodHJ1ZSk7XG4gICAgLy8gfVxuXG4gICAgLy8gZnVuY3Rpb24gb25EaXNjb25uZWN0KCkge1xuICAgIC8vICAgc2V0SXNDb25uZWN0ZWQoZmFsc2UpO1xuICAgIC8vIH1cblxuICAgIC8vIGZ1bmN0aW9uIG9uTWVzc2FnZShkYXRhOiBhbnkpIHtcbiAgICAvLyAgIHNldE1zZ3MoZGF0YSk7XG4gICAgLy8gfVxuXG4gICAgLy8gZnVuY3Rpb24gb25Sb3VuZFN0YXJ0KGRhdGE6IGFueSkge1xuICAgIC8vICAgc2V0Um91bmRTdGF0ZShcInN0YXJ0ZWRcIik7XG4gICAgLy8gICBjb25zb2xlLmxvZyhkYXRhKTtcbiAgICAvLyAgIHNldE9iam5hbWUoZGF0YS5vYmplY3RuYW1lKTtcbiAgICAvLyAgIHNldFNjb3JlKGRhdGEuc2NvcmUpO1xuICAgIC8vICAgc2V0Um91bmQoZGF0YS5yb3VuZCk7XG4gICAgLy8gICBzdGFydENvdW50ZXIoZGF0YS50aW1lKTtcbiAgICAvLyB9XG5cbiAgICAvLyBmdW5jdGlvbiBvblJvdW5kRW5kKGRhdGE6IGFueSkge1xuICAgIC8vICAgc2V0Um91bmRTdGF0ZShcImVuZGVkXCIpO1xuICAgIC8vICAgdGFiU3RhdGVbMV0oMSk7XG4gICAgLy8gICBsZXQgcGxheWVyc19yZXM6IHsgbmFtZTogYW55OyBkYXRhOiBhbnkgfVtdID0gW107XG4gICAgLy8gICBjb25zdCBkYXRhYSA9IGRhdGEuZGF0YTtcbiAgICAvLyAgIC8vIE9iamVjdC5rZXlzKGRhdGFhKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAvLyAgIC8vICAgLy8gcGxheWVyc19yZXMucHVzaCh7IG5hbWU6IGtleSwgZGF0YTogZGF0YWFba2V5XSB9KTtcbiAgICAvLyAgIC8vIH0pO1xuXG4gICAgLy8gICBzZXRQbGF5ZXJzUmVzcG9uc2UoZGF0YWEpO1xuICAgIC8vICAgY29uc29sZS5sb2coZGF0YWEpO1xuXG4gICAgLy8gICAvLyBzZXRQbGF5ZXJzUmVzcG9uc2UocGxheWVyc19yZXMpO1xuICAgIC8vIH1cblxuICAgIC8vIGZ1bmN0aW9uIG9uTGVhZGVyYm9hcmQoZGF0YTogYW55KSB7XG4gICAgLy8gICBzZXRMZWFkZXJib2FyZChkYXRhKTtcbiAgICAvLyB9XG5cbiAgICAvLyBmdW5jdGlvbiBvbkdhbWVTdGF0ZShkYXRhOiBhbnkpIHtcbiAgICAvLyAgIHNldEdhbWVTdGF0ZShkYXRhKTtcbiAgICAvLyAgIGNvbnNvbGUubG9nKFwiR2FtZSBTdGF0ZTogXCIsIGRhdGEpO1xuICAgIC8vIH1cblxuICAgIC8vIHNvY2tldC5vbihcImNvbm5lY3RcIiwgb25Db25uZWN0KTtcbiAgICAvLyBzb2NrZXQub24oXCJkaXNjb25uZWN0XCIsIG9uRGlzY29ubmVjdCk7XG4gICAgLy8gc29ja2V0Lm9uKFwiZ2FtZXN0YXRlXCIsIG9uR2FtZVN0YXRlKTtcbiAgICAvLyBzb2NrZXQub24oXCJtZXNzYWdlXCIsIG9uTWVzc2FnZSk7XG4gICAgLy8gc29ja2V0Lm9uKFwicm91bmRzdGFydFwiLCBvblJvdW5kU3RhcnQpO1xuICAgIC8vIHNvY2tldC5vbihcInJvdW5kZW5kXCIsIG9uUm91bmRFbmQpO1xuICAgIC8vIHNvY2tldC5vbihcImxlYWRlcmJvYXJkXCIsIG9uTGVhZGVyYm9hcmQpO1xuXG4gICAgLy8gY29ubmVjdCgpO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIC8vIHNvY2tldC5vZmYoXCJjb25uZWN0XCIsIG9uQ29ubmVjdCk7XG4gICAgICAvLyBzb2NrZXQub2ZmKFwiZGlzY29ubmVjdFwiLCBvbkRpc2Nvbm5lY3QpO1xuICAgICAgLy8gc29ja2V0Lm9mZihcImdhbWVzdGF0ZVwiLCBvbkdhbWVTdGF0ZSk7XG4gICAgICAvLyBzb2NrZXQub2ZmKFwibWVzc2FnZVwiLCBvbk1lc3NhZ2UpO1xuICAgICAgLy8gc29ja2V0Lm9mZihcInJvdW5kc3RhcnRcIiwgb25Sb3VuZFN0YXJ0KTtcbiAgICAgIC8vIHNvY2tldC5vZmYoXCJyb3VuZGVuZFwiLCBvblJvdW5kRW5kKTtcbiAgICAgIC8vIHNvY2tldC5vZmYoXCJsZWFkZXJib2FyZFwiLCBvbkxlYWRlcmJvYXJkKTtcbiAgICB9O1xuICB9LCBbXSk7XG5cbiAgLy8gZnVuY3Rpb24gY29ubmVjdCgpIHtcbiAgLy8gICB0cnkge1xuICAvLyAgICAgc29ja2V0LmNvbm5lY3QoKTtcbiAgLy8gICAgIHNvY2tldC5lbWl0KFwiam9pblwiLCBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInVzZXJuYW1lXCIpIHx8IFwidW5rbm93blwiKTtcbiAgLy8gICAgIHNvY2tldC5lbWl0KFwicmVhZHlcIiwgcmVhZHkpO1xuICAvLyAgICAgc2V0SXNDb25uZWN0ZWQodHJ1ZSk7XG4gIC8vICAgfSBjYXRjaCAoZXJyKSB7XG4gIC8vICAgICBhbGVydChcIkVycm9yIGNvbm5lY3RpbmcgdG8gc2VydmVyXCIpO1xuICAvLyAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgLy8gICB9XG4gIC8vIH1cblxuICAvLyBmdW5jdGlvbiBkaXNjb25uZWN0KCkge1xuICAvLyAgIHNvY2tldC5kaXNjb25uZWN0KCk7XG4gIC8vICAgc2V0SXNDb25uZWN0ZWQoZmFsc2UpO1xuICAvLyB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gc3RhcnRDb3VudGVyKGRlbGF5OiBudW1iZXIpIHtcbiAgICBmb3IgKGxldCBpID0gZGVsYXk7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBzZXRUaW1lKGkpO1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwMCkpO1xuICAgIH1cbiAgICAvLyBmb3IgKGxldCBpID0gMDsgaSA8PSBkZWxheTsgaSsrKSB7XG4gICAgLy8gICBzZXRUaW1lKGRlbGF5IC0gaSk7XG4gICAgLy8gICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDAwKSk7XG4gICAgLy8gfVxuICB9XG5cbiAgY29uc3QgeyB1c2VybmFtZSB9ID0gdXNlR2xvYmFsQ29udGV4dCgpO1xuXG4gIC8vIGNvbnN0IHNldE1zZyA9IChtc2c6IHN0cmluZykgPT4ge1xuICAvLyAgIHVwZGF0ZU1zZyhtc2cpO1xuICAvLyB9O1xuXG4gIC8vIGNvbnN0IHNldE1zZ3MgPSAobXNnczogc3RyaW5nW10pID0+IHtcbiAgLy8gICAvLyB1cGRhdGVNc2dzKG1zZ3MpO1xuICAvLyB9O1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJyZWxhdGl2ZSBoLWZ1bGxcIj5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtgJHtwb3BwaW5zLmNsYXNzTmFtZX1gfT48L2Rpdj5cbiAgICAgIHtnYW1lU3RhdGUgPT09IFwid2FpdGluZ1wiICYmIChcbiAgICAgICAgPE1vZGFsXG4gICAgICAgICAgY3VzdG9tQ2xvc2U9e1tcIlF1aXRcIiwgXCIvbWVudVwiXX1cbiAgICAgICAgICBlbmFibGU9e3RydWV9XG4gICAgICAgICAgZGVmYXVsdE9wZW49e3RydWV9XG4gICAgICAgICAgYWN0aW9ucz17XG4gICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICB7cmVhZHkgPyAoXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Bmb250LXNlbWlib2xkIHRleHQtbGcgJHtwb3BwaW5zLmNsYXNzTmFtZX1gfT5cbiAgICAgICAgICAgICAgICAgIFdhaXQgZm9yIG90aGVyc1xuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICApIDogKFxuICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgIGRpc2FibGVkPXshcm9vbX1cbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17YGJ0biBidG4tc2Vjb25kYXJ5IGZvbnQtYm9sZCAke3BvcHBpbnMuY2xhc3NOYW1lfWB9XG4gICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIFJlYWR5KCk7XG4gICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgIFJlYWR5XG4gICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICl9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICB9XG4gICAgICAgICAgaWQ9XCJhXCJcbiAgICAgICAgICBidG5uYW1lPXtcIkxPTFwifVxuICAgICAgICAgIHRpdGxlPXtcIk9iamVjdCBIdW50XCJ9XG4gICAgICAgID5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2wgZ2FwLTJcIj5cbiAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtMnhsXCI+QXJlIHlvdSByZWFkeSB0byBQbGF5PzwvcD5cbiAgICAgICAgICAgIDxwIGNsYXNzTmFtZT17YGZvbnQtYm9sZCAke3BvcHBpbnMuY2xhc3NOYW1lfWB9PlxuICAgICAgICAgICAgICBDbGljayBvbiB0aGUgYmVsb3cgYnV0dG9uIGFuZCB3YWl0IGZvciB0aGUgb3RoZXIgcGxheWVyc1xuICAgICAgICAgICAgPC9wPlxuICAgICAgICAgICAge2lzUkMgJiYgKFxuICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9e2Bmb250LWJvbGQgJHtwb3BwaW5zLmNsYXNzTmFtZX1gfT5cbiAgICAgICAgICAgICAgICBSb29tIElkOntcIiBcIn1cbiAgICAgICAgICAgICAgICA8c3BhblxuICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dChyb29tSWQpO1xuICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17YHRleHQtcHJpbWFyeSBiZy16aW5jLTgwMCBwLTEgcm91bmRlZC1tZCAke3BvcHBpbnMuY2xhc3NOYW1lfWB9XG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAge3Jvb21JZH1cbiAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICAgICl9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvTW9kYWw+XG4gICAgICApfVxuXG4gICAgICB7Z2FtZVN0YXRlID09PSBcImVuZGVkXCIgJiYgKFxuICAgICAgICA8TW9kYWxcbiAgICAgICAgICBjdXN0b21DbG9zZT17W1wiUXVpdFwiLCBcIi9tZW51XCJdfVxuICAgICAgICAgIGVuYWJsZT17dHJ1ZX1cbiAgICAgICAgICBkZWZhdWx0T3Blbj17dHJ1ZX1cbiAgICAgICAgICBpZD1cImdhbWVlbmRlZFwiXG4gICAgICAgICAgYnRubmFtZT17XCJMT0xcIn1cbiAgICAgICAgICB0aXRsZT17XCJHYW1lIEVuZGVkXCJ9XG4gICAgICAgID5cbiAgICAgICAgICA8TGVhZGVyYm9hcmQgZGF0YT17bGVhZGVyYm9hcmR9IC8+XG4gICAgICAgIDwvTW9kYWw+XG4gICAgICApfVxuXG4gICAgICB7cm91bmRTdGF0ZSA9PT0gXCJlbmRlZFwiICYmIChcbiAgICAgICAgPE1vZGFsXG4gICAgICAgICAgZW5hYmxlPXt0cnVlfVxuICAgICAgICAgIGRlZmF1bHRPcGVuPXt0cnVlfVxuICAgICAgICAgIGlkPXtcIlJvdW5kRW5kXCJ9XG4gICAgICAgICAgdGl0bGU9e1wiUm91bmQgRW5kXCJ9XG4gICAgICAgICAgYnRubmFtZT17XCJsb2xcIn1cbiAgICAgICAgPlxuICAgICAgICAgIDxJbWdTbGlkZXIgZGF0YT17cGxheWVyc1Jlc3BvbnNlfSBvYmpuYW1lPXtvYmpuYW1lfSAvPlxuICAgICAgICA8L01vZGFsPlxuICAgICAgKX1cblxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJteS0yXCI+PC9kaXY+XG5cbiAgICAgIHsvKiA8YnV0dG9uIG9uQ2xpY2s9eygpID0+IHNldE1zZ3MoW1wiU29oYW06IEhlbGxvXCIsIFwiU29oYW06IEhleVwiLCBcImVoc2FhczogSGVsbG8gU29oYW1cIiwgXCJTb2hhbTogVGVzdCAxXCIsIFwiU29oYW06IFRlc3QgMlwiLCBcImVoc2FhczogVGVzdCAzXCIsIFwiZWhzYWFzOiBUZXN0IDRcIiwgXCJlaHNhYXM6IFRlc3QgNVwiLCBcImVoc2FhczogVGVzdCA2XCIsIFwiU29oYW06IFRlc3QgN1wiLCBcImVoc2FhczogVGVzdCA4XCJdKX0gY2xhc3NOYW1lPVwiYnRuIGFic29sdXRlXCI+RHVtbXkgY2hhdHM8L2J1dHRvbj4gKi99XG5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYmctYmFzZS0yMDAgcC0yIG0tMSByb3VuZGVkLW1kIGZsZXgganVzdGlmeS1iZXR3ZWVuXCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgdGV4dC14bCAke2ZvbnQuY2xhc3NOYW1lfWB9PlxuICAgICAgICAgIEZpbmQgYXtcIiBcIn1cbiAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e2B0ZXh0LXByaW1hcnkgY2FwaXRhbGl6ZSAke2ZvbnQuY2xhc3NOYW1lfWB9PlxuICAgICAgICAgICAge29iam5hbWUgfHwgXCJPYmplY3RcIn1cbiAgICAgICAgICA8L3NwYW4+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17YHRleHQteGwgJHtwb3BwaW5zLmNsYXNzTmFtZX1gfT5cbiAgICAgICAgICB7LyogPHNwYW4gY2xhc3NOYW1lPVwiY291bnRkb3duIGZvbnQtbW9ubyBmb250LWJvbGQgdGV4dC1wcmltYXJ5XCI+XG4gICAgICAgICAgICA8c3BhbiBpZD1cImdhbWUtY291bnRkb3duXCI+PC9zcGFuPlxuICAgICAgICAgIDwvc3Bhbj4gKi99XG4gICAgICAgICAgPD48Lz5cbiAgICAgICAgICB7dGltZX1zIGxlZnRcbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cblxuICAgICAgPGRpdlxuICAgICAgICBjbGFzc05hbWU9e2BmbGV4IGp1c3RpZnktYmV0d2VlbiB0ZXh0LW1kIG0tMSBiZy1iYXNlLTIwMCBwLTIgJHtwb3BwaW5zLmNsYXNzTmFtZX0gcm91bmRlZC1tZGB9XG4gICAgICA+XG4gICAgICAgIDxkaXY+U2NvcmU6IHtzY29yZX08L2Rpdj5cbiAgICAgICAgPGRpdj5Sb3VuZDoge3JvdW5kfTwvZGl2PlxuICAgICAgPC9kaXY+XG5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaC1mdWxsIGJnLXJlZC01MDBcIj5cbiAgICAgICAgPENhcHR1cmUgc3VibWl0SW1hZ2U9e3N1Ym1pdEltYWdlfSBjYW5SZXRha2U9e2NhblJldGFrZUltYWdlfSAvPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRhYnMgdGFicy1ib3hlZCBtLTEgbXQtMS41XCI+XG4gICAgICAgICAgPGFcbiAgICAgICAgICAgIGNsYXNzTmFtZT17XG4gICAgICAgICAgICAgIChhY3RpdmVUYWIgPT0gMCAmJiBgdGFiLWFjdGl2ZSB0YWIgdy0xLzIgJHtmb250LmNsYXNzTmFtZX1gKSB8fFxuICAgICAgICAgICAgICBgdGFiIHctMS8yICR7Zm9udC5jbGFzc05hbWV9YFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0QWN0aXZlVGFiKDApfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIENoYXRcbiAgICAgICAgICA8L2E+XG4gICAgICAgICAgPGFcbiAgICAgICAgICAgIGNsYXNzTmFtZT17XG4gICAgICAgICAgICAgIChhY3RpdmVUYWIgPT0gMSAmJiBgdGFiLWFjdGl2ZSB0YWIgdy0xLzIgJHtmb250LmNsYXNzTmFtZX1gKSB8fFxuICAgICAgICAgICAgICBgdGFiIHctMS8yICR7Zm9udC5jbGFzc05hbWV9YFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0QWN0aXZlVGFiKDEpfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIExlYWRlcmJvYXJkXG4gICAgICAgICAgPC9hPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJiZy1ibHVlLTUwMCBoLWZ1bGwgdy1mdWxsIGZsZXgtMVwiPlxuICAgICAgICAgIHthY3RpdmVUYWIgPT0gMCAmJiAoXG4gICAgICAgICAgICA8Q2hhdCBtc2c9e21zZ30gbXNncz17bXNnc30gc2V0TXNnPXtzZXRNc2d9IHNlbmRNc2c9e3NlbmRNc2d9IC8+XG4gICAgICAgICAgKX1cbiAgICAgICAgICB7YWN0aXZlVGFiID09IDEgJiYgPExlYWRlcmJvYXJkIGRhdGE9e2xlYWRlcmJvYXJkfSAvPn1cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cblxuICAgICAgeyExICYmIChcbiAgICAgICAgPGRpdj5cbiAgICAgICAgICA8cCBjbGFzc05hbWU9XCJiZy1yZWQtNDAwIHRleHQtYmxhY2sgbS0xIHJvdW5kZWQtbWQgdGV4dC0yeGwgcC0yXCI+XG4gICAgICAgICAgICBZb3UgbG9vc2UgdGhpcyByb3VuZCBmb29sXG4gICAgICAgICAgPC9wPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICl9XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBwYWdlO1xuIl0sIm5hbWVzIjpbImZvbnQiLCJwb3BwaW5zIiwiUmVhY3QiLCJ1c2VFZmZlY3QiLCJ1c2VTdGF0ZSIsInVzZVNlYXJjaFBhcmFtcyIsImNvbHkiLCJNb2RhbCIsInVzZUdsb2JhbENvbnRleHQiLCJJbWdTbGlkZXIiLCJDYXB0dXJlIiwiQ2hhdCIsIkxlYWRlcmJvYXJkIiwicHJldlRpbWUiLCJEYXRlIiwiZ2V0VGltZSIsImdldEN1clRpbWUiLCJNYXRoIiwicm91bmQiLCJwYWdlIiwic2VhcmNoUGFyYW1zIiwicm9vbUlkIiwic2V0Um9vbUlkIiwiaXNSQyIsInNldElzUkMiLCJyb29tIiwic2V0Um9vbSIsIm1zZyIsInNldE1zZyIsIm1zZ3MiLCJzZXRNc2dzIiwidXNlcm5hbWUiLCJtZXNzYWdlIiwibGVhZGVyYm9hcmQiLCJzZXRMZWFkZXJib2FyZCIsInNjb3JlIiwiYWN0aXZlVGFiIiwic2V0QWN0aXZlVGFiIiwib2JqbmFtZSIsInNldE9iam5hbWUiLCJzZXRTY29yZSIsInNldFJvdW5kIiwidGltZSIsInNldFRpbWUiLCJjYW5SZXRha2VJbWFnZSIsInNldENhblJldGFrZUltYWdlIiwicmVhZHkiLCJzZXRSZWFkeSIsImdhbWVTdGF0ZSIsInNldEdhbWVTdGF0ZSIsInJvdW5kU3RhdGUiLCJzZXRSb3VuZFN0YXRlIiwic2xpZGVJbWFnZXMiLCJ1cmwiLCJjYXB0aW9uIiwicGxheWVyc1Jlc3BvbnNlIiwic2V0UGxheWVyc1Jlc3BvbnNlIiwiaW1nIiwibmFtZSIsIm1hdGNoZWQiLCJ1bmRlZmluZWQiLCJSZWFkeSIsImNvbnNvbGUiLCJsb2ciLCJzZW5kIiwiR2FtZVN0YXJ0cyIsInBheWxvYWQiLCJHYW1lRW5kcyIsIlJvdW5kU3RhcnRzIiwiY3VyUm91bmQiLCJzdGFydENvdW50ZXIiLCJSb3VuZEVuZHMiLCJjdXJTY29yZSIsImltZ3MiLCJzdWJtaXRJbWFnZSIsImltYWdlIiwic3Vic3RyaW5nIiwic2VuZE1zZyIsImFwcGVuZE1zZ3MiLCJwdXNoIiwic2xpY2UiLCJpZCIsImdldCIsImlzUm9vbUNyZWF0b3IiLCJvbkpvaW4iLCJHYW1lcGxheVNldHVwIiwiX3Jvb20iLCJzZXRUaW1lb3V0Iiwib25NZXNzYWdlIiwiY2xpZW50Iiwiam9pbkJ5SWQiLCJ0aGVuIiwiY2F0Y2giLCJlIiwiYWxlcnQiLCJqb2luT3JDcmVhdGUiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiX2lzUkMiLCJkZWxheSIsImkiLCJQcm9taXNlIiwicmVzb2x2ZSIsImRpdiIsImNsYXNzTmFtZSIsImN1c3RvbUNsb3NlIiwiZW5hYmxlIiwiZGVmYXVsdE9wZW4iLCJhY3Rpb25zIiwiYnV0dG9uIiwiZGlzYWJsZWQiLCJvbkNsaWNrIiwiYnRubmFtZSIsInRpdGxlIiwicCIsInNwYW4iLCJuYXZpZ2F0b3IiLCJjbGlwYm9hcmQiLCJ3cml0ZVRleHQiLCJkYXRhIiwiY2FuUmV0YWtlIiwiYSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./app/g/page.tsx\n"));

/***/ }),

/***/ "(app-client)/./lib/coly.ts":
/*!*********************!*\
  !*** ./lib/coly.ts ***!
  \*********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var colyseus_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! colyseus.js */ \"(app-client)/./node_modules/colyseus.js/dist/colyseus.js\");\n/* harmony import */ var colyseus_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(colyseus_js__WEBPACK_IMPORTED_MODULE_0__);\n\n// var client = new Colyseus.Client(\"wss://backend.objecthunt.com\");\nvar client = new colyseus_js__WEBPACK_IMPORTED_MODULE_0__.Client(\"ws://localhost:2567\");\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    client\n});\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbGliL2NvbHkudHMiLCJtYXBwaW5ncyI6Ijs7O0FBQXdDO0FBRXhDLG9FQUFvRTtBQUNwRSxJQUFJQyxTQUFTLElBQUlELCtDQUFlRSxDQUFDO0FBRWpDLCtEQUFlO0lBQUVEO0FBQU8sQ0FBQyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9jb2x5LnRzPzBhMDIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQ29seXNldXMgZnJvbSBcImNvbHlzZXVzLmpzXCI7XG5cbi8vIHZhciBjbGllbnQgPSBuZXcgQ29seXNldXMuQ2xpZW50KFwid3NzOi8vYmFja2VuZC5vYmplY3RodW50LmNvbVwiKTtcbnZhciBjbGllbnQgPSBuZXcgQ29seXNldXMuQ2xpZW50KFwid3M6Ly9sb2NhbGhvc3Q6MjU2N1wiKTtcblxuZXhwb3J0IGRlZmF1bHQgeyBjbGllbnQgfTtcbiJdLCJuYW1lcyI6WyJDb2x5c2V1cyIsImNsaWVudCIsIkNsaWVudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./lib/coly.ts\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js ***!
  \*********************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(()=>{\"use strict\";var e={686:(e,r,t)=>{var n=t(808);var i=Object.create(null);var a=typeof document===\"undefined\";var o=Array.prototype.forEach;function debounce(e,r){var t=0;return function(){var n=this;var i=arguments;var a=function functionCall(){return e.apply(n,i)};clearTimeout(t);t=setTimeout(a,r)}}function noop(){}function getCurrentScriptUrl(e){var r=i[e];if(!r){if(document.currentScript){r=document.currentScript.src}else{var t=document.getElementsByTagName(\"script\");var a=t[t.length-1];if(a){r=a.src}}i[e]=r}return function(e){if(!r){return null}var t=r.split(/([^\\\\/]+)\\.js$/);var i=t&&t[1];if(!i){return[r.replace(\".js\",\".css\")]}if(!e){return[r.replace(\".js\",\".css\")]}return e.split(\",\").map((function(e){var t=new RegExp(\"\".concat(i,\"\\\\.js$\"),\"g\");return n(r.replace(t,\"\".concat(e.replace(/{fileName}/g,i),\".css\")))}))}}function updateCss(e,r){if(!r){if(!e.href){return}r=e.href.split(\"?\")[0]}if(!isUrlRequest(r)){return}if(e.isLoaded===false){return}if(!r||!(r.indexOf(\".css\")>-1)){return}e.visited=true;var t=e.cloneNode();t.isLoaded=false;t.addEventListener(\"load\",(function(){if(t.isLoaded){return}t.isLoaded=true;e.parentNode.removeChild(e)}));t.addEventListener(\"error\",(function(){if(t.isLoaded){return}t.isLoaded=true;e.parentNode.removeChild(e)}));t.href=\"\".concat(r,\"?\").concat(Date.now());if(e.nextSibling){e.parentNode.insertBefore(t,e.nextSibling)}else{e.parentNode.appendChild(t)}}function getReloadUrl(e,r){var t;e=n(e,{stripWWW:false});r.some((function(n){if(e.indexOf(r)>-1){t=n}}));return t}function reloadStyle(e){if(!e){return false}var r=document.querySelectorAll(\"link\");var t=false;o.call(r,(function(r){if(!r.href){return}var n=getReloadUrl(r.href,e);if(!isUrlRequest(n)){return}if(r.visited===true){return}if(n){updateCss(r,n);t=true}}));return t}function reloadAll(){var e=document.querySelectorAll(\"link\");o.call(e,(function(e){if(e.visited===true){return}updateCss(e)}))}function isUrlRequest(e){if(!/^[a-zA-Z][a-zA-Z\\d+\\-.]*:/.test(e)){return false}return true}e.exports=function(e,r){if(a){console.log(\"no window.document found, will not HMR CSS\");return noop}var t=getCurrentScriptUrl(e);function update(){var e=t(r.filename);var n=reloadStyle(e);if(r.locals){console.log(\"[HMR] Detected local css modules. Reload all css\");reloadAll();return}if(n){console.log(\"[HMR] css reload %s\",e.join(\" \"))}else{console.log(\"[HMR] Reload all css\");reloadAll()}}return debounce(update,50)}},808:e=>{function normalizeUrl(e){return e.reduce((function(e,r){switch(r){case\"..\":e.pop();break;case\".\":break;default:e.push(r)}return e}),[]).join(\"/\")}e.exports=function(e){e=e.trim();if(/^data:/i.test(e)){return e}var r=e.indexOf(\"//\")!==-1?e.split(\"//\")[0]+\"//\":\"\";var t=e.replace(new RegExp(r,\"i\"),\"\").split(\"/\");var n=t[0].toLowerCase().replace(/\\.$/,\"\");t[0]=\"\";var i=normalizeUrl(t);return r+n+i}}};var r={};function __nccwpck_require__(t){var n=r[t];if(n!==undefined){return n.exports}var i=r[t]={exports:{}};var a=true;try{e[t](i,i.exports,__nccwpck_require__);a=false}finally{if(a)delete r[t]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var t=__nccwpck_require__(686);module.exports=t})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9taW5pLWNzcy1leHRyYWN0LXBsdWdpbi9obXIvaG90TW9kdWxlUmVwbGFjZW1lbnQuanMiLCJtYXBwaW5ncyI6IjtBQUFBLE1BQU0sYUFBYSxPQUFPLGNBQWMsYUFBYSwwQkFBMEIsb0NBQW9DLDhCQUE4Qix1QkFBdUIsUUFBUSxrQkFBa0IsV0FBVyxnQkFBZ0IsOEJBQThCLHFCQUFxQixnQkFBZ0IsbUJBQW1CLGlCQUFpQixnQ0FBZ0MsV0FBVyxPQUFPLDJCQUEyQiw2QkFBNkIsS0FBSyw4Q0FBOEMsb0JBQW9CLE1BQU0sU0FBUyxPQUFPLG1CQUFtQixPQUFPLFlBQVksZ0NBQWdDLGNBQWMsT0FBTyxnQ0FBZ0MsT0FBTyxnQ0FBZ0MscUNBQXFDLDRDQUE0QywyQ0FBMkMsU0FBUyxnQkFBZ0IsSUFBSSx3QkFBd0IsT0FBTyxZQUFZLE9BQU8sdUJBQXVCLHFCQUFxQixPQUFPLHVCQUF1QixPQUFPLGdDQUFnQyxPQUFPLGVBQWUsb0JBQW9CLGlCQUFpQixzQ0FBc0MsZUFBZSxPQUFPLGdCQUFnQiw0QkFBNEIsR0FBRyx1Q0FBdUMsZUFBZSxPQUFPLGdCQUFnQiw0QkFBNEIsR0FBRywyQ0FBMkMsa0JBQWtCLDJDQUEyQyxLQUFLLDZCQUE2QiwyQkFBMkIsTUFBTSxPQUFPLGVBQWUsRUFBRSxvQkFBb0Isb0JBQW9CLEtBQUssR0FBRyxTQUFTLHdCQUF3QixPQUFPLGFBQWEsd0NBQXdDLFlBQVksc0JBQXNCLFlBQVksT0FBTyw2QkFBNkIscUJBQXFCLE9BQU8scUJBQXFCLE9BQU8sTUFBTSxlQUFlLFFBQVEsR0FBRyxTQUFTLHFCQUFxQix3Q0FBd0Msc0JBQXNCLHFCQUFxQixPQUFPLGFBQWEsR0FBRyx5QkFBeUIseUNBQXlDLGFBQWEsWUFBWSx3QkFBd0IsTUFBTSwwREFBMEQsWUFBWSw2QkFBNkIsa0JBQWtCLG9CQUFvQixxQkFBcUIsYUFBYSxnRUFBZ0UsWUFBWSxPQUFPLE1BQU0sK0NBQStDLEtBQUssb0NBQW9DLGFBQWEsNEJBQTRCLFNBQVMseUJBQXlCLCtCQUErQixVQUFVLGlCQUFpQixNQUFNLGNBQWMsa0JBQWtCLFNBQVMsZ0JBQWdCLHNCQUFzQixXQUFXLHNCQUFzQixTQUFTLG9EQUFvRCxpREFBaUQsMkNBQTJDLFFBQVEsc0JBQXNCLGdCQUFnQixTQUFTLGdDQUFnQyxXQUFXLGtCQUFrQixpQkFBaUIsWUFBWSxZQUFZLFdBQVcsSUFBSSxzQ0FBc0MsUUFBUSxRQUFRLGlCQUFpQixpQkFBaUIsbUVBQW1FLFNBQVMsS0FBSywrQkFBK0IsaUJBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vaG1yL2hvdE1vZHVsZVJlcGxhY2VtZW50LmpzPzRjZTMiXSwic291cmNlc0NvbnRlbnQiOlsiKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIGU9ezY4NjooZSxyLHQpPT57dmFyIG49dCg4MDgpO3ZhciBpPU9iamVjdC5jcmVhdGUobnVsbCk7dmFyIGE9dHlwZW9mIGRvY3VtZW50PT09XCJ1bmRlZmluZWRcIjt2YXIgbz1BcnJheS5wcm90b3R5cGUuZm9yRWFjaDtmdW5jdGlvbiBkZWJvdW5jZShlLHIpe3ZhciB0PTA7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIG49dGhpczt2YXIgaT1hcmd1bWVudHM7dmFyIGE9ZnVuY3Rpb24gZnVuY3Rpb25DYWxsKCl7cmV0dXJuIGUuYXBwbHkobixpKX07Y2xlYXJUaW1lb3V0KHQpO3Q9c2V0VGltZW91dChhLHIpfX1mdW5jdGlvbiBub29wKCl7fWZ1bmN0aW9uIGdldEN1cnJlbnRTY3JpcHRVcmwoZSl7dmFyIHI9aVtlXTtpZighcil7aWYoZG9jdW1lbnQuY3VycmVudFNjcmlwdCl7cj1kb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyY31lbHNle3ZhciB0PWRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2NyaXB0XCIpO3ZhciBhPXRbdC5sZW5ndGgtMV07aWYoYSl7cj1hLnNyY319aVtlXT1yfXJldHVybiBmdW5jdGlvbihlKXtpZighcil7cmV0dXJuIG51bGx9dmFyIHQ9ci5zcGxpdCgvKFteXFxcXC9dKylcXC5qcyQvKTt2YXIgaT10JiZ0WzFdO2lmKCFpKXtyZXR1cm5bci5yZXBsYWNlKFwiLmpzXCIsXCIuY3NzXCIpXX1pZighZSl7cmV0dXJuW3IucmVwbGFjZShcIi5qc1wiLFwiLmNzc1wiKV19cmV0dXJuIGUuc3BsaXQoXCIsXCIpLm1hcCgoZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IFJlZ0V4cChcIlwiLmNvbmNhdChpLFwiXFxcXC5qcyRcIiksXCJnXCIpO3JldHVybiBuKHIucmVwbGFjZSh0LFwiXCIuY29uY2F0KGUucmVwbGFjZSgve2ZpbGVOYW1lfS9nLGkpLFwiLmNzc1wiKSkpfSkpfX1mdW5jdGlvbiB1cGRhdGVDc3MoZSxyKXtpZighcil7aWYoIWUuaHJlZil7cmV0dXJufXI9ZS5ocmVmLnNwbGl0KFwiP1wiKVswXX1pZighaXNVcmxSZXF1ZXN0KHIpKXtyZXR1cm59aWYoZS5pc0xvYWRlZD09PWZhbHNlKXtyZXR1cm59aWYoIXJ8fCEoci5pbmRleE9mKFwiLmNzc1wiKT4tMSkpe3JldHVybn1lLnZpc2l0ZWQ9dHJ1ZTt2YXIgdD1lLmNsb25lTm9kZSgpO3QuaXNMb2FkZWQ9ZmFsc2U7dC5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLChmdW5jdGlvbigpe2lmKHQuaXNMb2FkZWQpe3JldHVybn10LmlzTG9hZGVkPXRydWU7ZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGUpfSkpO3QuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsKGZ1bmN0aW9uKCl7aWYodC5pc0xvYWRlZCl7cmV0dXJufXQuaXNMb2FkZWQ9dHJ1ZTtlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZSl9KSk7dC5ocmVmPVwiXCIuY29uY2F0KHIsXCI/XCIpLmNvbmNhdChEYXRlLm5vdygpKTtpZihlLm5leHRTaWJsaW5nKXtlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHQsZS5uZXh0U2libGluZyl9ZWxzZXtlLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQodCl9fWZ1bmN0aW9uIGdldFJlbG9hZFVybChlLHIpe3ZhciB0O2U9bihlLHtzdHJpcFdXVzpmYWxzZX0pO3Iuc29tZSgoZnVuY3Rpb24obil7aWYoZS5pbmRleE9mKHIpPi0xKXt0PW59fSkpO3JldHVybiB0fWZ1bmN0aW9uIHJlbG9hZFN0eWxlKGUpe2lmKCFlKXtyZXR1cm4gZmFsc2V9dmFyIHI9ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImxpbmtcIik7dmFyIHQ9ZmFsc2U7by5jYWxsKHIsKGZ1bmN0aW9uKHIpe2lmKCFyLmhyZWYpe3JldHVybn12YXIgbj1nZXRSZWxvYWRVcmwoci5ocmVmLGUpO2lmKCFpc1VybFJlcXVlc3Qobikpe3JldHVybn1pZihyLnZpc2l0ZWQ9PT10cnVlKXtyZXR1cm59aWYobil7dXBkYXRlQ3NzKHIsbik7dD10cnVlfX0pKTtyZXR1cm4gdH1mdW5jdGlvbiByZWxvYWRBbGwoKXt2YXIgZT1kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwibGlua1wiKTtvLmNhbGwoZSwoZnVuY3Rpb24oZSl7aWYoZS52aXNpdGVkPT09dHJ1ZSl7cmV0dXJufXVwZGF0ZUNzcyhlKX0pKX1mdW5jdGlvbiBpc1VybFJlcXVlc3QoZSl7aWYoIS9eW2EtekEtWl1bYS16QS1aXFxkK1xcLS5dKjovLnRlc3QoZSkpe3JldHVybiBmYWxzZX1yZXR1cm4gdHJ1ZX1lLmV4cG9ydHM9ZnVuY3Rpb24oZSxyKXtpZihhKXtjb25zb2xlLmxvZyhcIm5vIHdpbmRvdy5kb2N1bWVudCBmb3VuZCwgd2lsbCBub3QgSE1SIENTU1wiKTtyZXR1cm4gbm9vcH12YXIgdD1nZXRDdXJyZW50U2NyaXB0VXJsKGUpO2Z1bmN0aW9uIHVwZGF0ZSgpe3ZhciBlPXQoci5maWxlbmFtZSk7dmFyIG49cmVsb2FkU3R5bGUoZSk7aWYoci5sb2NhbHMpe2NvbnNvbGUubG9nKFwiW0hNUl0gRGV0ZWN0ZWQgbG9jYWwgY3NzIG1vZHVsZXMuIFJlbG9hZCBhbGwgY3NzXCIpO3JlbG9hZEFsbCgpO3JldHVybn1pZihuKXtjb25zb2xlLmxvZyhcIltITVJdIGNzcyByZWxvYWQgJXNcIixlLmpvaW4oXCIgXCIpKX1lbHNle2NvbnNvbGUubG9nKFwiW0hNUl0gUmVsb2FkIGFsbCBjc3NcIik7cmVsb2FkQWxsKCl9fXJldHVybiBkZWJvdW5jZSh1cGRhdGUsNTApfX0sODA4OmU9PntmdW5jdGlvbiBub3JtYWxpemVVcmwoZSl7cmV0dXJuIGUucmVkdWNlKChmdW5jdGlvbihlLHIpe3N3aXRjaChyKXtjYXNlXCIuLlwiOmUucG9wKCk7YnJlYWs7Y2FzZVwiLlwiOmJyZWFrO2RlZmF1bHQ6ZS5wdXNoKHIpfXJldHVybiBlfSksW10pLmpvaW4oXCIvXCIpfWUuZXhwb3J0cz1mdW5jdGlvbihlKXtlPWUudHJpbSgpO2lmKC9eZGF0YTovaS50ZXN0KGUpKXtyZXR1cm4gZX12YXIgcj1lLmluZGV4T2YoXCIvL1wiKSE9PS0xP2Uuc3BsaXQoXCIvL1wiKVswXStcIi8vXCI6XCJcIjt2YXIgdD1lLnJlcGxhY2UobmV3IFJlZ0V4cChyLFwiaVwiKSxcIlwiKS5zcGxpdChcIi9cIik7dmFyIG49dFswXS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1xcLiQvLFwiXCIpO3RbMF09XCJcIjt2YXIgaT1ub3JtYWxpemVVcmwodCk7cmV0dXJuIHIrbitpfX19O3ZhciByPXt9O2Z1bmN0aW9uIF9fbmNjd3Bja19yZXF1aXJlX18odCl7dmFyIG49clt0XTtpZihuIT09dW5kZWZpbmVkKXtyZXR1cm4gbi5leHBvcnRzfXZhciBpPXJbdF09e2V4cG9ydHM6e319O3ZhciBhPXRydWU7dHJ5e2VbdF0oaSxpLmV4cG9ydHMsX19uY2N3cGNrX3JlcXVpcmVfXyk7YT1mYWxzZX1maW5hbGx5e2lmKGEpZGVsZXRlIHJbdF19cmV0dXJuIGkuZXhwb3J0c31pZih0eXBlb2YgX19uY2N3cGNrX3JlcXVpcmVfXyE9PVwidW5kZWZpbmVkXCIpX19uY2N3cGNrX3JlcXVpcmVfXy5hYj1fX2Rpcm5hbWUrXCIvXCI7dmFyIHQ9X19uY2N3cGNrX3JlcXVpcmVfXyg2ODYpO21vZHVsZS5leHBvcnRzPXR9KSgpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/font/google/target.css?{\"path\":\"app\\\\components\\\\ImgSlider.tsx\",\"import\":\"Poppins\",\"arguments\":[{\"weight\":[\"400\",\"500\",\"600\",\"700\"],\"subsets\":[\"latin\"]}],\"variableName\":\"poppins\"}":
/*!***************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/font/google/target.css?{"path":"app\\components\\ImgSlider.tsx","import":"Poppins","arguments":[{"weight":["400","500","600","700"],"subsets":["latin"]}],"variableName":"poppins"} ***!
  \***************************************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// extracted by mini-css-extract-plugin\nmodule.exports = {\"style\":{\"fontFamily\":\"'__Poppins_3bfef9', '__Poppins_Fallback_3bfef9'\",\"fontStyle\":\"normal\"},\"className\":\"__className_3bfef9\"};\n    if(true) {\n      // 1703070892304\n      var cssReload = __webpack_require__(/*! ./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js */ \"(app-client)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\")(module.id, {\"publicPath\":\"/_next/\",\"esModule\":false,\"locals\":true});\n      module.hot.dispose(cssReload);\n      \n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZm9udC9nb29nbGUvdGFyZ2V0LmNzcz97XCJwYXRoXCI6XCJhcHBcXFxcY29tcG9uZW50c1xcXFxJbWdTbGlkZXIudHN4XCIsXCJpbXBvcnRcIjpcIlBvcHBpbnNcIixcImFyZ3VtZW50c1wiOlt7XCJ3ZWlnaHRcIjpbXCI0MDBcIixcIjUwMFwiLFwiNjAwXCIsXCI3MDBcIl0sXCJzdWJzZXRzXCI6W1wibGF0aW5cIl19XSxcInZhcmlhYmxlTmFtZVwiOlwicG9wcGluc1wifSIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGtCQUFrQixTQUFTLG9GQUFvRjtBQUMvRyxPQUFPLElBQVU7QUFDakI7QUFDQSxzQkFBc0IsbUJBQU8sQ0FBQyxpTUFBb0csY0FBYyxzREFBc0Q7QUFDdE0sTUFBTSxVQUFVO0FBQ2hCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9mb250L2dvb2dsZS90YXJnZXQuY3NzP2Q0MzAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5tb2R1bGUuZXhwb3J0cyA9IHtcInN0eWxlXCI6e1wiZm9udEZhbWlseVwiOlwiJ19fUG9wcGluc18zYmZlZjknLCAnX19Qb3BwaW5zX0ZhbGxiYWNrXzNiZmVmOSdcIixcImZvbnRTdHlsZVwiOlwibm9ybWFsXCJ9LFwiY2xhc3NOYW1lXCI6XCJfX2NsYXNzTmFtZV8zYmZlZjlcIn07XG4gICAgaWYobW9kdWxlLmhvdCkge1xuICAgICAgLy8gMTcwMzA3MDg5MjMwNFxuICAgICAgdmFyIGNzc1JlbG9hZCA9IHJlcXVpcmUoXCJHOi9vYmplY3RfaHVudC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL21pbmktY3NzLWV4dHJhY3QtcGx1Z2luL2htci9ob3RNb2R1bGVSZXBsYWNlbWVudC5qc1wiKShtb2R1bGUuaWQsIHtcInB1YmxpY1BhdGhcIjpcIi9fbmV4dC9cIixcImVzTW9kdWxlXCI6ZmFsc2UsXCJsb2NhbHNcIjp0cnVlfSk7XG4gICAgICBtb2R1bGUuaG90LmRpc3Bvc2UoY3NzUmVsb2FkKTtcbiAgICAgIFxuICAgIH1cbiAgIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/font/google/target.css?{\"path\":\"app\\\\components\\\\ImgSlider.tsx\",\"import\":\"Poppins\",\"arguments\":[{\"weight\":[\"400\",\"500\",\"600\",\"700\"],\"subsets\":[\"latin\"]}],\"variableName\":\"poppins\"}\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/font/google/target.css?{\"path\":\"app\\\\components\\\\Modal.tsx\",\"import\":\"Bungee\",\"arguments\":[{\"weight\":\"400\",\"subsets\":[\"latin\"]}],\"variableName\":\"font1\"}":
/*!************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/font/google/target.css?{"path":"app\\components\\Modal.tsx","import":"Bungee","arguments":[{"weight":"400","subsets":["latin"]}],"variableName":"font1"} ***!
  \************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// extracted by mini-css-extract-plugin\nmodule.exports = {\"style\":{\"fontFamily\":\"'__Bungee_Fallback_d10ee3', '__Bungee_Fallback_Fallback_d10ee3'\",\"fontWeight\":400,\"fontStyle\":\"normal\"},\"className\":\"__className_d10ee3\"};\n    if(true) {\n      // 1703070856999\n      var cssReload = __webpack_require__(/*! ./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js */ \"(app-client)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\")(module.id, {\"publicPath\":\"/_next/\",\"esModule\":false,\"locals\":true});\n      module.hot.dispose(cssReload);\n      \n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZm9udC9nb29nbGUvdGFyZ2V0LmNzcz97XCJwYXRoXCI6XCJhcHBcXFxcY29tcG9uZW50c1xcXFxNb2RhbC50c3hcIixcImltcG9ydFwiOlwiQnVuZ2VlXCIsXCJhcmd1bWVudHNcIjpbe1wid2VpZ2h0XCI6XCI0MDBcIixcInN1YnNldHNcIjpbXCJsYXRpblwiXX1dLFwidmFyaWFibGVOYW1lXCI6XCJmb250MVwifSIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGtCQUFrQixTQUFTLHFIQUFxSDtBQUNoSixPQUFPLElBQVU7QUFDakI7QUFDQSxzQkFBc0IsbUJBQU8sQ0FBQyxpTUFBb0csY0FBYyxzREFBc0Q7QUFDdE0sTUFBTSxVQUFVO0FBQ2hCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9mb250L2dvb2dsZS90YXJnZXQuY3NzPzg4N2QiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5tb2R1bGUuZXhwb3J0cyA9IHtcInN0eWxlXCI6e1wiZm9udEZhbWlseVwiOlwiJ19fQnVuZ2VlX0ZhbGxiYWNrX2QxMGVlMycsICdfX0J1bmdlZV9GYWxsYmFja19GYWxsYmFja19kMTBlZTMnXCIsXCJmb250V2VpZ2h0XCI6NDAwLFwiZm9udFN0eWxlXCI6XCJub3JtYWxcIn0sXCJjbGFzc05hbWVcIjpcIl9fY2xhc3NOYW1lX2QxMGVlM1wifTtcbiAgICBpZihtb2R1bGUuaG90KSB7XG4gICAgICAvLyAxNzAzMDcwODU2OTk5XG4gICAgICB2YXIgY3NzUmVsb2FkID0gcmVxdWlyZShcIkc6L29iamVjdF9odW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vaG1yL2hvdE1vZHVsZVJlcGxhY2VtZW50LmpzXCIpKG1vZHVsZS5pZCwge1wicHVibGljUGF0aFwiOlwiL19uZXh0L1wiLFwiZXNNb2R1bGVcIjpmYWxzZSxcImxvY2Fsc1wiOnRydWV9KTtcbiAgICAgIG1vZHVsZS5ob3QuZGlzcG9zZShjc3NSZWxvYWQpO1xuICAgICAgXG4gICAgfVxuICAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/font/google/target.css?{\"path\":\"app\\\\components\\\\Modal.tsx\",\"import\":\"Bungee\",\"arguments\":[{\"weight\":\"400\",\"subsets\":[\"latin\"]}],\"variableName\":\"font1\"}\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/font/google/target.css?{\"path\":\"app\\\\components\\\\Room\\\\Capture.tsx\",\"import\":\"Poppins\",\"arguments\":[{\"weight\":\"500\",\"subsets\":[\"latin\"]}],\"variableName\":\"poppins\"}":
/*!***********************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/font/google/target.css?{"path":"app\\components\\Room\\Capture.tsx","import":"Poppins","arguments":[{"weight":"500","subsets":["latin"]}],"variableName":"poppins"} ***!
  \***********************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// extracted by mini-css-extract-plugin\nmodule.exports = {\"style\":{\"fontFamily\":\"'__Poppins_3c03fe', '__Poppins_Fallback_3c03fe'\",\"fontWeight\":500,\"fontStyle\":\"normal\"},\"className\":\"__className_3c03fe\"};\n    if(true) {\n      // 1703070892333\n      var cssReload = __webpack_require__(/*! ./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js */ \"(app-client)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\")(module.id, {\"publicPath\":\"/_next/\",\"esModule\":false,\"locals\":true});\n      module.hot.dispose(cssReload);\n      \n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZm9udC9nb29nbGUvdGFyZ2V0LmNzcz97XCJwYXRoXCI6XCJhcHBcXFxcY29tcG9uZW50c1xcXFxSb29tXFxcXENhcHR1cmUudHN4XCIsXCJpbXBvcnRcIjpcIlBvcHBpbnNcIixcImFyZ3VtZW50c1wiOlt7XCJ3ZWlnaHRcIjpcIjUwMFwiLFwic3Vic2V0c1wiOltcImxhdGluXCJdfV0sXCJ2YXJpYWJsZU5hbWVcIjpcInBvcHBpbnNcIn0iLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxrQkFBa0IsU0FBUyxxR0FBcUc7QUFDaEksT0FBTyxJQUFVO0FBQ2pCO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMsaU1BQW9HLGNBQWMsc0RBQXNEO0FBQ3RNLE1BQU0sVUFBVTtBQUNoQjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZm9udC9nb29nbGUvdGFyZ2V0LmNzcz8zNmU1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxubW9kdWxlLmV4cG9ydHMgPSB7XCJzdHlsZVwiOntcImZvbnRGYW1pbHlcIjpcIidfX1BvcHBpbnNfM2MwM2ZlJywgJ19fUG9wcGluc19GYWxsYmFja18zYzAzZmUnXCIsXCJmb250V2VpZ2h0XCI6NTAwLFwiZm9udFN0eWxlXCI6XCJub3JtYWxcIn0sXCJjbGFzc05hbWVcIjpcIl9fY2xhc3NOYW1lXzNjMDNmZVwifTtcbiAgICBpZihtb2R1bGUuaG90KSB7XG4gICAgICAvLyAxNzAzMDcwODkyMzMzXG4gICAgICB2YXIgY3NzUmVsb2FkID0gcmVxdWlyZShcIkc6L29iamVjdF9odW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vaG1yL2hvdE1vZHVsZVJlcGxhY2VtZW50LmpzXCIpKG1vZHVsZS5pZCwge1wicHVibGljUGF0aFwiOlwiL19uZXh0L1wiLFwiZXNNb2R1bGVcIjpmYWxzZSxcImxvY2Fsc1wiOnRydWV9KTtcbiAgICAgIG1vZHVsZS5ob3QuZGlzcG9zZShjc3NSZWxvYWQpO1xuICAgICAgXG4gICAgfVxuICAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/font/google/target.css?{\"path\":\"app\\\\components\\\\Room\\\\Capture.tsx\",\"import\":\"Poppins\",\"arguments\":[{\"weight\":\"500\",\"subsets\":[\"latin\"]}],\"variableName\":\"poppins\"}\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/font/google/target.css?{\"path\":\"app\\\\components\\\\Room\\\\Chat.tsx\",\"import\":\"Bungee\",\"arguments\":[{\"weight\":\"400\",\"subsets\":[\"latin\"]}],\"variableName\":\"bungee\"}":
/*!******************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/font/google/target.css?{"path":"app\\components\\Room\\Chat.tsx","import":"Bungee","arguments":[{"weight":"400","subsets":["latin"]}],"variableName":"bungee"} ***!
  \******************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// extracted by mini-css-extract-plugin\nmodule.exports = {\"style\":{\"fontFamily\":\"'__Bungee_e557cd', '__Bungee_Fallback_e557cd'\",\"fontWeight\":400,\"fontStyle\":\"normal\"},\"className\":\"__className_e557cd\"};\n    if(true) {\n      // 1703070892149\n      var cssReload = __webpack_require__(/*! ./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js */ \"(app-client)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\")(module.id, {\"publicPath\":\"/_next/\",\"esModule\":false,\"locals\":true});\n      module.hot.dispose(cssReload);\n      \n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZm9udC9nb29nbGUvdGFyZ2V0LmNzcz97XCJwYXRoXCI6XCJhcHBcXFxcY29tcG9uZW50c1xcXFxSb29tXFxcXENoYXQudHN4XCIsXCJpbXBvcnRcIjpcIkJ1bmdlZVwiLFwiYXJndW1lbnRzXCI6W3tcIndlaWdodFwiOlwiNDAwXCIsXCJzdWJzZXRzXCI6W1wibGF0aW5cIl19XSxcInZhcmlhYmxlTmFtZVwiOlwiYnVuZ2VlXCJ9IiwibWFwcGluZ3MiOiJBQUFBO0FBQ0Esa0JBQWtCLFNBQVMsbUdBQW1HO0FBQzlILE9BQU8sSUFBVTtBQUNqQjtBQUNBLHNCQUFzQixtQkFBTyxDQUFDLGlNQUFvRyxjQUFjLHNEQUFzRDtBQUN0TSxNQUFNLFVBQVU7QUFDaEI7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2ZvbnQvZ29vZ2xlL3RhcmdldC5jc3M/MDUwNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbm1vZHVsZS5leHBvcnRzID0ge1wic3R5bGVcIjp7XCJmb250RmFtaWx5XCI6XCInX19CdW5nZWVfZTU1N2NkJywgJ19fQnVuZ2VlX0ZhbGxiYWNrX2U1NTdjZCdcIixcImZvbnRXZWlnaHRcIjo0MDAsXCJmb250U3R5bGVcIjpcIm5vcm1hbFwifSxcImNsYXNzTmFtZVwiOlwiX19jbGFzc05hbWVfZTU1N2NkXCJ9O1xuICAgIGlmKG1vZHVsZS5ob3QpIHtcbiAgICAgIC8vIDE3MDMwNzA4OTIxNDlcbiAgICAgIHZhciBjc3NSZWxvYWQgPSByZXF1aXJlKFwiRzovb2JqZWN0X2h1bnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9taW5pLWNzcy1leHRyYWN0LXBsdWdpbi9obXIvaG90TW9kdWxlUmVwbGFjZW1lbnQuanNcIikobW9kdWxlLmlkLCB7XCJwdWJsaWNQYXRoXCI6XCIvX25leHQvXCIsXCJlc01vZHVsZVwiOmZhbHNlLFwibG9jYWxzXCI6dHJ1ZX0pO1xuICAgICAgbW9kdWxlLmhvdC5kaXNwb3NlKGNzc1JlbG9hZCk7XG4gICAgICBcbiAgICB9XG4gICJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/font/google/target.css?{\"path\":\"app\\\\components\\\\Room\\\\Chat.tsx\",\"import\":\"Bungee\",\"arguments\":[{\"weight\":\"400\",\"subsets\":[\"latin\"]}],\"variableName\":\"bungee\"}\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/font/google/target.css?{\"path\":\"app\\\\components\\\\Room\\\\Chat.tsx\",\"import\":\"Poppins\",\"arguments\":[{\"weight\":\"500\",\"subsets\":[\"latin\"]}],\"variableName\":\"poppins\"}":
/*!********************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/font/google/target.css?{"path":"app\\components\\Room\\Chat.tsx","import":"Poppins","arguments":[{"weight":"500","subsets":["latin"]}],"variableName":"poppins"} ***!
  \********************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// extracted by mini-css-extract-plugin\nmodule.exports = {\"style\":{\"fontFamily\":\"'__Poppins_3c03fe', '__Poppins_Fallback_3c03fe'\",\"fontWeight\":500,\"fontStyle\":\"normal\"},\"className\":\"__className_3c03fe\"};\n    if(true) {\n      // 1703070891584\n      var cssReload = __webpack_require__(/*! ./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js */ \"(app-client)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\")(module.id, {\"publicPath\":\"/_next/\",\"esModule\":false,\"locals\":true});\n      module.hot.dispose(cssReload);\n      \n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZm9udC9nb29nbGUvdGFyZ2V0LmNzcz97XCJwYXRoXCI6XCJhcHBcXFxcY29tcG9uZW50c1xcXFxSb29tXFxcXENoYXQudHN4XCIsXCJpbXBvcnRcIjpcIlBvcHBpbnNcIixcImFyZ3VtZW50c1wiOlt7XCJ3ZWlnaHRcIjpcIjUwMFwiLFwic3Vic2V0c1wiOltcImxhdGluXCJdfV0sXCJ2YXJpYWJsZU5hbWVcIjpcInBvcHBpbnNcIn0iLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxrQkFBa0IsU0FBUyxxR0FBcUc7QUFDaEksT0FBTyxJQUFVO0FBQ2pCO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMsaU1BQW9HLGNBQWMsc0RBQXNEO0FBQ3RNLE1BQU0sVUFBVTtBQUNoQjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZm9udC9nb29nbGUvdGFyZ2V0LmNzcz9kNjk3Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxubW9kdWxlLmV4cG9ydHMgPSB7XCJzdHlsZVwiOntcImZvbnRGYW1pbHlcIjpcIidfX1BvcHBpbnNfM2MwM2ZlJywgJ19fUG9wcGluc19GYWxsYmFja18zYzAzZmUnXCIsXCJmb250V2VpZ2h0XCI6NTAwLFwiZm9udFN0eWxlXCI6XCJub3JtYWxcIn0sXCJjbGFzc05hbWVcIjpcIl9fY2xhc3NOYW1lXzNjMDNmZVwifTtcbiAgICBpZihtb2R1bGUuaG90KSB7XG4gICAgICAvLyAxNzAzMDcwODkxNTg0XG4gICAgICB2YXIgY3NzUmVsb2FkID0gcmVxdWlyZShcIkc6L29iamVjdF9odW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vaG1yL2hvdE1vZHVsZVJlcGxhY2VtZW50LmpzXCIpKG1vZHVsZS5pZCwge1wicHVibGljUGF0aFwiOlwiL19uZXh0L1wiLFwiZXNNb2R1bGVcIjpmYWxzZSxcImxvY2Fsc1wiOnRydWV9KTtcbiAgICAgIG1vZHVsZS5ob3QuZGlzcG9zZShjc3NSZWxvYWQpO1xuICAgICAgXG4gICAgfVxuICAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/font/google/target.css?{\"path\":\"app\\\\components\\\\Room\\\\Chat.tsx\",\"import\":\"Poppins\",\"arguments\":[{\"weight\":\"500\",\"subsets\":[\"latin\"]}],\"variableName\":\"poppins\"}\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/font/google/target.css?{\"path\":\"app\\\\g\\\\page.tsx\",\"import\":\"Bungee\",\"arguments\":[{\"weight\":\"400\",\"subsets\":[\"latin\"]}],\"variableName\":\"font\"}":
/*!*************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/font/google/target.css?{"path":"app\\g\\page.tsx","import":"Bungee","arguments":[{"weight":"400","subsets":["latin"]}],"variableName":"font"} ***!
  \*************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// extracted by mini-css-extract-plugin\nmodule.exports = {\"style\":{\"fontFamily\":\"'__Bungee_e557cd', '__Bungee_Fallback_e557cd'\",\"fontWeight\":400,\"fontStyle\":\"normal\"},\"className\":\"__className_e557cd\"};\n    if(true) {\n      // 1703070890714\n      var cssReload = __webpack_require__(/*! ./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js */ \"(app-client)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\")(module.id, {\"publicPath\":\"/_next/\",\"esModule\":false,\"locals\":true});\n      module.hot.dispose(cssReload);\n      \n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZm9udC9nb29nbGUvdGFyZ2V0LmNzcz97XCJwYXRoXCI6XCJhcHBcXFxcZ1xcXFxwYWdlLnRzeFwiLFwiaW1wb3J0XCI6XCJCdW5nZWVcIixcImFyZ3VtZW50c1wiOlt7XCJ3ZWlnaHRcIjpcIjQwMFwiLFwic3Vic2V0c1wiOltcImxhdGluXCJdfV0sXCJ2YXJpYWJsZU5hbWVcIjpcImZvbnRcIn0iLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxrQkFBa0IsU0FBUyxtR0FBbUc7QUFDOUgsT0FBTyxJQUFVO0FBQ2pCO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMsaU1BQW9HLGNBQWMsc0RBQXNEO0FBQ3RNLE1BQU0sVUFBVTtBQUNoQjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZm9udC9nb29nbGUvdGFyZ2V0LmNzcz8xNGRlIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxubW9kdWxlLmV4cG9ydHMgPSB7XCJzdHlsZVwiOntcImZvbnRGYW1pbHlcIjpcIidfX0J1bmdlZV9lNTU3Y2QnLCAnX19CdW5nZWVfRmFsbGJhY2tfZTU1N2NkJ1wiLFwiZm9udFdlaWdodFwiOjQwMCxcImZvbnRTdHlsZVwiOlwibm9ybWFsXCJ9LFwiY2xhc3NOYW1lXCI6XCJfX2NsYXNzTmFtZV9lNTU3Y2RcIn07XG4gICAgaWYobW9kdWxlLmhvdCkge1xuICAgICAgLy8gMTcwMzA3MDg5MDcxNFxuICAgICAgdmFyIGNzc1JlbG9hZCA9IHJlcXVpcmUoXCJHOi9vYmplY3RfaHVudC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL21pbmktY3NzLWV4dHJhY3QtcGx1Z2luL2htci9ob3RNb2R1bGVSZXBsYWNlbWVudC5qc1wiKShtb2R1bGUuaWQsIHtcInB1YmxpY1BhdGhcIjpcIi9fbmV4dC9cIixcImVzTW9kdWxlXCI6ZmFsc2UsXCJsb2NhbHNcIjp0cnVlfSk7XG4gICAgICBtb2R1bGUuaG90LmRpc3Bvc2UoY3NzUmVsb2FkKTtcbiAgICAgIFxuICAgIH1cbiAgIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/font/google/target.css?{\"path\":\"app\\\\g\\\\page.tsx\",\"import\":\"Bungee\",\"arguments\":[{\"weight\":\"400\",\"subsets\":[\"latin\"]}],\"variableName\":\"font\"}\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/font/google/target.css?{\"path\":\"app\\\\g\\\\page.tsx\",\"import\":\"Poppins\",\"arguments\":[{\"weight\":[\"400\",\"500\",\"600\",\"700\"],\"subsets\":[\"latin\"]}],\"variableName\":\"poppins\"}":
/*!*************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/font/google/target.css?{"path":"app\\g\\page.tsx","import":"Poppins","arguments":[{"weight":["400","500","600","700"],"subsets":["latin"]}],"variableName":"poppins"} ***!
  \*************************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// extracted by mini-css-extract-plugin\nmodule.exports = {\"style\":{\"fontFamily\":\"'__Poppins_3bfef9', '__Poppins_Fallback_3bfef9'\",\"fontStyle\":\"normal\"},\"className\":\"__className_3bfef9\"};\n    if(true) {\n      // 1703070890723\n      var cssReload = __webpack_require__(/*! ./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js */ \"(app-client)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\")(module.id, {\"publicPath\":\"/_next/\",\"esModule\":false,\"locals\":true});\n      module.hot.dispose(cssReload);\n      \n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZm9udC9nb29nbGUvdGFyZ2V0LmNzcz97XCJwYXRoXCI6XCJhcHBcXFxcZ1xcXFxwYWdlLnRzeFwiLFwiaW1wb3J0XCI6XCJQb3BwaW5zXCIsXCJhcmd1bWVudHNcIjpbe1wid2VpZ2h0XCI6W1wiNDAwXCIsXCI1MDBcIixcIjYwMFwiLFwiNzAwXCJdLFwic3Vic2V0c1wiOltcImxhdGluXCJdfV0sXCJ2YXJpYWJsZU5hbWVcIjpcInBvcHBpbnNcIn0iLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxrQkFBa0IsU0FBUyxvRkFBb0Y7QUFDL0csT0FBTyxJQUFVO0FBQ2pCO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMsaU1BQW9HLGNBQWMsc0RBQXNEO0FBQ3RNLE1BQU0sVUFBVTtBQUNoQjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZm9udC9nb29nbGUvdGFyZ2V0LmNzcz8yYTVlIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxubW9kdWxlLmV4cG9ydHMgPSB7XCJzdHlsZVwiOntcImZvbnRGYW1pbHlcIjpcIidfX1BvcHBpbnNfM2JmZWY5JywgJ19fUG9wcGluc19GYWxsYmFja18zYmZlZjknXCIsXCJmb250U3R5bGVcIjpcIm5vcm1hbFwifSxcImNsYXNzTmFtZVwiOlwiX19jbGFzc05hbWVfM2JmZWY5XCJ9O1xuICAgIGlmKG1vZHVsZS5ob3QpIHtcbiAgICAgIC8vIDE3MDMwNzA4OTA3MjNcbiAgICAgIHZhciBjc3NSZWxvYWQgPSByZXF1aXJlKFwiRzovb2JqZWN0X2h1bnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9taW5pLWNzcy1leHRyYWN0LXBsdWdpbi9obXIvaG90TW9kdWxlUmVwbGFjZW1lbnQuanNcIikobW9kdWxlLmlkLCB7XCJwdWJsaWNQYXRoXCI6XCIvX25leHQvXCIsXCJlc01vZHVsZVwiOmZhbHNlLFwibG9jYWxzXCI6dHJ1ZX0pO1xuICAgICAgbW9kdWxlLmhvdC5kaXNwb3NlKGNzc1JlbG9hZCk7XG4gICAgICBcbiAgICB9XG4gICJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/font/google/target.css?{\"path\":\"app\\\\g\\\\page.tsx\",\"import\":\"Poppins\",\"arguments\":[{\"weight\":[\"400\",\"500\",\"600\",\"700\"],\"subsets\":[\"latin\"]}],\"variableName\":\"poppins\"}\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/compiled/process/browser.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/compiled/process/browser.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){var e={229:function(e){var t=e.exports={};var r;var n;function defaultSetTimout(){throw new Error(\"setTimeout has not been defined\")}function defaultClearTimeout(){throw new Error(\"clearTimeout has not been defined\")}(function(){try{if(typeof setTimeout===\"function\"){r=setTimeout}else{r=defaultSetTimout}}catch(e){r=defaultSetTimout}try{if(typeof clearTimeout===\"function\"){n=clearTimeout}else{n=defaultClearTimeout}}catch(e){n=defaultClearTimeout}})();function runTimeout(e){if(r===setTimeout){return setTimeout(e,0)}if((r===defaultSetTimout||!r)&&setTimeout){r=setTimeout;return setTimeout(e,0)}try{return r(e,0)}catch(t){try{return r.call(null,e,0)}catch(t){return r.call(this,e,0)}}}function runClearTimeout(e){if(n===clearTimeout){return clearTimeout(e)}if((n===defaultClearTimeout||!n)&&clearTimeout){n=clearTimeout;return clearTimeout(e)}try{return n(e)}catch(t){try{return n.call(null,e)}catch(t){return n.call(this,e)}}}var i=[];var o=false;var u;var a=-1;function cleanUpNextTick(){if(!o||!u){return}o=false;if(u.length){i=u.concat(i)}else{a=-1}if(i.length){drainQueue()}}function drainQueue(){if(o){return}var e=runTimeout(cleanUpNextTick);o=true;var t=i.length;while(t){u=i;i=[];while(++a<t){if(u){u[a].run()}}a=-1;t=i.length}u=null;o=false;runClearTimeout(e)}t.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1){for(var r=1;r<arguments.length;r++){t[r-1]=arguments[r]}}i.push(new Item(e,t));if(i.length===1&&!o){runTimeout(drainQueue)}};function Item(e,t){this.fun=e;this.array=t}Item.prototype.run=function(){this.fun.apply(null,this.array)};t.title=\"browser\";t.browser=true;t.env={};t.argv=[];t.version=\"\";t.versions={};function noop(){}t.on=noop;t.addListener=noop;t.once=noop;t.off=noop;t.removeListener=noop;t.removeAllListeners=noop;t.emit=noop;t.prependListener=noop;t.prependOnceListener=noop;t.listeners=function(e){return[]};t.binding=function(e){throw new Error(\"process.binding is not supported\")};t.cwd=function(){return\"/\"};t.chdir=function(e){throw new Error(\"process.chdir is not supported\")};t.umask=function(){return 0}}};var t={};function __nccwpck_require__(r){var n=t[r];if(n!==undefined){return n.exports}var i=t[r]={exports:{}};var o=true;try{e[r](i,i.exports,__nccwpck_require__);o=false}finally{if(o)delete t[r]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var r=__nccwpck_require__(229);module.exports=r})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wcm9jZXNzL2Jyb3dzZXIuanMiLCJtYXBwaW5ncyI6IjtBQUFBLFlBQVksT0FBTyxnQkFBZ0IsbUJBQW1CLE1BQU0sTUFBTSw0QkFBNEIsbURBQW1ELCtCQUErQixxREFBcUQsWUFBWSxJQUFJLG1DQUFtQyxhQUFhLEtBQUssb0JBQW9CLFNBQVMsbUJBQW1CLElBQUkscUNBQXFDLGVBQWUsS0FBSyx1QkFBdUIsU0FBUyx1QkFBdUIsSUFBSSx1QkFBdUIsbUJBQW1CLHVCQUF1QiwyQ0FBMkMsYUFBYSx1QkFBdUIsSUFBSSxjQUFjLFNBQVMsSUFBSSx3QkFBd0IsU0FBUywwQkFBMEIsNEJBQTRCLHFCQUFxQix1QkFBdUIsZ0RBQWdELGVBQWUsdUJBQXVCLElBQUksWUFBWSxTQUFTLElBQUksc0JBQXNCLFNBQVMsd0JBQXdCLFNBQVMsWUFBWSxNQUFNLFNBQVMsMkJBQTJCLFdBQVcsT0FBTyxRQUFRLGFBQWEsY0FBYyxLQUFLLEtBQUssYUFBYSxjQUFjLHNCQUFzQixNQUFNLE9BQU8sa0NBQWtDLE9BQU8sZUFBZSxTQUFTLElBQUksS0FBSyxhQUFhLE1BQU0sWUFBWSxLQUFLLFdBQVcsT0FBTyxRQUFRLG1CQUFtQix1QkFBdUIsb0NBQW9DLHVCQUF1QixZQUFZLG1CQUFtQixLQUFLLHFCQUFxQixzQkFBc0IscUJBQXFCLHlCQUF5QixtQkFBbUIsV0FBVyxhQUFhLDhCQUE4QixpQ0FBaUMsa0JBQWtCLGVBQWUsU0FBUyxVQUFVLGFBQWEsY0FBYyxpQkFBaUIsVUFBVSxtQkFBbUIsWUFBWSxXQUFXLHNCQUFzQiwwQkFBMEIsWUFBWSx1QkFBdUIsMkJBQTJCLHdCQUF3QixVQUFVLHNCQUFzQixxREFBcUQsaUJBQWlCLFdBQVcsb0JBQW9CLG1EQUFtRCxtQkFBbUIsWUFBWSxTQUFTLGdDQUFnQyxXQUFXLGtCQUFrQixpQkFBaUIsWUFBWSxZQUFZLFdBQVcsSUFBSSxzQ0FBc0MsUUFBUSxRQUFRLGlCQUFpQixpQkFBaUIsbUVBQW1FLFNBQVMsS0FBSywrQkFBK0IsaUJBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzcy9icm93c2VyLmpzPzk3ODAiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7dmFyIGU9ezIyOTpmdW5jdGlvbihlKXt2YXIgdD1lLmV4cG9ydHM9e307dmFyIHI7dmFyIG47ZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpe3Rocm93IG5ldyBFcnJvcihcInNldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcIil9ZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCgpe3Rocm93IG5ldyBFcnJvcihcImNsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZFwiKX0oZnVuY3Rpb24oKXt0cnl7aWYodHlwZW9mIHNldFRpbWVvdXQ9PT1cImZ1bmN0aW9uXCIpe3I9c2V0VGltZW91dH1lbHNle3I9ZGVmYXVsdFNldFRpbW91dH19Y2F0Y2goZSl7cj1kZWZhdWx0U2V0VGltb3V0fXRyeXtpZih0eXBlb2YgY2xlYXJUaW1lb3V0PT09XCJmdW5jdGlvblwiKXtuPWNsZWFyVGltZW91dH1lbHNle249ZGVmYXVsdENsZWFyVGltZW91dH19Y2F0Y2goZSl7bj1kZWZhdWx0Q2xlYXJUaW1lb3V0fX0pKCk7ZnVuY3Rpb24gcnVuVGltZW91dChlKXtpZihyPT09c2V0VGltZW91dCl7cmV0dXJuIHNldFRpbWVvdXQoZSwwKX1pZigocj09PWRlZmF1bHRTZXRUaW1vdXR8fCFyKSYmc2V0VGltZW91dCl7cj1zZXRUaW1lb3V0O3JldHVybiBzZXRUaW1lb3V0KGUsMCl9dHJ5e3JldHVybiByKGUsMCl9Y2F0Y2godCl7dHJ5e3JldHVybiByLmNhbGwobnVsbCxlLDApfWNhdGNoKHQpe3JldHVybiByLmNhbGwodGhpcyxlLDApfX19ZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KGUpe2lmKG49PT1jbGVhclRpbWVvdXQpe3JldHVybiBjbGVhclRpbWVvdXQoZSl9aWYoKG49PT1kZWZhdWx0Q2xlYXJUaW1lb3V0fHwhbikmJmNsZWFyVGltZW91dCl7bj1jbGVhclRpbWVvdXQ7cmV0dXJuIGNsZWFyVGltZW91dChlKX10cnl7cmV0dXJuIG4oZSl9Y2F0Y2godCl7dHJ5e3JldHVybiBuLmNhbGwobnVsbCxlKX1jYXRjaCh0KXtyZXR1cm4gbi5jYWxsKHRoaXMsZSl9fX12YXIgaT1bXTt2YXIgbz1mYWxzZTt2YXIgdTt2YXIgYT0tMTtmdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKXtpZighb3x8IXUpe3JldHVybn1vPWZhbHNlO2lmKHUubGVuZ3RoKXtpPXUuY29uY2F0KGkpfWVsc2V7YT0tMX1pZihpLmxlbmd0aCl7ZHJhaW5RdWV1ZSgpfX1mdW5jdGlvbiBkcmFpblF1ZXVlKCl7aWYobyl7cmV0dXJufXZhciBlPXJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtvPXRydWU7dmFyIHQ9aS5sZW5ndGg7d2hpbGUodCl7dT1pO2k9W107d2hpbGUoKythPHQpe2lmKHUpe3VbYV0ucnVuKCl9fWE9LTE7dD1pLmxlbmd0aH11PW51bGw7bz1mYWxzZTtydW5DbGVhclRpbWVvdXQoZSl9dC5uZXh0VGljaz1mdW5jdGlvbihlKXt2YXIgdD1uZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aC0xKTtpZihhcmd1bWVudHMubGVuZ3RoPjEpe2Zvcih2YXIgcj0xO3I8YXJndW1lbnRzLmxlbmd0aDtyKyspe3Rbci0xXT1hcmd1bWVudHNbcl19fWkucHVzaChuZXcgSXRlbShlLHQpKTtpZihpLmxlbmd0aD09PTEmJiFvKXtydW5UaW1lb3V0KGRyYWluUXVldWUpfX07ZnVuY3Rpb24gSXRlbShlLHQpe3RoaXMuZnVuPWU7dGhpcy5hcnJheT10fUl0ZW0ucHJvdG90eXBlLnJ1bj1mdW5jdGlvbigpe3RoaXMuZnVuLmFwcGx5KG51bGwsdGhpcy5hcnJheSl9O3QudGl0bGU9XCJicm93c2VyXCI7dC5icm93c2VyPXRydWU7dC5lbnY9e307dC5hcmd2PVtdO3QudmVyc2lvbj1cIlwiO3QudmVyc2lvbnM9e307ZnVuY3Rpb24gbm9vcCgpe310Lm9uPW5vb3A7dC5hZGRMaXN0ZW5lcj1ub29wO3Qub25jZT1ub29wO3Qub2ZmPW5vb3A7dC5yZW1vdmVMaXN0ZW5lcj1ub29wO3QucmVtb3ZlQWxsTGlzdGVuZXJzPW5vb3A7dC5lbWl0PW5vb3A7dC5wcmVwZW5kTGlzdGVuZXI9bm9vcDt0LnByZXBlbmRPbmNlTGlzdGVuZXI9bm9vcDt0Lmxpc3RlbmVycz1mdW5jdGlvbihlKXtyZXR1cm5bXX07dC5iaW5kaW5nPWZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcihcInByb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkXCIpfTt0LmN3ZD1mdW5jdGlvbigpe3JldHVyblwiL1wifTt0LmNoZGlyPWZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcihcInByb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZFwiKX07dC51bWFzaz1mdW5jdGlvbigpe3JldHVybiAwfX19O3ZhciB0PXt9O2Z1bmN0aW9uIF9fbmNjd3Bja19yZXF1aXJlX18ocil7dmFyIG49dFtyXTtpZihuIT09dW5kZWZpbmVkKXtyZXR1cm4gbi5leHBvcnRzfXZhciBpPXRbcl09e2V4cG9ydHM6e319O3ZhciBvPXRydWU7dHJ5e2Vbcl0oaSxpLmV4cG9ydHMsX19uY2N3cGNrX3JlcXVpcmVfXyk7bz1mYWxzZX1maW5hbGx5e2lmKG8pZGVsZXRlIHRbcl19cmV0dXJuIGkuZXhwb3J0c31pZih0eXBlb2YgX19uY2N3cGNrX3JlcXVpcmVfXyE9PVwidW5kZWZpbmVkXCIpX19uY2N3cGNrX3JlcXVpcmVfXy5hYj1fX2Rpcm5hbWUrXCIvXCI7dmFyIHI9X19uY2N3cGNrX3JlcXVpcmVfXygyMjkpO21vZHVsZS5leHBvcnRzPXJ9KSgpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/compiled/process/browser.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-client)/./node_modules/next/dist/compiled/react/index.js\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_SERVER_CONTEXT_TYPE = Symbol.for('react.server_context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar REACT_CACHE_TYPE = Symbol.for('react.cache');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false; // Track which Fiber(s) schedule render work.\n\nvar REACT_CLIENT_REFERENCE$1 = Symbol.for('react.client.reference');\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_CLIENT_REFERENCE$1 || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n} // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  {\n    if (typeof type.tag === 'number') {\n      error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n    }\n  }\n\n  if (typeof type === 'function') {\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n    case REACT_CACHE_TYPE:\n      {\n        return 'Cache';\n      }\n\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n        return getContextName(context) + '.Consumer';\n\n      case REACT_PROVIDER_TYPE:\n        var provider = type;\n        return getContextName(provider._context) + '.Provider';\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n\n      case REACT_SERVER_CONTEXT_TYPE:\n        {\n          var context2 = type;\n          return (context2.displayName || context2._globalName) + '.Provider';\n        }\n\n    }\n  }\n\n  return null;\n}\n\nvar assign = Object.assign;\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, source, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if (!fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  var control;\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n\n  try {\n    // This should throw.\n    if (construct) {\n      // Something should be setting the props in the constructor.\n      var Fake = function () {\n        throw Error();\n      }; // $FlowFixMe[prop-missing]\n\n\n      Object.defineProperty(Fake.prototype, 'props', {\n        set: function () {\n          // We use a throwing setter instead of frozen or non-writable props\n          // because that won't throw in a non-strict mode function.\n          throw Error();\n        }\n      });\n\n      if (typeof Reflect === 'object' && Reflect.construct) {\n        // We construct a different control for this case to include any extra\n        // frames added by the construct call.\n        try {\n          Reflect.construct(Fake, []);\n        } catch (x) {\n          control = x;\n        }\n\n        Reflect.construct(fn, [], Fake);\n      } else {\n        try {\n          Fake.call();\n        } catch (x) {\n          control = x;\n        } // $FlowFixMe[prop-missing] found when upgrading Flow\n\n\n        fn.call(Fake.prototype);\n      }\n    } else {\n      try {\n        throw Error();\n      } catch (x) {\n        control = x;\n      } // TODO(luna): This will currently only throw if the function component\n      // tries to access React/ReactDOM/props. We should probably make this throw\n      // in simple components too\n\n\n      fn();\n    }\n  } catch (sample) {\n    // This is inlined manually because closure doesn't do it for us.\n    if (sample && control && typeof sample.stack === 'string') {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sample.stack.split('\\n');\n      var controlLines = control.stack.split('\\n');\n      var s = sampleLines.length - 1;\n      var c = controlLines.length - 1;\n\n      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n        // We expect at least one stack frame to be shared.\n        // Typically this will be the root most one. However, stack frames may be\n        // cut off due to maximum stack limits. In this case, one maybe cut off\n        // earlier than the other. We assume that the sample is longer or the same\n        // and there for cut off earlier. So we should find the root most frame in\n        // the sample somewhere in the control.\n        c--;\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, source, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\n// $FlowFixMe[method-unbinding]\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar loggedTypeFailures = {};\nvar ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement$1(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction checkPropTypes(typeSpecs, values, location, componentName, element) {\n  {\n    // $FlowFixMe[incompatible-use] This is okay but Flow doesn't know it.\n    var has = Function.call.bind(hasOwnProperty);\n\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            // eslint-disable-next-line react-internal/prod-error-codes\n            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n\n          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n        } catch (ex) {\n          error$1 = ex;\n        }\n\n        if (error$1 && !(error$1 instanceof Error)) {\n          setCurrentlyValidatingElement$1(element);\n\n          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\n\n          setCurrentlyValidatingElement$1(null);\n        }\n\n        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error$1.message] = true;\n          setCurrentlyValidatingElement$1(element);\n\n          error('Failed %s type: %s', location, error$1.message);\n\n          setCurrentlyValidatingElement$1(null);\n        }\n      }\n    }\n  }\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n/*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object'; // $FlowFixMe[incompatible-return]\n\n    return type;\n  }\n} // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\nvar RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true\n};\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner$1.current && self && ReactCurrentOwner$1.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner$1.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingRef = function () {\n      if (!specialPropRefWarningShown) {\n        specialPropRefWarningShown = true;\n\n        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingRef.isReactWarning = true;\n    Object.defineProperty(props, 'ref', {\n      get: warnAboutAccessingRef,\n      configurable: true\n    });\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nfunction ReactElement(type, key, ref, self, source, owner, props) {\n  var element = {\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // self and source are DEV only properties.\n\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    }); // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n}\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV$1(type, config, maybeKey, source, self) {\n  {\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      ref = config.ref;\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    return ReactElement(type, key, ref, self, source, ReactCurrentOwner$1.current, props);\n  }\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\nvar REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nvar propTypesMisspellWarningShown;\n\n{\n  propTypesMisspellWarningShown = false;\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  {\n    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n\nfunction getSourceInfoErrorAddendum(source) {\n  {\n    if (source !== undefined) {\n      var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n      var lineNumber = source.lineNumber;\n      return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n    }\n\n    return '';\n  }\n}\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\n\n\nvar ownerHasKeyUseWarning = {};\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement(null);\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object' || !node) {\n      return;\n    }\n\n    if (node.$$typeof === REACT_CLIENT_REFERENCE) ; else if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\n\n\nfunction validatePropTypes(element) {\n  {\n    var type = element.type;\n\n    if (type === null || type === undefined || typeof type === 'string') {\n      return;\n    }\n\n    if (type.$$typeof === REACT_CLIENT_REFERENCE) {\n      return;\n    }\n\n    var propTypes;\n\n    if (typeof type === 'function') {\n      propTypes = type.propTypes;\n    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n    // Inner props are checked in the reconciler.\n    type.$$typeof === REACT_MEMO_TYPE)) {\n      propTypes = type.propTypes;\n    } else {\n      return;\n    }\n\n    if (propTypes) {\n      // Intentionally inside to avoid triggering lazy initializers:\n      var name = getComponentNameFromType(type);\n      checkPropTypes(propTypes, element.props, 'prop', name, element);\n    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n      var _name = getComponentNameFromType(type);\n\n      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\n    }\n\n    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n    }\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement(null);\n    }\n  }\n}\n\nvar didWarnAboutKeySpread = {};\nfunction jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n  {\n    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n    // succeed and there will likely be errors in render.\n\n    if (!validType) {\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var sourceInfo = getSourceInfoErrorAddendum(source);\n\n      if (sourceInfo) {\n        info += sourceInfo;\n      } else {\n        info += getDeclarationErrorAddendum();\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    }\n\n    var element = jsxDEV$1(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n    // TODO: Drop this when these are no longer allowed as the type argument.\n\n    if (element == null) {\n      return element;\n    } // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing errors.\n    // We don't want exception behavior to differ between dev and prod.\n    // (Rendering will throw with a helpful message and as soon as the type is\n    // fixed, the key warnings will appear.)\n\n\n    if (validType) {\n      var children = props.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    }\n\n    if (hasOwnProperty.call(props, 'key')) {\n      var componentName = getComponentNameFromType(type);\n      var keys = Object.keys(props).filter(function (k) {\n        return k !== 'key';\n      });\n      var beforeExample = keys.length > 0 ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}' : '{key: someKey}';\n\n      if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n        var afterExample = keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n\n        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + '  let props = %s;\\n' + '  <%s {...props} />\\n' + 'React keys must be passed directly to JSX without using spread:\\n' + '  let props = %s;\\n' + '  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);\n\n        didWarnAboutKeySpread[componentName + beforeExample] = true;\n      }\n    }\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    } else {\n      validatePropTypes(element);\n    }\n\n    return element;\n  }\n} // These two functions exist to still get child warnings in dev\n\nvar jsxDEV = jsxWithValidation ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsxDEV = jsxDEV;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixJQUFJLElBQXFDO0FBQ3pDO0FBQ0E7O0FBRUEsWUFBWSxtQkFBTyxDQUFDLCtGQUEwQjs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHLGVBQWU7QUFDaEg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBLEtBQUssR0FBRzs7QUFFUixrREFBa0Q7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsNEJBQTRCO0FBQzVCO0FBQ0EscUNBQXFDOztBQUVyQyxnQ0FBZ0M7QUFDaEM7QUFDQTs7QUFFQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLFNBQVM7QUFDVCx1QkFBdUI7QUFDdkI7QUFDQSxTQUFTO0FBQ1QsdUJBQXVCO0FBQ3ZCO0FBQ0EsU0FBUztBQUNULHdCQUF3QjtBQUN4QjtBQUNBLFNBQVM7QUFDVCx3QkFBd0I7QUFDeEI7QUFDQSxTQUFTO0FBQ1QsaUNBQWlDO0FBQ2pDO0FBQ0EsU0FBUztBQUNULDJCQUEyQjtBQUMzQjtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJEQUEyRDs7QUFFM0Q7QUFDQTs7QUFFQTtBQUNBLHlEQUF5RDtBQUN6RDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7O0FBR1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQTtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7OztBQUdsQjtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkhBQTJIO0FBQzNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0VBQW9FOztBQUVwRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrR0FBa0c7O0FBRWxHO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLGVBQWU7QUFDMUIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHOztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEdBQUc7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLDJEQUEyRCxVQUFVO0FBQ3JFLHlCQUF5QixVQUFVO0FBQ25DO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixZQUFZLFNBQVM7QUFDckI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLEdBQUc7QUFDZDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw2REFBNkQ7QUFDN0Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxHQUFHO0FBQ2Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0RBQW9EO0FBQ3BELHNCQUFzQixpQkFBaUI7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekI7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sNENBQTRDOztBQUU1Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGlCQUFpQjtBQUNyQzs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDREQUE0RDtBQUM1RDs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxQkFBcUI7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCw4Q0FBOEMsZ0RBQWdELE1BQU0sYUFBYTs7QUFFakg7QUFDQSwrQ0FBK0Msa0NBQWtDLE9BQU87O0FBRXhGLHVHQUF1RyxjQUFjLFVBQVUsZ0dBQWdHLGtCQUFrQixVQUFVLFVBQVU7O0FBRXJRO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUEsZ0JBQWdCO0FBQ2hCLGNBQWM7QUFDZCxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzP2YwOGMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0XCIpO1xuXG4vLyBBVFRFTlRJT05cbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcbi8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKTtcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcbnZhciBSRUFDVF9TRVJWRVJfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc2VydmVyX2NvbnRleHQnKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xudmFyIFJFQUNUX0NBQ0hFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jYWNoZScpO1xudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaXRlbSk7XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxudmFyIGVuYWJsZUNhY2hlRWxlbWVudCA9IGZhbHNlO1xudmFyIGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nID0gZmFsc2U7IC8vIE5vIGtub3duIGJ1Z3MsIGJ1dCBuZWVkcyBwZXJmb3JtYW5jZSB0ZXN0aW5nXG5cbnZhciBlbmFibGVMZWdhY3lIaWRkZW4gPSBmYWxzZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpYmVyXG4vLyBzdHVmZi4gSW50ZW5kZWQgdG8gZW5hYmxlIFJlYWN0IGNvcmUgbWVtYmVycyB0byBtb3JlIGVhc2lseSBkZWJ1ZyBzY2hlZHVsaW5nXG4vLyBpc3N1ZXMgaW4gREVWIGJ1aWxkcy5cblxudmFyIGVuYWJsZURlYnVnVHJhY2luZyA9IGZhbHNlOyAvLyBUcmFjayB3aGljaCBGaWJlcihzKSBzY2hlZHVsZSByZW5kZXIgd29yay5cblxudmFyIFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNsaWVudC5yZWZlcmVuY2UnKTtcbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBOb3RlOiB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyAoZS5nLiBpZiBpdCdzIGEgcG9seWZpbGwpLlxuXG5cbiAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fCBlbmFibGVEZWJ1Z1RyYWNpbmcgIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgZW5hYmxlTGVnYWN5SGlkZGVuICB8fCB0eXBlID09PSBSRUFDVF9PRkZTQ1JFRU5fVFlQRSB8fCBlbmFibGVTY29wZUFQSSAgfHwgZW5hYmxlQ2FjaGVFbGVtZW50ICB8fCBlbmFibGVUcmFuc2l0aW9uVHJhY2luZyApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCkge1xuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxuICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2VcbiAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIEZsaWdodCBidWlsZCB0aGlzIHdpbGwgZW5kIHVwIGJlaW5nIHVzZWRcbiAgICAvLyB3aXRoLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSB8fCB0eXBlLmdldE1vZHVsZUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XG4gIHZhciBkaXNwbGF5TmFtZSA9IG91dGVyVHlwZS5kaXNwbGF5TmFtZTtcblxuICBpZiAoZGlzcGxheU5hbWUpIHtcbiAgICByZXR1cm4gZGlzcGxheU5hbWU7XG4gIH1cblxuICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuICByZXR1cm4gZnVuY3Rpb25OYW1lICE9PSAnJyA/IHdyYXBwZXJOYW1lICsgXCIoXCIgKyBmdW5jdGlvbk5hbWUgKyBcIilcIiA6IHdyYXBwZXJOYW1lO1xufSAvLyBLZWVwIGluIHN5bmMgd2l0aCByZWFjdC1yZWNvbmNpbGVyL2dldENvbXBvbmVudE5hbWVGcm9tRmliZXJcblxuXG5mdW5jdGlvbiBnZXRDb250ZXh0TmFtZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0Jztcbn0gLy8gTm90ZSB0aGF0IHRoZSByZWNvbmNpbGVyIHBhY2thZ2Ugc2hvdWxkIGdlbmVyYWxseSBwcmVmZXIgdG8gdXNlIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoKSBpbnN0ZWFkLlxuXG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAvLyBIb3N0IHJvb3QsIHRleHQgbm9kZSBvciBqdXN0IGludmFsaWQgdHlwZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuXG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiAnUG9ydGFsJztcblxuICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgIHJldHVybiAnUHJvZmlsZXInO1xuXG4gICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG5cbiAgICBjYXNlIFJFQUNUX0NBQ0hFX1RZUEU6XG4gICAgICB7XG4gICAgICAgIHJldHVybiAnQ2FjaGUnO1xuICAgICAgfVxuXG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUoY29udGV4dCkgKyAnLkNvbnN1bWVyJztcblxuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB2YXIgcHJvdmlkZXIgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldFdyYXBwZWROYW1lKHR5cGUsIHR5cGUucmVuZGVyLCAnRm9yd2FyZFJlZicpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgdmFyIG91dGVyTmFtZSA9IHR5cGUuZGlzcGxheU5hbWUgfHwgbnVsbDtcblxuICAgICAgICBpZiAob3V0ZXJOYW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG91dGVyTmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCAnTWVtbyc7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShpbml0KHBheWxvYWQpKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9TRVJWRVJfQ09OVEVYVF9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGNvbnRleHQyID0gdHlwZTtcbiAgICAgICAgICByZXR1cm4gKGNvbnRleHQyLmRpc3BsYXlOYW1lIHx8IGNvbnRleHQyLl9nbG9iYWxOYW1lKSArICcuUHJvdmlkZXInO1xuICAgICAgICB9XG5cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRyb2w7XG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBUaGlzIHNob3VsZCB0aHJvdy5cbiAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCAncHJvcHMnLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd29uJ3QgdGhyb3cgaW4gYSBub24tc3RyaWN0IG1vZGUgZnVuY3Rpb24uXG4gICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAvLyBmcmFtZXMgYWRkZWQgYnkgdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICB0cnkge1xuICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgRmFrZS5jYWxsKCk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfSAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ10gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG5cbiAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgfSAvLyBUT0RPKGx1bmEpOiBUaGlzIHdpbGwgY3VycmVudGx5IG9ubHkgdGhyb3cgaWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudFxuICAgICAgLy8gdHJpZXMgdG8gYWNjZXNzIFJlYWN0L1JlYWN0RE9NL3Byb3BzLiBXZSBzaG91bGQgcHJvYmFibHkgbWFrZSB0aGlzIHRocm93XG4gICAgICAvLyBpbiBzaW1wbGUgY29tcG9uZW50cyB0b29cblxuXG4gICAgICBmbigpO1xuICAgIH1cbiAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgdHlwZW9mIHNhbXBsZS5zdGFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZS5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbC5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgcyA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCAmJiBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgIC8vIGN1dCBvZmYgZHVlIHRvIG1heGltdW0gc3RhY2sgbGltaXRzLiBJbiB0aGlzIGNhc2UsIG9uZSBtYXliZSBjdXQgb2ZmXG4gICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgIC8vIHRoZSBzYW1wbGUgc29tZXdoZXJlIGluIHRoZSBjb250cm9sLlxuICAgICAgICBjLS07XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG4gICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXG4gICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cbiAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuXG4gICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpOyAvLyBJZiBvdXIgY29tcG9uZW50IGZyYW1lIGlzIGxhYmVsZWQgXCI8YW5vbnltb3VzPlwiXG4gICAgICAgICAgICAgICAgLy8gYnV0IHdlIGhhdmUgYSB1c2VyLXByb3ZpZGVkIFwiZGlzcGxheU5hbWVcIlxuICAgICAgICAgICAgICAgIC8vIHNwbGljZSBpdCBpbiB0byBtYWtlIHRoZSBzdGFjayBtb3JlIHJlYWRhYmxlLlxuXG5cbiAgICAgICAgICAgICAgICBpZiAoZm4uZGlzcGxheU5hbWUgJiYgX2ZyYW1lLmluY2x1ZGVzKCc8YW5vbnltb3VzPicpKSB7XG4gICAgICAgICAgICAgICAgICBfZnJhbWUgPSBfZnJhbWUucmVwbGFjZSgnPGFub255bW91cz4nLCBmbi5kaXNwbGF5TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgdmFyIHByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gIHJldHVybiAhIShwcm90b3R5cGUgJiYgcHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZSwgc291cmNlLCBvd25lckZuKSB7XG5cbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHtcbiAgICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKHR5cGUsIHNob3VsZENvbnN0cnVjdCh0eXBlKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSh0eXBlKTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2UnKTtcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZUxpc3QnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLnJlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAvLyBNZW1vIG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUudHlwZSwgc291cmNlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBzb3VyY2UsIG93bmVyRm4pO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbi8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBlbGVtZW50KSB7XG4gIHtcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIFRoaXMgaXMgb2theSBidXQgRmxvdyBkb2Vzbid0IGtub3cgaXQuXG4gICAgdmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChoYXNPd25Qcm9wZXJ0eSk7XG5cbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3IkMSA9IHZvaWQgMDsgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcbiAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcigoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgKyAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nICsgJ1RoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLicpO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXJyb3IkMSA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJyk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IkMSA9IGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgJiYgIShlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzJyArICcgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yJDEpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvciQxLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yJDEubWVzc2FnZV0gPSB0cnVlO1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignRmFpbGVkICVzIHR5cGU6ICVzJywgbG9jYXRpb24sIGVycm9yJDEubWVzc2FnZSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblxuZnVuY3Rpb24gaXNBcnJheShhKSB7XG4gIHJldHVybiBpc0FycmF5SW1wbChhKTtcbn1cblxuLypcbiAqIFRoZSBgJycgKyB2YWx1ZWAgcGF0dGVybiAodXNlZCBpbiBwZXJmLXNlbnNpdGl2ZSBjb2RlKSB0aHJvd3MgZm9yIFN5bWJvbFxuICogYW5kIFRlbXBvcmFsLiogdHlwZXMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yMjA2NC5cbiAqXG4gKiBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIHdpbGwgdGhyb3cgYW4gZWFzaWVyLXRvLXVuZGVyc3RhbmQsXG4gKiBlYXNpZXItdG8tZGVidWcgZXhjZXB0aW9uIHdpdGggYSBjbGVhciBlcnJvcnMgbWVzc2FnZSBtZXNzYWdlIGV4cGxhaW5pbmcgdGhlXG4gKiBwcm9ibGVtLiAoSW5zdGVhZCBvZiBhIGNvbmZ1c2luZyBleGNlcHRpb24gdGhyb3duIGluc2lkZSB0aGUgaW1wbGVtZW50YXRpb25cbiAqIG9mIHRoZSBgdmFsdWVgIG9iamVjdCkuXG4gKi9cbi8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl0gb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5mdW5jdGlvbiB0eXBlTmFtZSh2YWx1ZSkge1xuICB7XG4gICAgLy8gdG9TdHJpbmdUYWcgaXMgbmVlZGVkIGZvciBuYW1lc3BhY2VkIHR5cGVzIGxpa2UgVGVtcG9yYWwuSW5zdGFudFxuICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLnRvU3RyaW5nVGFnO1xuICAgIHZhciB0eXBlID0gaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdPYmplY3QnOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dXG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxufSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuXG5cbmZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSB7XG4gIHtcbiAgICB0cnkge1xuICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIC8vIElmIHlvdSBlbmRlZCB1cCBoZXJlIGJ5IGZvbGxvd2luZyBhbiBleGNlcHRpb24gY2FsbCBzdGFjaywgaGVyZSdzIHdoYXQnc1xuICAvLyBoYXBwZW5lZDogeW91IHN1cHBsaWVkIGFuIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gUmVhY3QgKGFzIGEgcHJvcCwga2V5LFxuICAvLyBET00gYXR0cmlidXRlLCBDU1MgcHJvcGVydHksIHN0cmluZyByZWYsIGV0Yy4pIGFuZCB3aGVuIFJlYWN0IHRyaWVkIHRvXG4gIC8vIGNvZXJjZSBpdCB0byBhIHN0cmluZyB1c2luZyBgJycgKyB2YWx1ZWAsIGFuIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxuICAvL1xuICAvLyBUaGUgbW9zdCBjb21tb24gdHlwZXMgdGhhdCB3aWxsIGNhdXNlIHRoaXMgZXhjZXB0aW9uIGFyZSBgU3ltYm9sYCBpbnN0YW5jZXNcbiAgLy8gYW5kIFRlbXBvcmFsIG9iamVjdHMgbGlrZSBgVGVtcG9yYWwuSW5zdGFudGAuIEJ1dCBhbnkgb2JqZWN0IHRoYXQgaGFzIGFcbiAgLy8gYHZhbHVlT2ZgIG9yIGBbU3ltYm9sLnRvUHJpbWl0aXZlXWAgbWV0aG9kIHRoYXQgdGhyb3dzIHdpbGwgYWxzbyBjYXVzZSB0aGlzXG4gIC8vIGV4Y2VwdGlvbi4gKExpYnJhcnkgYXV0aG9ycyBkbyB0aGlzIHRvIHByZXZlbnQgdXNlcnMgZnJvbSB1c2luZyBidWlsdC1pblxuICAvLyBudW1lcmljIG9wZXJhdG9ycyBsaWtlIGArYCBvciBjb21wYXJpc29uIG9wZXJhdG9ycyBsaWtlIGA+PWAgYmVjYXVzZSBjdXN0b21cbiAgLy8gbWV0aG9kcyBhcmUgbmVlZGVkIHRvIHBlcmZvcm0gYWNjdXJhdGUgYXJpdGhtZXRpYyBvciBjb21wYXJpc29uLilcbiAgLy9cbiAgLy8gVG8gZml4IHRoZSBwcm9ibGVtLCBjb2VyY2UgdGhpcyBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nIGJlZm9yZVxuICAvLyBwYXNzaW5nIGl0IHRvIFJlYWN0LiBUaGUgbW9zdCByZWxpYWJsZSB3YXkgaXMgdXN1YWxseSBgU3RyaW5nKHZhbHVlKWAuXG4gIC8vXG4gIC8vIFRvIGZpbmQgd2hpY2ggdmFsdWUgaXMgdGhyb3dpbmcsIGNoZWNrIHRoZSBicm93c2VyIG9yIGRlYnVnZ2VyIGNvbnNvbGUuXG4gIC8vIEJlZm9yZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLCB0aGVyZSBzaG91bGQgYmUgYGNvbnNvbGUuZXJyb3JgIG91dHB1dFxuICAvLyB0aGF0IHNob3dzIHRoZSB0eXBlIChTeW1ib2wsIFRlbXBvcmFsLlBsYWluRGF0ZSwgZXRjLikgdGhhdCBjYXVzZWQgdGhlXG4gIC8vIHByb2JsZW0gYW5kIGhvdyB0aGF0IHR5cGUgd2FzIHVzZWQ6IGtleSwgYXRycmlidXRlLCBpbnB1dCB2YWx1ZSBwcm9wLCBldGMuXG4gIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgY29uc29sZSBvdXRwdXQgYWxzbyBzaG93cyB0aGUgY29tcG9uZW50IGFuZCBpdHNcbiAgLy8gYW5jZXN0b3IgY29tcG9uZW50cyB3aGVyZSB0aGUgZXhjZXB0aW9uIGhhcHBlbmVkLlxuICAvL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgcmV0dXJuICcnICsgdmFsdWU7XG59XG5mdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIHtcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG4gICAgICBlcnJvcignVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLCB0eXBlTmFtZSh2YWx1ZSkpO1xuXG4gICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsgLy8gdGhyb3cgKHRvIGhlbHAgY2FsbGVycyBmaW5kIHRyb3VibGVzaG9vdGluZyBjb21tZW50cylcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50ICYmIHNlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudC50eXBlKSwgY29uZmlnLnJlZik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTsgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYkMSh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gICAgdmFyIHByb3BzID0ge307XG4gICAgdmFyIGtleSA9IG51bGw7XG4gICAgdmFyIHJlZiA9IG51bGw7IC8vIEN1cnJlbnRseSwga2V5IGNhbiBiZSBzcHJlYWQgaW4gYXMgYSBwcm9wLiBUaGlzIGNhdXNlcyBhIHBvdGVudGlhbFxuICAgIC8vIGlzc3VlIGlmIGtleSBpcyBhbHNvIGV4cGxpY2l0bHkgZGVjbGFyZWQgKGllLiA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPlxuICAgIC8vIG9yIDxkaXYga2V5PVwiSGlcIiB7Li4ucHJvcHN9IC8+ICkuIFdlIHdhbnQgdG8gZGVwcmVjYXRlIGtleSBzcHJlYWQsXG4gICAgLy8gYnV0IGFzIGFuIGludGVybWVkaWFyeSBzdGVwLCB3ZSB3aWxsIHVzZSBqc3hERVYgZm9yIGV2ZXJ5dGhpbmcgZXhjZXB0XG4gICAgLy8gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz4sIGJlY2F1c2Ugd2UgYXJlbid0IGN1cnJlbnRseSBhYmxlIHRvIHRlbGwgaWZcbiAgICAvLyBrZXkgaXMgZXhwbGljaXRseSBkZWNsYXJlZCB0byBiZSB1bmRlZmluZWQgb3Igbm90LlxuXG4gICAgaWYgKG1heWJlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihtYXliZUtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgbWF5YmVLZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZik7XG4gICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcblxuXG4gICAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcblxuICAgICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LCBwcm9wcyk7XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNsaWVudC5yZWZlcmVuY2UnKTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcblxue1xuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xufVxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBAZmluYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcbiAge1xuICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cblxuXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB7XG4gICAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICAgIGlmICghaW5mbykge1xuICAgICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XG5cbiAgICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gIH1cbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0JyB8fCAhbm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChub2RlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSA7IGVsc2UgaWYgKGlzQXJyYXkobm9kZSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcblxuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByb3BUeXBlcztcblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BUeXBlcykge1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblxuICAgICAgdmFyIF9uYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuXG4gICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nICYmICF0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcblxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIGlzU3RhdGljQ2hpbGRyZW4sIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTsgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gICAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKTtcblxuICAgICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBqc3hERVYkMSh0eXBlLCBwcm9wcywga2V5LCBzb3VyY2UsIHNlbGYpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cblxuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH0gLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAgIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gICAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuXG5cbiAgICBpZiAodmFsaWRUeXBlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCAna2V5JykpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wcykuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiBrICE9PSAna2V5JztcbiAgICAgIH0pO1xuICAgICAgdmFyIGJlZm9yZUV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAne2tleTogc29tZUtleSwgJyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne2tleTogc29tZUtleX0nO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0pIHtcbiAgICAgICAgdmFyIGFmdGVyRXhhbXBsZSA9IGtleXMubGVuZ3RoID4gMCA/ICd7JyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne30nO1xuXG4gICAgICAgIGVycm9yKCdBIHByb3BzIG9iamVjdCBjb250YWluaW5nIGEgXCJrZXlcIiBwcm9wIGlzIGJlaW5nIHNwcmVhZCBpbnRvIEpTWDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyB7Li4ucHJvcHN9IC8+XFxuJyArICdSZWFjdCBrZXlzIG11c3QgYmUgcGFzc2VkIGRpcmVjdGx5IHRvIEpTWCB3aXRob3V0IHVzaW5nIHNwcmVhZDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyBrZXk9e3NvbWVLZXl9IHsuLi5wcm9wc30gLz4nLCBiZWZvcmVFeGFtcGxlLCBjb21wb25lbnROYW1lLCBhZnRlckV4YW1wbGUsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59IC8vIFRoZXNlIHR3byBmdW5jdGlvbnMgZXhpc3QgdG8gc3RpbGwgZ2V0IGNoaWxkIHdhcm5pbmdzIGluIGRldlxuXG52YXIganN4REVWID0ganN4V2l0aFZhbGlkYXRpb24gO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4REVWID0ganN4REVWO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-client)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9qc3gtZGV2LXJ1bnRpbWUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRixFQUFFLHVMQUFzRTtBQUN4RSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcz9lZjU2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/navigation.js":
/*!*****************************************!*\
  !*** ./node_modules/next/navigation.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = __webpack_require__(/*! ./dist/client/components/navigation */ \"(app-client)/./node_modules/next/dist/client/components/navigation.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvbmF2aWdhdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBQSx3SkFBK0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvbmF2aWdhdGlvbi5qcz84ZGJjIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXN0L2NsaWVudC9jb21wb25lbnRzL25hdmlnYXRpb24nKVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/navigation.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/react-slideshow-image/dist/react-slideshow-image.esm.js":
/*!******************************************************************************!*\
  !*** ./node_modules/react-slideshow-image/dist/react-slideshow-image.esm.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Fade: function() { return /* binding */ Fade; },\n/* harmony export */   Slide: function() { return /* binding */ Slide; },\n/* harmony export */   Zoom: function() { return /* binding */ Zoom; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-client)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var resize_observer_polyfill__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! resize-observer-polyfill */ \"(app-client)/./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js\");\n/* harmony import */ var _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tweenjs/tween.js */ \"(app-client)/./node_modules/@tweenjs/tween.js/dist/tween.esm.js\");\n\n\n\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\nvar getStartingIndex = function getStartingIndex(children, defaultIndex) {\n  if (defaultIndex && defaultIndex < react__WEBPACK_IMPORTED_MODULE_0___default().Children.count(children)) {\n    return defaultIndex;\n  }\n\n  return 0;\n};\nvar getResponsiveSettings = function getResponsiveSettings(wrapperWidth, responsive) {\n  if (typeof window !== 'undefined' && Array.isArray(responsive)) {\n    return responsive.find(function (each) {\n      return each.breakpoint <= wrapperWidth;\n    });\n  }\n\n  return;\n};\nvar EASING_METHODS = {\n  linear: _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_2__.Easing.Linear.None,\n  ease: _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_2__.Easing.Quadratic.InOut,\n  'ease-in': _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_2__.Easing.Quadratic.In,\n  'ease-out': _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_2__.Easing.Quadratic.Out,\n  cubic: _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_2__.Easing.Cubic.InOut,\n  'cubic-in': _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_2__.Easing.Cubic.In,\n  'cubic-out': _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_2__.Easing.Cubic.Out\n};\nvar getEasing = function getEasing(easeMethod) {\n  if (easeMethod) {\n    return EASING_METHODS[easeMethod];\n  }\n\n  return EASING_METHODS.linear;\n};\nvar showPreviousArrow = function showPreviousArrow(_ref, currentIndex, moveSlides) {\n  var prevArrow = _ref.prevArrow,\n      infinite = _ref.infinite;\n  var isDisabled = currentIndex <= 0 && !infinite;\n  var props = {\n    'data-type': 'prev',\n    'aria-label': 'Previous Slide',\n    disabled: isDisabled,\n    onClick: moveSlides\n  };\n\n  if (prevArrow) {\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().cloneElement(prevArrow, _extends({\n      className: (prevArrow.props.className || '') + \" nav \" + (isDisabled ? 'disabled' : '')\n    }, props));\n  }\n\n  var className = \"nav default-nav \" + (isDisabled ? 'disabled' : '');\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"button\", Object.assign({\n    type: \"button\",\n    className: className\n  }, props), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"svg\", {\n    width: \"24\",\n    height: \"24\",\n    viewBox: \"0 0 24 24\"\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"path\", {\n    d: \"M16.67 0l2.83 2.829-9.339 9.175 9.339 9.167-2.83 2.829-12.17-11.996z\"\n  })));\n};\nvar showNextArrow = function showNextArrow(properties, currentIndex, moveSlides) {\n  var nextArrow = properties.nextArrow,\n      infinite = properties.infinite,\n      children = properties.children;\n  var slidesToScroll = 1;\n\n  if ('slidesToScroll' in properties) {\n    slidesToScroll = properties.slidesToScroll || 1;\n  }\n\n  var isDisabled = currentIndex >= react__WEBPACK_IMPORTED_MODULE_0___default().Children.count(children) - slidesToScroll && !infinite;\n  var props = {\n    'data-type': 'next',\n    'aria-label': 'Next Slide',\n    disabled: isDisabled,\n    onClick: moveSlides\n  };\n\n  if (nextArrow) {\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().cloneElement(nextArrow, _extends({\n      className: (nextArrow.props.className || '') + \" nav \" + (isDisabled ? 'disabled' : '')\n    }, props));\n  }\n\n  var className = \"nav default-nav \" + (isDisabled ? 'disabled' : '');\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"button\", Object.assign({\n    type: \"button\",\n    className: className\n  }, props), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"svg\", {\n    width: \"24\",\n    height: \"24\",\n    viewBox: \"0 0 24 24\"\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"path\", {\n    d: \"M5 3l3.057-3 11.943 12-11.943 12-3.057-3 9-9z\"\n  })));\n};\n\nvar showDefaultIndicator = function showDefaultIndicator(isCurrentPageActive, key, indicatorProps) {\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"li\", {\n    key: key\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"button\", Object.assign({\n    type: \"button\",\n    className: \"each-slideshow-indicator \" + (isCurrentPageActive ? 'active' : '')\n  }, indicatorProps)));\n};\n\nvar showCustomIndicator = function showCustomIndicator(isCurrentPageActive, key, indicatorProps, eachIndicator) {\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().cloneElement(eachIndicator, _extends({\n    className: eachIndicator.props.className + \" \" + (isCurrentPageActive ? 'active' : ''),\n    key: key\n  }, indicatorProps));\n};\n\nvar showIndicators = function showIndicators(props, currentIndex, navigate, responsiveSettings) {\n  var children = props.children,\n      indicators = props.indicators;\n  var slidesToScroll = 1;\n\n  if (responsiveSettings) {\n    slidesToScroll = responsiveSettings == null ? void 0 : responsiveSettings.settings.slidesToScroll;\n  } else if ('slidesToScroll' in props) {\n    slidesToScroll = props.slidesToScroll || 1;\n  }\n\n  var pages = Math.ceil(react__WEBPACK_IMPORTED_MODULE_0___default().Children.count(children) / slidesToScroll);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"ul\", {\n    className: \"indicators\"\n  }, Array.from({\n    length: pages\n  }, function (_, key) {\n    var indicatorProps = {\n      'data-key': key,\n      'aria-label': \"Go to slide \" + (key + 1),\n      onClick: navigate\n    };\n    var isCurrentPageActive = Math.floor((currentIndex + slidesToScroll - 1) / slidesToScroll) === key;\n\n    if (typeof indicators === 'function') {\n      return showCustomIndicator(isCurrentPageActive, key, indicatorProps, indicators(key));\n    }\n\n    return showDefaultIndicator(isCurrentPageActive, key, indicatorProps);\n  }));\n};\n\nvar defaultProps = {\n  duration: 5000,\n  transitionDuration: 1000,\n  defaultIndex: 0,\n  infinite: true,\n  autoplay: true,\n  indicators: false,\n  arrows: true,\n  pauseOnHover: true,\n  easing: 'linear',\n  canSwipe: true,\n  cssClass: '',\n  responsive: []\n};\n\nvar FadeZoom = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().forwardRef(function (props, ref) {\n  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(getStartingIndex(props.children, props.defaultIndex)),\n      index = _useState[0],\n      setIndex = _useState[1];\n\n  var wrapperRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  var innerWrapperRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  var tweenGroup = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(new _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_2__.Group());\n  var timeout = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n  var resizeObserver = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n  var childrenCount = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function () {\n    return react__WEBPACK_IMPORTED_MODULE_0___default().Children.count(props.children);\n  }, [props.children]);\n  var applyStyle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function () {\n    if (innerWrapperRef.current && wrapperRef.current) {\n      var wrapperWidth = wrapperRef.current.clientWidth;\n      var fullwidth = wrapperWidth * childrenCount;\n      innerWrapperRef.current.style.width = fullwidth + \"px\";\n\n      for (var _index = 0; _index < innerWrapperRef.current.children.length; _index++) {\n        var eachDiv = innerWrapperRef.current.children[_index];\n\n        if (eachDiv) {\n          eachDiv.style.width = wrapperWidth + \"px\";\n          eachDiv.style.left = _index * -wrapperWidth + \"px\";\n          eachDiv.style.display = \"block\";\n        }\n      }\n    }\n  }, [wrapperRef, innerWrapperRef, childrenCount]);\n  var initResizeObserver = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function () {\n    if (wrapperRef.current) {\n      resizeObserver.current = new resize_observer_polyfill__WEBPACK_IMPORTED_MODULE_1__[\"default\"](function (entries) {\n        if (!entries) return;\n        applyStyle();\n      });\n      resizeObserver.current.observe(wrapperRef.current);\n    }\n  }, [wrapperRef, applyStyle]);\n  var play = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function () {\n    var autoplay = props.autoplay,\n        children = props.children,\n        duration = props.duration,\n        infinite = props.infinite;\n\n    if (autoplay && react__WEBPACK_IMPORTED_MODULE_0___default().Children.count(children) > 1 && (infinite || index < react__WEBPACK_IMPORTED_MODULE_0___default().Children.count(children) - 1)) {\n      timeout.current = setTimeout(moveNext, duration);\n    } // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, [props, index]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n    initResizeObserver();\n    return function () {\n      tweenGroup.current.removeAll();\n      clearTimeout(timeout.current);\n      removeResizeObserver();\n    };\n  }, [initResizeObserver, tweenGroup]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n    clearTimeout(timeout.current);\n    play();\n  }, [index, props.autoplay, play]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n    applyStyle();\n  }, [childrenCount, applyStyle]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, function () {\n    return {\n      goNext: function goNext() {\n        moveNext();\n      },\n      goBack: function goBack() {\n        moveBack();\n      },\n      goTo: function goTo(index, options) {\n        if (options != null && options.skipTransition) {\n          setIndex(index);\n        } else {\n          moveTo(index);\n        }\n      }\n    };\n  });\n\n  var removeResizeObserver = function removeResizeObserver() {\n    if (resizeObserver.current && wrapperRef.current) {\n      resizeObserver.current.unobserve(wrapperRef.current);\n    }\n  };\n\n  var pauseSlides = function pauseSlides() {\n    if (props.pauseOnHover) {\n      clearTimeout(timeout.current);\n    }\n  };\n\n  var startSlides = function startSlides() {\n    var pauseOnHover = props.pauseOnHover,\n        autoplay = props.autoplay,\n        duration = props.duration;\n\n    if (pauseOnHover && autoplay) {\n      timeout.current = setTimeout(function () {\n        return moveNext();\n      }, duration);\n    }\n  };\n\n  var moveNext = function moveNext() {\n    var children = props.children,\n        infinite = props.infinite;\n\n    if (!infinite && index === react__WEBPACK_IMPORTED_MODULE_0___default().Children.count(children) - 1) {\n      return;\n    }\n\n    transitionSlide((index + 1) % react__WEBPACK_IMPORTED_MODULE_0___default().Children.count(children));\n  };\n\n  var moveBack = function moveBack() {\n    var children = props.children,\n        infinite = props.infinite;\n\n    if (!infinite && index === 0) {\n      return;\n    }\n\n    transitionSlide(index === 0 ? react__WEBPACK_IMPORTED_MODULE_0___default().Children.count(children) - 1 : index - 1);\n  };\n\n  var preTransition = function preTransition(event) {\n    var currentTarget = event.currentTarget;\n\n    if (currentTarget.dataset.type === 'prev') {\n      moveBack();\n    } else {\n      moveNext();\n    }\n  };\n\n  var animate = function animate() {\n    requestAnimationFrame(animate);\n    tweenGroup.current.update();\n  };\n\n  var transitionSlide = function transitionSlide(newIndex) {\n    var existingTweens = tweenGroup.current.getAll();\n\n    if (!existingTweens.length) {\n      var _innerWrapperRef$curr;\n\n      if (!((_innerWrapperRef$curr = innerWrapperRef.current) != null && _innerWrapperRef$curr.children[newIndex])) {\n        newIndex = 0;\n      }\n\n      clearTimeout(timeout.current);\n      var value = {\n        opacity: 0,\n        scale: 1\n      };\n      animate();\n      var tween = new _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_2__.Tween(value, tweenGroup.current).to({\n        opacity: 1,\n        scale: props.scale\n      }, props.transitionDuration).onUpdate(function (value) {\n        if (!innerWrapperRef.current) {\n          return;\n        }\n\n        innerWrapperRef.current.children[newIndex].style.opacity = value.opacity;\n        innerWrapperRef.current.children[index].style.opacity = 1 - value.opacity;\n        innerWrapperRef.current.children[index].style.transform = \"scale(\" + value.scale + \")\";\n      });\n      tween.easing(getEasing(props.easing));\n      tween.onStart(function () {\n        if (typeof props.onStartChange === 'function') {\n          props.onStartChange(index, newIndex);\n        }\n      });\n      tween.onComplete(function () {\n        if (innerWrapperRef.current) {\n          setIndex(newIndex);\n          innerWrapperRef.current.children[index].style.transform = \"scale(1)\";\n        }\n\n        if (typeof props.onChange === 'function') {\n          props.onChange(index, newIndex);\n        }\n      });\n      tween.start();\n    }\n  };\n\n  var moveTo = function moveTo(gotoIndex) {\n    if (gotoIndex !== index) {\n      transitionSlide(gotoIndex);\n    }\n  };\n\n  var navigate = function navigate(event) {\n    var currentTarget = event.currentTarget;\n\n    if (!currentTarget.dataset.key) {\n      return;\n    }\n\n    if (parseInt(currentTarget.dataset.key) !== index) {\n      moveTo(parseInt(currentTarget.dataset.key));\n    }\n  };\n\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    dir: \"ltr\",\n    \"aria-roledescription\": \"carousel\"\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"react-slideshow-container \" + (props.cssClass || ''),\n    onMouseEnter: pauseSlides,\n    onMouseOver: pauseSlides,\n    onMouseLeave: startSlides\n  }, props.arrows && showPreviousArrow(props, index, preTransition), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"react-slideshow-fadezoom-wrapper \" + props.cssClass,\n    ref: wrapperRef\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"react-slideshow-fadezoom-images-wrap\",\n    ref: innerWrapperRef\n  }, (react__WEBPACK_IMPORTED_MODULE_0___default().Children.map(props.children, function (thisArg) {\n    return thisArg;\n  }) || []).map(function (each, key) {\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n      style: {\n        opacity: key === index ? '1' : '0',\n        zIndex: key === index ? '1' : '0'\n      },\n      \"data-index\": key,\n      key: key,\n      \"aria-roledescription\": \"slide\",\n      \"aria-hidden\": key === index ? 'false' : 'true'\n    }, each);\n  }))), props.arrows && showNextArrow(props, index, preTransition)), props.indicators && showIndicators(props, index, navigate));\n});\nFadeZoom.defaultProps = defaultProps;\n\nvar Fade = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().forwardRef(function (props, ref) {\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(FadeZoom, Object.assign({}, props, {\n    scale: 1,\n    ref: ref\n  }));\n});\nFade.defaultProps = defaultProps;\n\nvar Zoom = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().forwardRef(function (props, ref) {\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(FadeZoom, Object.assign({}, props, {\n    ref: ref\n  }));\n});\nZoom.defaultProps = defaultProps;\n\nvar Slide = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().forwardRef(function (props, ref) {\n  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(getStartingIndex(props.children, props.defaultIndex)),\n      index = _useState[0],\n      setIndex = _useState[1];\n\n  var _useState2 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0),\n      wrapperWidth = _useState2[0],\n      setWrapperWidth = _useState2[1];\n\n  var wrapperRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  var innerWrapperRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  var tweenGroup = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(new _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_2__.Group());\n  var responsiveSettings = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function () {\n    return getResponsiveSettings(wrapperWidth, props.responsive);\n  }, [wrapperWidth, props.responsive]);\n  var slidesToScroll = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function () {\n    if (responsiveSettings) {\n      return responsiveSettings.settings.slidesToScroll;\n    }\n\n    return props.slidesToScroll || 1;\n  }, [responsiveSettings, props.slidesToScroll]);\n  var slidesToShow = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function () {\n    if (responsiveSettings) {\n      return responsiveSettings.settings.slidesToShow;\n    }\n\n    return props.slidesToShow || 1;\n  }, [responsiveSettings, props.slidesToShow]);\n  var childrenCount = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function () {\n    return react__WEBPACK_IMPORTED_MODULE_0___default().Children.count(props.children);\n  }, [props.children]);\n  var eachChildWidth = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function () {\n    return wrapperWidth / slidesToShow;\n  }, [wrapperWidth, slidesToShow]);\n  var timeout = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n  var resizeObserver = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n  var startingClientX;\n  var dragging = false;\n  var distanceSwiped = 0;\n  var applyStyle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function () {\n    if (innerWrapperRef.current) {\n      var fullwidth = wrapperWidth * innerWrapperRef.current.children.length;\n      innerWrapperRef.current.style.width = fullwidth + \"px\";\n\n      for (var _index = 0; _index < innerWrapperRef.current.children.length; _index++) {\n        var eachDiv = innerWrapperRef.current.children[_index];\n\n        if (eachDiv) {\n          eachDiv.style.width = eachChildWidth + \"px\";\n          eachDiv.style.display = \"block\";\n        }\n      }\n    }\n  }, [wrapperWidth, eachChildWidth]);\n  var initResizeObserver = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function () {\n    if (wrapperRef.current) {\n      resizeObserver.current = new resize_observer_polyfill__WEBPACK_IMPORTED_MODULE_1__[\"default\"](function (entries) {\n        if (!entries) return;\n        setWidth();\n      });\n      resizeObserver.current.observe(wrapperRef.current);\n    }\n  }, [wrapperRef]);\n  var play = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function () {\n    var autoplay = props.autoplay,\n        infinite = props.infinite,\n        duration = props.duration;\n\n    if (autoplay && (infinite || index < childrenCount - 1)) {\n      timeout.current = setTimeout(moveNext, duration);\n    } // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, [props, childrenCount, index]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n    applyStyle();\n  }, [wrapperWidth, applyStyle]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n    initResizeObserver();\n    return function () {\n      tweenGroup.current.removeAll();\n      clearTimeout(timeout.current);\n      removeResizeObserver();\n    };\n  }, [wrapperRef, initResizeObserver, tweenGroup]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n    clearTimeout(timeout.current);\n    play();\n  }, [index, wrapperWidth, props.autoplay, play]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, function () {\n    return {\n      goNext: function goNext() {\n        moveNext();\n      },\n      goBack: function goBack() {\n        moveBack();\n      },\n      goTo: function goTo(index, options) {\n        if (options != null && options.skipTransition) {\n          setIndex(index);\n        } else {\n          moveTo(index);\n        }\n      }\n    };\n  });\n\n  var removeResizeObserver = function removeResizeObserver() {\n    if (resizeObserver && wrapperRef.current) {\n      resizeObserver.current.unobserve(wrapperRef.current);\n    }\n  };\n\n  var pauseSlides = function pauseSlides() {\n    if (props.pauseOnHover) {\n      clearTimeout(timeout.current);\n    }\n  };\n\n  var swipe = function swipe(event) {\n    if (props.canSwipe && dragging) {\n      var clientX;\n\n      if (window.TouchEvent && event.nativeEvent instanceof TouchEvent) {\n        clientX = event.nativeEvent.touches[0].pageX;\n      } else if (event.nativeEvent instanceof MouseEvent) {\n        clientX = event.nativeEvent.clientX;\n      }\n\n      if (clientX && startingClientX) {\n        var translateValue = eachChildWidth * (index + getOffset());\n        var distance = clientX - startingClientX;\n\n        if (!props.infinite && index === childrenCount - slidesToScroll && distance < 0) {\n          // if it is the last and infinite is false and you're swiping left\n          // then nothing happens\n          return;\n        }\n\n        if (!props.infinite && index === 0 && distance > 0) {\n          // if it is the first and infinite is false and you're swiping right\n          // then nothing happens\n          return;\n        }\n\n        distanceSwiped = distance;\n        translateValue -= distanceSwiped;\n        innerWrapperRef.current.style.transform = \"translate(-\" + translateValue + \"px)\";\n      }\n    }\n  };\n\n  var moveNext = function moveNext() {\n    if (!props.infinite && index === childrenCount - slidesToScroll) {\n      return;\n    }\n\n    var nextIndex = calculateIndex(index + slidesToScroll);\n    transitionSlide(nextIndex);\n  };\n\n  var moveBack = function moveBack() {\n    if (!props.infinite && index === 0) {\n      return;\n    }\n\n    var previousIndex = index - slidesToScroll;\n\n    if (previousIndex % slidesToScroll) {\n      previousIndex = Math.ceil(previousIndex / slidesToScroll) * slidesToScroll;\n    }\n\n    transitionSlide(previousIndex);\n  };\n\n  var goToSlide = function goToSlide(_ref) {\n    var currentTarget = _ref.currentTarget;\n\n    if (!currentTarget.dataset.key) {\n      return;\n    }\n\n    var datasetKey = parseInt(currentTarget.dataset.key);\n    moveTo(datasetKey * slidesToScroll);\n  };\n\n  var moveTo = function moveTo(index) {\n    transitionSlide(calculateIndex(index));\n  };\n\n  var calculateIndex = function calculateIndex(nextIndex) {\n    if (nextIndex < childrenCount && nextIndex + slidesToScroll > childrenCount) {\n      if ((childrenCount - slidesToScroll) % slidesToScroll) {\n        return childrenCount - slidesToScroll;\n      }\n\n      return nextIndex;\n    }\n\n    return nextIndex;\n  };\n\n  var startSlides = function startSlides() {\n    if (dragging) {\n      endSwipe();\n    } else if (props.pauseOnHover && props.autoplay) {\n      timeout.current = setTimeout(moveNext, props.duration);\n    }\n  };\n\n  var moveSlides = function moveSlides(_ref2) {\n    var dataset = _ref2.currentTarget.dataset;\n\n    if (dataset.type === 'next') {\n      moveNext();\n    } else {\n      moveBack();\n    }\n  };\n\n  var renderPreceedingSlides = function renderPreceedingSlides() {\n    return react__WEBPACK_IMPORTED_MODULE_0___default().Children.toArray(props.children).slice(-slidesToShow).map(function (each, index) {\n      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n        \"data-index\": index - slidesToShow,\n        \"aria-roledescription\": \"slide\",\n        \"aria-hidden\": \"true\",\n        key: index - slidesToShow\n      }, each);\n    });\n  };\n\n  var renderTrailingSlides = function renderTrailingSlides() {\n    if (!props.infinite && slidesToShow === slidesToScroll) {\n      return;\n    }\n\n    return react__WEBPACK_IMPORTED_MODULE_0___default().Children.toArray(props.children).slice(0, slidesToShow).map(function (each, index) {\n      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n        \"data-index\": childrenCount + index,\n        \"aria-roledescription\": \"slide\",\n        \"aria-hidden\": \"true\",\n        key: childrenCount + index\n      }, each);\n    });\n  };\n\n  var setWidth = function setWidth() {\n    if (wrapperRef.current) {\n      setWrapperWidth(wrapperRef.current.clientWidth);\n    }\n  };\n\n  var startSwipe = function startSwipe(event) {\n    if (props.canSwipe) {\n      if (window.TouchEvent && event.nativeEvent instanceof TouchEvent) {\n        startingClientX = event.nativeEvent.touches[0].pageX;\n      } else if (event.nativeEvent instanceof MouseEvent) {\n        startingClientX = event.nativeEvent.clientX;\n      }\n\n      clearTimeout(timeout.current);\n      dragging = true;\n    }\n  };\n\n  var endSwipe = function endSwipe() {\n    if (props.canSwipe) {\n      dragging = false;\n\n      if (Math.abs(distanceSwiped) / wrapperWidth > 0.2) {\n        if (distanceSwiped < 0) {\n          moveNext();\n        } else {\n          moveBack();\n        }\n      } else {\n        if (Math.abs(distanceSwiped) > 0) {\n          transitionSlide(index, 300);\n        }\n      }\n    }\n  };\n\n  var animate = function animate() {\n    requestAnimationFrame(animate);\n    tweenGroup.current.update();\n  };\n\n  var transitionSlide = function transitionSlide(toIndex, animationDuration) {\n    var transitionDuration = animationDuration || props.transitionDuration;\n    var currentIndex = index;\n    var existingTweens = tweenGroup.current.getAll();\n\n    if (!wrapperRef.current) {\n      return;\n    }\n\n    var childWidth = wrapperRef.current.clientWidth / slidesToShow;\n\n    if (!existingTweens.length) {\n      clearTimeout(timeout.current);\n      var value = {\n        margin: -childWidth * (currentIndex + getOffset()) + distanceSwiped\n      };\n      var tween = new _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_2__.Tween(value, tweenGroup.current).to({\n        margin: -childWidth * (toIndex + getOffset())\n      }, transitionDuration).onUpdate(function (value) {\n        if (innerWrapperRef.current) {\n          innerWrapperRef.current.style.transform = \"translate(\" + value.margin + \"px)\";\n        }\n      });\n      tween.easing(getEasing(props.easing));\n      animate();\n      var newIndex = toIndex;\n\n      if (newIndex < 0) {\n        newIndex = childrenCount - slidesToScroll;\n      } else if (newIndex >= childrenCount) {\n        newIndex = 0;\n      }\n\n      tween.onStart(function () {\n        if (typeof props.onStartChange === 'function') {\n          props.onStartChange(index, newIndex);\n        }\n      });\n      tween.onComplete(function () {\n        distanceSwiped = 0;\n\n        if (typeof props.onChange === 'function') {\n          props.onChange(index, newIndex);\n        }\n\n        setIndex(newIndex);\n      });\n      tween.start();\n    }\n  };\n\n  var isSlideActive = function isSlideActive(key) {\n    return key < index + slidesToShow && key >= index;\n  };\n\n  var getOffset = function getOffset() {\n    if (!props.infinite) {\n      return 0;\n    }\n\n    return slidesToShow;\n  };\n\n  var style = {\n    transform: \"translate(-\" + (index + getOffset()) * eachChildWidth + \"px)\"\n  };\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    dir: \"ltr\",\n    \"aria-roledescription\": \"carousel\"\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"react-slideshow-container\",\n    onMouseEnter: pauseSlides,\n    onMouseOver: pauseSlides,\n    onMouseLeave: startSlides,\n    onMouseDown: startSwipe,\n    onMouseUp: endSwipe,\n    onMouseMove: swipe,\n    onTouchStart: startSwipe,\n    onTouchEnd: endSwipe,\n    onTouchCancel: endSwipe,\n    onTouchMove: swipe\n  }, props.arrows && showPreviousArrow(props, index, moveSlides), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"react-slideshow-wrapper slide \" + (props.cssClass || ''),\n    ref: wrapperRef\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"images-wrap\",\n    style: style,\n    ref: innerWrapperRef\n  }, props.infinite && renderPreceedingSlides(), (react__WEBPACK_IMPORTED_MODULE_0___default().Children.map(props.children, function (thisArg) {\n    return thisArg;\n  }) || []).map(function (each, key) {\n    var isThisSlideActive = isSlideActive(key);\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n      \"data-index\": key,\n      key: key,\n      className: isThisSlideActive ? 'active' : '',\n      \"aria-roledescription\": \"slide\",\n      \"aria-hidden\": isThisSlideActive ? 'false' : 'true'\n    }, each);\n  }), renderTrailingSlides())), props.arrows && showNextArrow(props, index, moveSlides)), props.indicators && showIndicators(props, index, goToSlide, responsiveSettings));\n});\nSlide.defaultProps = defaultProps;\n\n\n//# sourceMappingURL=react-slideshow-image.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXNsaWRlc2hvdy1pbWFnZS9kaXN0L3JlYWN0LXNsaWRlc2hvdy1pbWFnZS5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFzRztBQUNoRDtBQUNHOztBQUV6RDtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUMscURBQWM7QUFDbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVSxxREFBTTtBQUNoQixRQUFRLHFEQUFNO0FBQ2QsYUFBYSxxREFBTTtBQUNuQixjQUFjLHFEQUFNO0FBQ3BCLFNBQVMscURBQU07QUFDZixjQUFjLHFEQUFNO0FBQ3BCLGVBQWUscURBQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IseURBQWtCO0FBQzFDO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0Esc0JBQXNCLDBEQUFtQjtBQUN6QztBQUNBO0FBQ0EsR0FBRyx1QkFBdUIsMERBQW1CO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLEdBQUcsZUFBZSwwREFBbUI7QUFDckM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUMscURBQWM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLHlEQUFrQjtBQUMxQztBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLHNCQUFzQiwwREFBbUI7QUFDekM7QUFDQTtBQUNBLEdBQUcsdUJBQXVCLDBEQUFtQjtBQUM3QztBQUNBO0FBQ0E7QUFDQSxHQUFHLGVBQWUsMERBQW1CO0FBQ3JDO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0Esc0JBQXNCLDBEQUFtQjtBQUN6QztBQUNBLEdBQUcsZUFBZSwwREFBbUI7QUFDckM7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLHNCQUFzQix5REFBa0I7QUFDeEM7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUEsd0JBQXdCLHFEQUFjO0FBQ3RDLHNCQUFzQiwwREFBbUI7QUFDekM7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0Qix1REFBZ0I7QUFDNUMsa0JBQWtCLCtDQUFRO0FBQzFCO0FBQ0E7O0FBRUEsbUJBQW1CLDZDQUFNO0FBQ3pCLHdCQUF3Qiw2Q0FBTTtBQUM5QixtQkFBbUIsNkNBQU0sS0FBSyxvREFBSztBQUNuQyxnQkFBZ0IsNkNBQU07QUFDdEIsdUJBQXVCLDZDQUFNO0FBQzdCLHNCQUFzQiw4Q0FBTztBQUM3QixXQUFXLHFEQUFjO0FBQ3pCLEdBQUc7QUFDSCxtQkFBbUIsa0RBQVc7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLGtEQUFrRDtBQUM3RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCwyQkFBMkIsa0RBQVc7QUFDdEM7QUFDQSxtQ0FBbUMsZ0VBQWM7QUFDakQ7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNILGFBQWEsa0RBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLHFEQUFjLDZDQUE2QyxxREFBYztBQUM3RjtBQUNBLE1BQU07O0FBRU4sR0FBRztBQUNILEVBQUUsZ0RBQVM7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSxnREFBUztBQUNYO0FBQ0EsR0FBRztBQUNILEVBQUUsMERBQW1CO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0IscURBQWM7QUFDN0M7QUFDQTs7QUFFQSxrQ0FBa0MscURBQWM7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0MscURBQWM7QUFDaEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixvREFBSztBQUMzQjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsMERBQW1CO0FBQ3pDO0FBQ0E7QUFDQSxHQUFHLGVBQWUsMERBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRywrRUFBK0UsMERBQW1CO0FBQ3JHO0FBQ0E7QUFDQSxHQUFHLGVBQWUsMERBQW1CO0FBQ3JDO0FBQ0E7QUFDQSxHQUFHLEdBQUcscURBQWM7QUFDcEI7QUFDQSxHQUFHO0FBQ0gsd0JBQXdCLDBEQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7QUFDRDs7QUFFQSx3QkFBd0IsdURBQWdCO0FBQ3hDLHNCQUFzQiwwREFBbUIsMkJBQTJCO0FBQ3BFO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEOztBQUVBLHdCQUF3Qix1REFBZ0I7QUFDeEMsc0JBQXNCLDBEQUFtQiwyQkFBMkI7QUFDcEU7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEOztBQUVBLHlCQUF5Qix1REFBZ0I7QUFDekMsa0JBQWtCLCtDQUFRO0FBQzFCO0FBQ0E7O0FBRUEsbUJBQW1CLCtDQUFRO0FBQzNCO0FBQ0E7O0FBRUEsbUJBQW1CLDZDQUFNO0FBQ3pCLHdCQUF3Qiw2Q0FBTTtBQUM5QixtQkFBbUIsNkNBQU0sS0FBSyxvREFBSztBQUNuQywyQkFBMkIsOENBQU87QUFDbEM7QUFDQSxHQUFHO0FBQ0gsdUJBQXVCLDhDQUFPO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSCxxQkFBcUIsOENBQU87QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNILHNCQUFzQiw4Q0FBTztBQUM3QixXQUFXLHFEQUFjO0FBQ3pCLEdBQUc7QUFDSCx1QkFBdUIsOENBQU87QUFDOUI7QUFDQSxHQUFHO0FBQ0gsZ0JBQWdCLDZDQUFNO0FBQ3RCLHVCQUF1Qiw2Q0FBTTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0RBQVc7QUFDOUI7QUFDQTtBQUNBOztBQUVBLDJCQUEyQixrREFBa0Q7QUFDN0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILDJCQUEyQixrREFBVztBQUN0QztBQUNBLG1DQUFtQyxnRUFBYztBQUNqRDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsYUFBYSxrREFBVztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07O0FBRU4sR0FBRztBQUNILEVBQUUsZ0RBQVM7QUFDWDtBQUNBLEdBQUc7QUFDSCxFQUFFLGdEQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVM7QUFDWDtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsMERBQW1CO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxxREFBYztBQUN6QiwwQkFBMEIsMERBQW1CO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLHFEQUFjO0FBQ3pCLDBCQUEwQiwwREFBbUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG9EQUFLO0FBQzNCO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMERBQW1CO0FBQ3pDO0FBQ0E7QUFDQSxHQUFHLGVBQWUsMERBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLDRFQUE0RSwwREFBbUI7QUFDbEc7QUFDQTtBQUNBLEdBQUcsZUFBZSwwREFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0EsR0FBRywrQ0FBK0MscURBQWM7QUFDaEU7QUFDQSxHQUFHO0FBQ0g7QUFDQSx3QkFBd0IsMERBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7QUFDRDs7QUFFNkI7QUFDN0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXNsaWRlc2hvdy1pbWFnZS9kaXN0L3JlYWN0LXNsaWRlc2hvdy1pbWFnZS5lc20uanM/N2M1OCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUsIHVzZVJlZiwgdXNlTWVtbywgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlSW1wZXJhdGl2ZUhhbmRsZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBSZXNpemVPYnNlcnZlciBmcm9tICdyZXNpemUtb2JzZXJ2ZXItcG9seWZpbGwnO1xuaW1wb3J0IHsgRWFzaW5nLCBHcm91cCwgVHdlZW4gfSBmcm9tICdAdHdlZW5qcy90d2Vlbi5qcyc7XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxudmFyIGdldFN0YXJ0aW5nSW5kZXggPSBmdW5jdGlvbiBnZXRTdGFydGluZ0luZGV4KGNoaWxkcmVuLCBkZWZhdWx0SW5kZXgpIHtcbiAgaWYgKGRlZmF1bHRJbmRleCAmJiBkZWZhdWx0SW5kZXggPCBSZWFjdC5DaGlsZHJlbi5jb3VudChjaGlsZHJlbikpIHtcbiAgICByZXR1cm4gZGVmYXVsdEluZGV4O1xuICB9XG5cbiAgcmV0dXJuIDA7XG59O1xudmFyIGdldFJlc3BvbnNpdmVTZXR0aW5ncyA9IGZ1bmN0aW9uIGdldFJlc3BvbnNpdmVTZXR0aW5ncyh3cmFwcGVyV2lkdGgsIHJlc3BvbnNpdmUpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIEFycmF5LmlzQXJyYXkocmVzcG9uc2l2ZSkpIHtcbiAgICByZXR1cm4gcmVzcG9uc2l2ZS5maW5kKGZ1bmN0aW9uIChlYWNoKSB7XG4gICAgICByZXR1cm4gZWFjaC5icmVha3BvaW50IDw9IHdyYXBwZXJXaWR0aDtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybjtcbn07XG52YXIgRUFTSU5HX01FVEhPRFMgPSB7XG4gIGxpbmVhcjogRWFzaW5nLkxpbmVhci5Ob25lLFxuICBlYXNlOiBFYXNpbmcuUXVhZHJhdGljLkluT3V0LFxuICAnZWFzZS1pbic6IEVhc2luZy5RdWFkcmF0aWMuSW4sXG4gICdlYXNlLW91dCc6IEVhc2luZy5RdWFkcmF0aWMuT3V0LFxuICBjdWJpYzogRWFzaW5nLkN1YmljLkluT3V0LFxuICAnY3ViaWMtaW4nOiBFYXNpbmcuQ3ViaWMuSW4sXG4gICdjdWJpYy1vdXQnOiBFYXNpbmcuQ3ViaWMuT3V0XG59O1xudmFyIGdldEVhc2luZyA9IGZ1bmN0aW9uIGdldEVhc2luZyhlYXNlTWV0aG9kKSB7XG4gIGlmIChlYXNlTWV0aG9kKSB7XG4gICAgcmV0dXJuIEVBU0lOR19NRVRIT0RTW2Vhc2VNZXRob2RdO1xuICB9XG5cbiAgcmV0dXJuIEVBU0lOR19NRVRIT0RTLmxpbmVhcjtcbn07XG52YXIgc2hvd1ByZXZpb3VzQXJyb3cgPSBmdW5jdGlvbiBzaG93UHJldmlvdXNBcnJvdyhfcmVmLCBjdXJyZW50SW5kZXgsIG1vdmVTbGlkZXMpIHtcbiAgdmFyIHByZXZBcnJvdyA9IF9yZWYucHJldkFycm93LFxuICAgICAgaW5maW5pdGUgPSBfcmVmLmluZmluaXRlO1xuICB2YXIgaXNEaXNhYmxlZCA9IGN1cnJlbnRJbmRleCA8PSAwICYmICFpbmZpbml0ZTtcbiAgdmFyIHByb3BzID0ge1xuICAgICdkYXRhLXR5cGUnOiAncHJldicsXG4gICAgJ2FyaWEtbGFiZWwnOiAnUHJldmlvdXMgU2xpZGUnLFxuICAgIGRpc2FibGVkOiBpc0Rpc2FibGVkLFxuICAgIG9uQ2xpY2s6IG1vdmVTbGlkZXNcbiAgfTtcblxuICBpZiAocHJldkFycm93KSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jbG9uZUVsZW1lbnQocHJldkFycm93LCBfZXh0ZW5kcyh7XG4gICAgICBjbGFzc05hbWU6IChwcmV2QXJyb3cucHJvcHMuY2xhc3NOYW1lIHx8ICcnKSArIFwiIG5hdiBcIiArIChpc0Rpc2FibGVkID8gJ2Rpc2FibGVkJyA6ICcnKVxuICAgIH0sIHByb3BzKSk7XG4gIH1cblxuICB2YXIgY2xhc3NOYW1lID0gXCJuYXYgZGVmYXVsdC1uYXYgXCIgKyAoaXNEaXNhYmxlZCA/ICdkaXNhYmxlZCcgOiAnJyk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCBPYmplY3QuYXNzaWduKHtcbiAgICB0eXBlOiBcImJ1dHRvblwiLFxuICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lXG4gIH0sIHByb3BzKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwge1xuICAgIHdpZHRoOiBcIjI0XCIsXG4gICAgaGVpZ2h0OiBcIjI0XCIsXG4gICAgdmlld0JveDogXCIwIDAgMjQgMjRcIlxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgIGQ6IFwiTTE2LjY3IDBsMi44MyAyLjgyOS05LjMzOSA5LjE3NSA5LjMzOSA5LjE2Ny0yLjgzIDIuODI5LTEyLjE3LTExLjk5NnpcIlxuICB9KSkpO1xufTtcbnZhciBzaG93TmV4dEFycm93ID0gZnVuY3Rpb24gc2hvd05leHRBcnJvdyhwcm9wZXJ0aWVzLCBjdXJyZW50SW5kZXgsIG1vdmVTbGlkZXMpIHtcbiAgdmFyIG5leHRBcnJvdyA9IHByb3BlcnRpZXMubmV4dEFycm93LFxuICAgICAgaW5maW5pdGUgPSBwcm9wZXJ0aWVzLmluZmluaXRlLFxuICAgICAgY2hpbGRyZW4gPSBwcm9wZXJ0aWVzLmNoaWxkcmVuO1xuICB2YXIgc2xpZGVzVG9TY3JvbGwgPSAxO1xuXG4gIGlmICgnc2xpZGVzVG9TY3JvbGwnIGluIHByb3BlcnRpZXMpIHtcbiAgICBzbGlkZXNUb1Njcm9sbCA9IHByb3BlcnRpZXMuc2xpZGVzVG9TY3JvbGwgfHwgMTtcbiAgfVxuXG4gIHZhciBpc0Rpc2FibGVkID0gY3VycmVudEluZGV4ID49IFJlYWN0LkNoaWxkcmVuLmNvdW50KGNoaWxkcmVuKSAtIHNsaWRlc1RvU2Nyb2xsICYmICFpbmZpbml0ZTtcbiAgdmFyIHByb3BzID0ge1xuICAgICdkYXRhLXR5cGUnOiAnbmV4dCcsXG4gICAgJ2FyaWEtbGFiZWwnOiAnTmV4dCBTbGlkZScsXG4gICAgZGlzYWJsZWQ6IGlzRGlzYWJsZWQsXG4gICAgb25DbGljazogbW92ZVNsaWRlc1xuICB9O1xuXG4gIGlmIChuZXh0QXJyb3cpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNsb25lRWxlbWVudChuZXh0QXJyb3csIF9leHRlbmRzKHtcbiAgICAgIGNsYXNzTmFtZTogKG5leHRBcnJvdy5wcm9wcy5jbGFzc05hbWUgfHwgJycpICsgXCIgbmF2IFwiICsgKGlzRGlzYWJsZWQgPyAnZGlzYWJsZWQnIDogJycpXG4gICAgfSwgcHJvcHMpKTtcbiAgfVxuXG4gIHZhciBjbGFzc05hbWUgPSBcIm5hdiBkZWZhdWx0LW5hdiBcIiArIChpc0Rpc2FibGVkID8gJ2Rpc2FibGVkJyA6ICcnKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIE9iamVjdC5hc3NpZ24oe1xuICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWVcbiAgfSwgcHJvcHMpLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7XG4gICAgd2lkdGg6IFwiMjRcIixcbiAgICBoZWlnaHQ6IFwiMjRcIixcbiAgICB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgZDogXCJNNSAzbDMuMDU3LTMgMTEuOTQzIDEyLTExLjk0MyAxMi0zLjA1Ny0zIDktOXpcIlxuICB9KSkpO1xufTtcblxudmFyIHNob3dEZWZhdWx0SW5kaWNhdG9yID0gZnVuY3Rpb24gc2hvd0RlZmF1bHRJbmRpY2F0b3IoaXNDdXJyZW50UGFnZUFjdGl2ZSwga2V5LCBpbmRpY2F0b3JQcm9wcykge1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJsaVwiLCB7XG4gICAga2V5OiBrZXlcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgdHlwZTogXCJidXR0b25cIixcbiAgICBjbGFzc05hbWU6IFwiZWFjaC1zbGlkZXNob3ctaW5kaWNhdG9yIFwiICsgKGlzQ3VycmVudFBhZ2VBY3RpdmUgPyAnYWN0aXZlJyA6ICcnKVxuICB9LCBpbmRpY2F0b3JQcm9wcykpKTtcbn07XG5cbnZhciBzaG93Q3VzdG9tSW5kaWNhdG9yID0gZnVuY3Rpb24gc2hvd0N1c3RvbUluZGljYXRvcihpc0N1cnJlbnRQYWdlQWN0aXZlLCBrZXksIGluZGljYXRvclByb3BzLCBlYWNoSW5kaWNhdG9yKSB7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY2xvbmVFbGVtZW50KGVhY2hJbmRpY2F0b3IsIF9leHRlbmRzKHtcbiAgICBjbGFzc05hbWU6IGVhY2hJbmRpY2F0b3IucHJvcHMuY2xhc3NOYW1lICsgXCIgXCIgKyAoaXNDdXJyZW50UGFnZUFjdGl2ZSA/ICdhY3RpdmUnIDogJycpLFxuICAgIGtleToga2V5XG4gIH0sIGluZGljYXRvclByb3BzKSk7XG59O1xuXG52YXIgc2hvd0luZGljYXRvcnMgPSBmdW5jdGlvbiBzaG93SW5kaWNhdG9ycyhwcm9wcywgY3VycmVudEluZGV4LCBuYXZpZ2F0ZSwgcmVzcG9uc2l2ZVNldHRpbmdzKSB7XG4gIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxuICAgICAgaW5kaWNhdG9ycyA9IHByb3BzLmluZGljYXRvcnM7XG4gIHZhciBzbGlkZXNUb1Njcm9sbCA9IDE7XG5cbiAgaWYgKHJlc3BvbnNpdmVTZXR0aW5ncykge1xuICAgIHNsaWRlc1RvU2Nyb2xsID0gcmVzcG9uc2l2ZVNldHRpbmdzID09IG51bGwgPyB2b2lkIDAgOiByZXNwb25zaXZlU2V0dGluZ3Muc2V0dGluZ3Muc2xpZGVzVG9TY3JvbGw7XG4gIH0gZWxzZSBpZiAoJ3NsaWRlc1RvU2Nyb2xsJyBpbiBwcm9wcykge1xuICAgIHNsaWRlc1RvU2Nyb2xsID0gcHJvcHMuc2xpZGVzVG9TY3JvbGwgfHwgMTtcbiAgfVxuXG4gIHZhciBwYWdlcyA9IE1hdGguY2VpbChSZWFjdC5DaGlsZHJlbi5jb3VudChjaGlsZHJlbikgLyBzbGlkZXNUb1Njcm9sbCk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInVsXCIsIHtcbiAgICBjbGFzc05hbWU6IFwiaW5kaWNhdG9yc1wiXG4gIH0sIEFycmF5LmZyb20oe1xuICAgIGxlbmd0aDogcGFnZXNcbiAgfSwgZnVuY3Rpb24gKF8sIGtleSkge1xuICAgIHZhciBpbmRpY2F0b3JQcm9wcyA9IHtcbiAgICAgICdkYXRhLWtleSc6IGtleSxcbiAgICAgICdhcmlhLWxhYmVsJzogXCJHbyB0byBzbGlkZSBcIiArIChrZXkgKyAxKSxcbiAgICAgIG9uQ2xpY2s6IG5hdmlnYXRlXG4gICAgfTtcbiAgICB2YXIgaXNDdXJyZW50UGFnZUFjdGl2ZSA9IE1hdGguZmxvb3IoKGN1cnJlbnRJbmRleCArIHNsaWRlc1RvU2Nyb2xsIC0gMSkgLyBzbGlkZXNUb1Njcm9sbCkgPT09IGtleTtcblxuICAgIGlmICh0eXBlb2YgaW5kaWNhdG9ycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHNob3dDdXN0b21JbmRpY2F0b3IoaXNDdXJyZW50UGFnZUFjdGl2ZSwga2V5LCBpbmRpY2F0b3JQcm9wcywgaW5kaWNhdG9ycyhrZXkpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2hvd0RlZmF1bHRJbmRpY2F0b3IoaXNDdXJyZW50UGFnZUFjdGl2ZSwga2V5LCBpbmRpY2F0b3JQcm9wcyk7XG4gIH0pKTtcbn07XG5cbnZhciBkZWZhdWx0UHJvcHMgPSB7XG4gIGR1cmF0aW9uOiA1MDAwLFxuICB0cmFuc2l0aW9uRHVyYXRpb246IDEwMDAsXG4gIGRlZmF1bHRJbmRleDogMCxcbiAgaW5maW5pdGU6IHRydWUsXG4gIGF1dG9wbGF5OiB0cnVlLFxuICBpbmRpY2F0b3JzOiBmYWxzZSxcbiAgYXJyb3dzOiB0cnVlLFxuICBwYXVzZU9uSG92ZXI6IHRydWUsXG4gIGVhc2luZzogJ2xpbmVhcicsXG4gIGNhblN3aXBlOiB0cnVlLFxuICBjc3NDbGFzczogJycsXG4gIHJlc3BvbnNpdmU6IFtdXG59O1xuXG52YXIgRmFkZVpvb20gPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiAocHJvcHMsIHJlZikge1xuICB2YXIgX3VzZVN0YXRlID0gdXNlU3RhdGUoZ2V0U3RhcnRpbmdJbmRleChwcm9wcy5jaGlsZHJlbiwgcHJvcHMuZGVmYXVsdEluZGV4KSksXG4gICAgICBpbmRleCA9IF91c2VTdGF0ZVswXSxcbiAgICAgIHNldEluZGV4ID0gX3VzZVN0YXRlWzFdO1xuXG4gIHZhciB3cmFwcGVyUmVmID0gdXNlUmVmKG51bGwpO1xuICB2YXIgaW5uZXJXcmFwcGVyUmVmID0gdXNlUmVmKG51bGwpO1xuICB2YXIgdHdlZW5Hcm91cCA9IHVzZVJlZihuZXcgR3JvdXAoKSk7XG4gIHZhciB0aW1lb3V0ID0gdXNlUmVmKCk7XG4gIHZhciByZXNpemVPYnNlcnZlciA9IHVzZVJlZigpO1xuICB2YXIgY2hpbGRyZW5Db3VudCA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBSZWFjdC5DaGlsZHJlbi5jb3VudChwcm9wcy5jaGlsZHJlbik7XG4gIH0sIFtwcm9wcy5jaGlsZHJlbl0pO1xuICB2YXIgYXBwbHlTdHlsZSA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoaW5uZXJXcmFwcGVyUmVmLmN1cnJlbnQgJiYgd3JhcHBlclJlZi5jdXJyZW50KSB7XG4gICAgICB2YXIgd3JhcHBlcldpZHRoID0gd3JhcHBlclJlZi5jdXJyZW50LmNsaWVudFdpZHRoO1xuICAgICAgdmFyIGZ1bGx3aWR0aCA9IHdyYXBwZXJXaWR0aCAqIGNoaWxkcmVuQ291bnQ7XG4gICAgICBpbm5lcldyYXBwZXJSZWYuY3VycmVudC5zdHlsZS53aWR0aCA9IGZ1bGx3aWR0aCArIFwicHhcIjtcblxuICAgICAgZm9yICh2YXIgX2luZGV4ID0gMDsgX2luZGV4IDwgaW5uZXJXcmFwcGVyUmVmLmN1cnJlbnQuY2hpbGRyZW4ubGVuZ3RoOyBfaW5kZXgrKykge1xuICAgICAgICB2YXIgZWFjaERpdiA9IGlubmVyV3JhcHBlclJlZi5jdXJyZW50LmNoaWxkcmVuW19pbmRleF07XG5cbiAgICAgICAgaWYgKGVhY2hEaXYpIHtcbiAgICAgICAgICBlYWNoRGl2LnN0eWxlLndpZHRoID0gd3JhcHBlcldpZHRoICsgXCJweFwiO1xuICAgICAgICAgIGVhY2hEaXYuc3R5bGUubGVmdCA9IF9pbmRleCAqIC13cmFwcGVyV2lkdGggKyBcInB4XCI7XG4gICAgICAgICAgZWFjaERpdi5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCBbd3JhcHBlclJlZiwgaW5uZXJXcmFwcGVyUmVmLCBjaGlsZHJlbkNvdW50XSk7XG4gIHZhciBpbml0UmVzaXplT2JzZXJ2ZXIgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHdyYXBwZXJSZWYuY3VycmVudCkge1xuICAgICAgcmVzaXplT2JzZXJ2ZXIuY3VycmVudCA9IG5ldyBSZXNpemVPYnNlcnZlcihmdW5jdGlvbiAoZW50cmllcykge1xuICAgICAgICBpZiAoIWVudHJpZXMpIHJldHVybjtcbiAgICAgICAgYXBwbHlTdHlsZSgpO1xuICAgICAgfSk7XG4gICAgICByZXNpemVPYnNlcnZlci5jdXJyZW50Lm9ic2VydmUod3JhcHBlclJlZi5jdXJyZW50KTtcbiAgICB9XG4gIH0sIFt3cmFwcGVyUmVmLCBhcHBseVN0eWxlXSk7XG4gIHZhciBwbGF5ID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHZhciBhdXRvcGxheSA9IHByb3BzLmF1dG9wbGF5LFxuICAgICAgICBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxuICAgICAgICBkdXJhdGlvbiA9IHByb3BzLmR1cmF0aW9uLFxuICAgICAgICBpbmZpbml0ZSA9IHByb3BzLmluZmluaXRlO1xuXG4gICAgaWYgKGF1dG9wbGF5ICYmIFJlYWN0LkNoaWxkcmVuLmNvdW50KGNoaWxkcmVuKSA+IDEgJiYgKGluZmluaXRlIHx8IGluZGV4IDwgUmVhY3QuQ2hpbGRyZW4uY291bnQoY2hpbGRyZW4pIC0gMSkpIHtcbiAgICAgIHRpbWVvdXQuY3VycmVudCA9IHNldFRpbWVvdXQobW92ZU5leHQsIGR1cmF0aW9uKTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcblxuICB9LCBbcHJvcHMsIGluZGV4XSk7XG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaW5pdFJlc2l6ZU9ic2VydmVyKCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHR3ZWVuR3JvdXAuY3VycmVudC5yZW1vdmVBbGwoKTtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0LmN1cnJlbnQpO1xuICAgICAgcmVtb3ZlUmVzaXplT2JzZXJ2ZXIoKTtcbiAgICB9O1xuICB9LCBbaW5pdFJlc2l6ZU9ic2VydmVyLCB0d2Vlbkdyb3VwXSk7XG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQuY3VycmVudCk7XG4gICAgcGxheSgpO1xuICB9LCBbaW5kZXgsIHByb3BzLmF1dG9wbGF5LCBwbGF5XSk7XG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgYXBwbHlTdHlsZSgpO1xuICB9LCBbY2hpbGRyZW5Db3VudCwgYXBwbHlTdHlsZV0pO1xuICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBnb05leHQ6IGZ1bmN0aW9uIGdvTmV4dCgpIHtcbiAgICAgICAgbW92ZU5leHQoKTtcbiAgICAgIH0sXG4gICAgICBnb0JhY2s6IGZ1bmN0aW9uIGdvQmFjaygpIHtcbiAgICAgICAgbW92ZUJhY2soKTtcbiAgICAgIH0sXG4gICAgICBnb1RvOiBmdW5jdGlvbiBnb1RvKGluZGV4LCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zICE9IG51bGwgJiYgb3B0aW9ucy5za2lwVHJhbnNpdGlvbikge1xuICAgICAgICAgIHNldEluZGV4KGluZGV4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtb3ZlVG8oaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG5cbiAgdmFyIHJlbW92ZVJlc2l6ZU9ic2VydmVyID0gZnVuY3Rpb24gcmVtb3ZlUmVzaXplT2JzZXJ2ZXIoKSB7XG4gICAgaWYgKHJlc2l6ZU9ic2VydmVyLmN1cnJlbnQgJiYgd3JhcHBlclJlZi5jdXJyZW50KSB7XG4gICAgICByZXNpemVPYnNlcnZlci5jdXJyZW50LnVub2JzZXJ2ZSh3cmFwcGVyUmVmLmN1cnJlbnQpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgcGF1c2VTbGlkZXMgPSBmdW5jdGlvbiBwYXVzZVNsaWRlcygpIHtcbiAgICBpZiAocHJvcHMucGF1c2VPbkhvdmVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dC5jdXJyZW50KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHN0YXJ0U2xpZGVzID0gZnVuY3Rpb24gc3RhcnRTbGlkZXMoKSB7XG4gICAgdmFyIHBhdXNlT25Ib3ZlciA9IHByb3BzLnBhdXNlT25Ib3ZlcixcbiAgICAgICAgYXV0b3BsYXkgPSBwcm9wcy5hdXRvcGxheSxcbiAgICAgICAgZHVyYXRpb24gPSBwcm9wcy5kdXJhdGlvbjtcblxuICAgIGlmIChwYXVzZU9uSG92ZXIgJiYgYXV0b3BsYXkpIHtcbiAgICAgIHRpbWVvdXQuY3VycmVudCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbW92ZU5leHQoKTtcbiAgICAgIH0sIGR1cmF0aW9uKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIG1vdmVOZXh0ID0gZnVuY3Rpb24gbW92ZU5leHQoKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgICAgIGluZmluaXRlID0gcHJvcHMuaW5maW5pdGU7XG5cbiAgICBpZiAoIWluZmluaXRlICYmIGluZGV4ID09PSBSZWFjdC5DaGlsZHJlbi5jb3VudChjaGlsZHJlbikgLSAxKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJhbnNpdGlvblNsaWRlKChpbmRleCArIDEpICUgUmVhY3QuQ2hpbGRyZW4uY291bnQoY2hpbGRyZW4pKTtcbiAgfTtcblxuICB2YXIgbW92ZUJhY2sgPSBmdW5jdGlvbiBtb3ZlQmFjaygpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgICAgaW5maW5pdGUgPSBwcm9wcy5pbmZpbml0ZTtcblxuICAgIGlmICghaW5maW5pdGUgJiYgaW5kZXggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0cmFuc2l0aW9uU2xpZGUoaW5kZXggPT09IDAgPyBSZWFjdC5DaGlsZHJlbi5jb3VudChjaGlsZHJlbikgLSAxIDogaW5kZXggLSAxKTtcbiAgfTtcblxuICB2YXIgcHJlVHJhbnNpdGlvbiA9IGZ1bmN0aW9uIHByZVRyYW5zaXRpb24oZXZlbnQpIHtcbiAgICB2YXIgY3VycmVudFRhcmdldCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG5cbiAgICBpZiAoY3VycmVudFRhcmdldC5kYXRhc2V0LnR5cGUgPT09ICdwcmV2Jykge1xuICAgICAgbW92ZUJhY2soKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbW92ZU5leHQoKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGFuaW1hdGUgPSBmdW5jdGlvbiBhbmltYXRlKCkge1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcbiAgICB0d2Vlbkdyb3VwLmN1cnJlbnQudXBkYXRlKCk7XG4gIH07XG5cbiAgdmFyIHRyYW5zaXRpb25TbGlkZSA9IGZ1bmN0aW9uIHRyYW5zaXRpb25TbGlkZShuZXdJbmRleCkge1xuICAgIHZhciBleGlzdGluZ1R3ZWVucyA9IHR3ZWVuR3JvdXAuY3VycmVudC5nZXRBbGwoKTtcblxuICAgIGlmICghZXhpc3RpbmdUd2VlbnMubGVuZ3RoKSB7XG4gICAgICB2YXIgX2lubmVyV3JhcHBlclJlZiRjdXJyO1xuXG4gICAgICBpZiAoISgoX2lubmVyV3JhcHBlclJlZiRjdXJyID0gaW5uZXJXcmFwcGVyUmVmLmN1cnJlbnQpICE9IG51bGwgJiYgX2lubmVyV3JhcHBlclJlZiRjdXJyLmNoaWxkcmVuW25ld0luZGV4XSkpIHtcbiAgICAgICAgbmV3SW5kZXggPSAwO1xuICAgICAgfVxuXG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dC5jdXJyZW50KTtcbiAgICAgIHZhciB2YWx1ZSA9IHtcbiAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgc2NhbGU6IDFcbiAgICAgIH07XG4gICAgICBhbmltYXRlKCk7XG4gICAgICB2YXIgdHdlZW4gPSBuZXcgVHdlZW4odmFsdWUsIHR3ZWVuR3JvdXAuY3VycmVudCkudG8oe1xuICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICBzY2FsZTogcHJvcHMuc2NhbGVcbiAgICAgIH0sIHByb3BzLnRyYW5zaXRpb25EdXJhdGlvbikub25VcGRhdGUoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICghaW5uZXJXcmFwcGVyUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpbm5lcldyYXBwZXJSZWYuY3VycmVudC5jaGlsZHJlbltuZXdJbmRleF0uc3R5bGUub3BhY2l0eSA9IHZhbHVlLm9wYWNpdHk7XG4gICAgICAgIGlubmVyV3JhcHBlclJlZi5jdXJyZW50LmNoaWxkcmVuW2luZGV4XS5zdHlsZS5vcGFjaXR5ID0gMSAtIHZhbHVlLm9wYWNpdHk7XG4gICAgICAgIGlubmVyV3JhcHBlclJlZi5jdXJyZW50LmNoaWxkcmVuW2luZGV4XS5zdHlsZS50cmFuc2Zvcm0gPSBcInNjYWxlKFwiICsgdmFsdWUuc2NhbGUgKyBcIilcIjtcbiAgICAgIH0pO1xuICAgICAgdHdlZW4uZWFzaW5nKGdldEVhc2luZyhwcm9wcy5lYXNpbmcpKTtcbiAgICAgIHR3ZWVuLm9uU3RhcnQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodHlwZW9mIHByb3BzLm9uU3RhcnRDaGFuZ2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBwcm9wcy5vblN0YXJ0Q2hhbmdlKGluZGV4LCBuZXdJbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdHdlZW4ub25Db21wbGV0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbm5lcldyYXBwZXJSZWYuY3VycmVudCkge1xuICAgICAgICAgIHNldEluZGV4KG5ld0luZGV4KTtcbiAgICAgICAgICBpbm5lcldyYXBwZXJSZWYuY3VycmVudC5jaGlsZHJlbltpbmRleF0uc3R5bGUudHJhbnNmb3JtID0gXCJzY2FsZSgxKVwiO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwcm9wcy5vbkNoYW5nZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHByb3BzLm9uQ2hhbmdlKGluZGV4LCBuZXdJbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdHdlZW4uc3RhcnQoKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIG1vdmVUbyA9IGZ1bmN0aW9uIG1vdmVUbyhnb3RvSW5kZXgpIHtcbiAgICBpZiAoZ290b0luZGV4ICE9PSBpbmRleCkge1xuICAgICAgdHJhbnNpdGlvblNsaWRlKGdvdG9JbmRleCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBuYXZpZ2F0ZSA9IGZ1bmN0aW9uIG5hdmlnYXRlKGV2ZW50KSB7XG4gICAgdmFyIGN1cnJlbnRUYXJnZXQgPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuXG4gICAgaWYgKCFjdXJyZW50VGFyZ2V0LmRhdGFzZXQua2V5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHBhcnNlSW50KGN1cnJlbnRUYXJnZXQuZGF0YXNldC5rZXkpICE9PSBpbmRleCkge1xuICAgICAgbW92ZVRvKHBhcnNlSW50KGN1cnJlbnRUYXJnZXQuZGF0YXNldC5rZXkpKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBkaXI6IFwibHRyXCIsXG4gICAgXCJhcmlhLXJvbGVkZXNjcmlwdGlvblwiOiBcImNhcm91c2VsXCJcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogXCJyZWFjdC1zbGlkZXNob3ctY29udGFpbmVyIFwiICsgKHByb3BzLmNzc0NsYXNzIHx8ICcnKSxcbiAgICBvbk1vdXNlRW50ZXI6IHBhdXNlU2xpZGVzLFxuICAgIG9uTW91c2VPdmVyOiBwYXVzZVNsaWRlcyxcbiAgICBvbk1vdXNlTGVhdmU6IHN0YXJ0U2xpZGVzXG4gIH0sIHByb3BzLmFycm93cyAmJiBzaG93UHJldmlvdXNBcnJvdyhwcm9wcywgaW5kZXgsIHByZVRyYW5zaXRpb24pLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBcInJlYWN0LXNsaWRlc2hvdy1mYWRlem9vbS13cmFwcGVyIFwiICsgcHJvcHMuY3NzQ2xhc3MsXG4gICAgcmVmOiB3cmFwcGVyUmVmXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBjbGFzc05hbWU6IFwicmVhY3Qtc2xpZGVzaG93LWZhZGV6b29tLWltYWdlcy13cmFwXCIsXG4gICAgcmVmOiBpbm5lcldyYXBwZXJSZWZcbiAgfSwgKFJlYWN0LkNoaWxkcmVuLm1hcChwcm9wcy5jaGlsZHJlbiwgZnVuY3Rpb24gKHRoaXNBcmcpIHtcbiAgICByZXR1cm4gdGhpc0FyZztcbiAgfSkgfHwgW10pLm1hcChmdW5jdGlvbiAoZWFjaCwga2V5KSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIG9wYWNpdHk6IGtleSA9PT0gaW5kZXggPyAnMScgOiAnMCcsXG4gICAgICAgIHpJbmRleDoga2V5ID09PSBpbmRleCA/ICcxJyA6ICcwJ1xuICAgICAgfSxcbiAgICAgIFwiZGF0YS1pbmRleFwiOiBrZXksXG4gICAgICBrZXk6IGtleSxcbiAgICAgIFwiYXJpYS1yb2xlZGVzY3JpcHRpb25cIjogXCJzbGlkZVwiLFxuICAgICAgXCJhcmlhLWhpZGRlblwiOiBrZXkgPT09IGluZGV4ID8gJ2ZhbHNlJyA6ICd0cnVlJ1xuICAgIH0sIGVhY2gpO1xuICB9KSkpLCBwcm9wcy5hcnJvd3MgJiYgc2hvd05leHRBcnJvdyhwcm9wcywgaW5kZXgsIHByZVRyYW5zaXRpb24pKSwgcHJvcHMuaW5kaWNhdG9ycyAmJiBzaG93SW5kaWNhdG9ycyhwcm9wcywgaW5kZXgsIG5hdmlnYXRlKSk7XG59KTtcbkZhZGVab29tLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcblxudmFyIEZhZGUgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiAocHJvcHMsIHJlZikge1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRmFkZVpvb20sIE9iamVjdC5hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgc2NhbGU6IDEsXG4gICAgcmVmOiByZWZcbiAgfSkpO1xufSk7XG5GYWRlLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcblxudmFyIFpvb20gPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiAocHJvcHMsIHJlZikge1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRmFkZVpvb20sIE9iamVjdC5hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgcmVmOiByZWZcbiAgfSkpO1xufSk7XG5ab29tLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcblxudmFyIFNsaWRlID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gKHByb3BzLCByZWYpIHtcbiAgdmFyIF91c2VTdGF0ZSA9IHVzZVN0YXRlKGdldFN0YXJ0aW5nSW5kZXgocHJvcHMuY2hpbGRyZW4sIHByb3BzLmRlZmF1bHRJbmRleCkpLFxuICAgICAgaW5kZXggPSBfdXNlU3RhdGVbMF0sXG4gICAgICBzZXRJbmRleCA9IF91c2VTdGF0ZVsxXTtcblxuICB2YXIgX3VzZVN0YXRlMiA9IHVzZVN0YXRlKDApLFxuICAgICAgd3JhcHBlcldpZHRoID0gX3VzZVN0YXRlMlswXSxcbiAgICAgIHNldFdyYXBwZXJXaWR0aCA9IF91c2VTdGF0ZTJbMV07XG5cbiAgdmFyIHdyYXBwZXJSZWYgPSB1c2VSZWYobnVsbCk7XG4gIHZhciBpbm5lcldyYXBwZXJSZWYgPSB1c2VSZWYobnVsbCk7XG4gIHZhciB0d2Vlbkdyb3VwID0gdXNlUmVmKG5ldyBHcm91cCgpKTtcbiAgdmFyIHJlc3BvbnNpdmVTZXR0aW5ncyA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnZXRSZXNwb25zaXZlU2V0dGluZ3Mod3JhcHBlcldpZHRoLCBwcm9wcy5yZXNwb25zaXZlKTtcbiAgfSwgW3dyYXBwZXJXaWR0aCwgcHJvcHMucmVzcG9uc2l2ZV0pO1xuICB2YXIgc2xpZGVzVG9TY3JvbGwgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocmVzcG9uc2l2ZVNldHRpbmdzKSB7XG4gICAgICByZXR1cm4gcmVzcG9uc2l2ZVNldHRpbmdzLnNldHRpbmdzLnNsaWRlc1RvU2Nyb2xsO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9wcy5zbGlkZXNUb1Njcm9sbCB8fCAxO1xuICB9LCBbcmVzcG9uc2l2ZVNldHRpbmdzLCBwcm9wcy5zbGlkZXNUb1Njcm9sbF0pO1xuICB2YXIgc2xpZGVzVG9TaG93ID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHJlc3BvbnNpdmVTZXR0aW5ncykge1xuICAgICAgcmV0dXJuIHJlc3BvbnNpdmVTZXR0aW5ncy5zZXR0aW5ncy5zbGlkZXNUb1Nob3c7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb3BzLnNsaWRlc1RvU2hvdyB8fCAxO1xuICB9LCBbcmVzcG9uc2l2ZVNldHRpbmdzLCBwcm9wcy5zbGlkZXNUb1Nob3ddKTtcbiAgdmFyIGNoaWxkcmVuQ291bnQgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gUmVhY3QuQ2hpbGRyZW4uY291bnQocHJvcHMuY2hpbGRyZW4pO1xuICB9LCBbcHJvcHMuY2hpbGRyZW5dKTtcbiAgdmFyIGVhY2hDaGlsZFdpZHRoID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHdyYXBwZXJXaWR0aCAvIHNsaWRlc1RvU2hvdztcbiAgfSwgW3dyYXBwZXJXaWR0aCwgc2xpZGVzVG9TaG93XSk7XG4gIHZhciB0aW1lb3V0ID0gdXNlUmVmKCk7XG4gIHZhciByZXNpemVPYnNlcnZlciA9IHVzZVJlZigpO1xuICB2YXIgc3RhcnRpbmdDbGllbnRYO1xuICB2YXIgZHJhZ2dpbmcgPSBmYWxzZTtcbiAgdmFyIGRpc3RhbmNlU3dpcGVkID0gMDtcbiAgdmFyIGFwcGx5U3R5bGUgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGlubmVyV3JhcHBlclJlZi5jdXJyZW50KSB7XG4gICAgICB2YXIgZnVsbHdpZHRoID0gd3JhcHBlcldpZHRoICogaW5uZXJXcmFwcGVyUmVmLmN1cnJlbnQuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgaW5uZXJXcmFwcGVyUmVmLmN1cnJlbnQuc3R5bGUud2lkdGggPSBmdWxsd2lkdGggKyBcInB4XCI7XG5cbiAgICAgIGZvciAodmFyIF9pbmRleCA9IDA7IF9pbmRleCA8IGlubmVyV3JhcHBlclJlZi5jdXJyZW50LmNoaWxkcmVuLmxlbmd0aDsgX2luZGV4KyspIHtcbiAgICAgICAgdmFyIGVhY2hEaXYgPSBpbm5lcldyYXBwZXJSZWYuY3VycmVudC5jaGlsZHJlbltfaW5kZXhdO1xuXG4gICAgICAgIGlmIChlYWNoRGl2KSB7XG4gICAgICAgICAgZWFjaERpdi5zdHlsZS53aWR0aCA9IGVhY2hDaGlsZFdpZHRoICsgXCJweFwiO1xuICAgICAgICAgIGVhY2hEaXYuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwgW3dyYXBwZXJXaWR0aCwgZWFjaENoaWxkV2lkdGhdKTtcbiAgdmFyIGluaXRSZXNpemVPYnNlcnZlciA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAod3JhcHBlclJlZi5jdXJyZW50KSB7XG4gICAgICByZXNpemVPYnNlcnZlci5jdXJyZW50ID0gbmV3IFJlc2l6ZU9ic2VydmVyKGZ1bmN0aW9uIChlbnRyaWVzKSB7XG4gICAgICAgIGlmICghZW50cmllcykgcmV0dXJuO1xuICAgICAgICBzZXRXaWR0aCgpO1xuICAgICAgfSk7XG4gICAgICByZXNpemVPYnNlcnZlci5jdXJyZW50Lm9ic2VydmUod3JhcHBlclJlZi5jdXJyZW50KTtcbiAgICB9XG4gIH0sIFt3cmFwcGVyUmVmXSk7XG4gIHZhciBwbGF5ID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHZhciBhdXRvcGxheSA9IHByb3BzLmF1dG9wbGF5LFxuICAgICAgICBpbmZpbml0ZSA9IHByb3BzLmluZmluaXRlLFxuICAgICAgICBkdXJhdGlvbiA9IHByb3BzLmR1cmF0aW9uO1xuXG4gICAgaWYgKGF1dG9wbGF5ICYmIChpbmZpbml0ZSB8fCBpbmRleCA8IGNoaWxkcmVuQ291bnQgLSAxKSkge1xuICAgICAgdGltZW91dC5jdXJyZW50ID0gc2V0VGltZW91dChtb3ZlTmV4dCwgZHVyYXRpb24pO1xuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuXG4gIH0sIFtwcm9wcywgY2hpbGRyZW5Db3VudCwgaW5kZXhdKTtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBhcHBseVN0eWxlKCk7XG4gIH0sIFt3cmFwcGVyV2lkdGgsIGFwcGx5U3R5bGVdKTtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpbml0UmVzaXplT2JzZXJ2ZXIoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdHdlZW5Hcm91cC5jdXJyZW50LnJlbW92ZUFsbCgpO1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQuY3VycmVudCk7XG4gICAgICByZW1vdmVSZXNpemVPYnNlcnZlcigpO1xuICAgIH07XG4gIH0sIFt3cmFwcGVyUmVmLCBpbml0UmVzaXplT2JzZXJ2ZXIsIHR3ZWVuR3JvdXBdKTtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dC5jdXJyZW50KTtcbiAgICBwbGF5KCk7XG4gIH0sIFtpbmRleCwgd3JhcHBlcldpZHRoLCBwcm9wcy5hdXRvcGxheSwgcGxheV0pO1xuICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBnb05leHQ6IGZ1bmN0aW9uIGdvTmV4dCgpIHtcbiAgICAgICAgbW92ZU5leHQoKTtcbiAgICAgIH0sXG4gICAgICBnb0JhY2s6IGZ1bmN0aW9uIGdvQmFjaygpIHtcbiAgICAgICAgbW92ZUJhY2soKTtcbiAgICAgIH0sXG4gICAgICBnb1RvOiBmdW5jdGlvbiBnb1RvKGluZGV4LCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zICE9IG51bGwgJiYgb3B0aW9ucy5za2lwVHJhbnNpdGlvbikge1xuICAgICAgICAgIHNldEluZGV4KGluZGV4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtb3ZlVG8oaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG5cbiAgdmFyIHJlbW92ZVJlc2l6ZU9ic2VydmVyID0gZnVuY3Rpb24gcmVtb3ZlUmVzaXplT2JzZXJ2ZXIoKSB7XG4gICAgaWYgKHJlc2l6ZU9ic2VydmVyICYmIHdyYXBwZXJSZWYuY3VycmVudCkge1xuICAgICAgcmVzaXplT2JzZXJ2ZXIuY3VycmVudC51bm9ic2VydmUod3JhcHBlclJlZi5jdXJyZW50KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHBhdXNlU2xpZGVzID0gZnVuY3Rpb24gcGF1c2VTbGlkZXMoKSB7XG4gICAgaWYgKHByb3BzLnBhdXNlT25Ib3Zlcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQuY3VycmVudCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBzd2lwZSA9IGZ1bmN0aW9uIHN3aXBlKGV2ZW50KSB7XG4gICAgaWYgKHByb3BzLmNhblN3aXBlICYmIGRyYWdnaW5nKSB7XG4gICAgICB2YXIgY2xpZW50WDtcblxuICAgICAgaWYgKHdpbmRvdy5Ub3VjaEV2ZW50ICYmIGV2ZW50Lm5hdGl2ZUV2ZW50IGluc3RhbmNlb2YgVG91Y2hFdmVudCkge1xuICAgICAgICBjbGllbnRYID0gZXZlbnQubmF0aXZlRXZlbnQudG91Y2hlc1swXS5wYWdlWDtcbiAgICAgIH0gZWxzZSBpZiAoZXZlbnQubmF0aXZlRXZlbnQgaW5zdGFuY2VvZiBNb3VzZUV2ZW50KSB7XG4gICAgICAgIGNsaWVudFggPSBldmVudC5uYXRpdmVFdmVudC5jbGllbnRYO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2xpZW50WCAmJiBzdGFydGluZ0NsaWVudFgpIHtcbiAgICAgICAgdmFyIHRyYW5zbGF0ZVZhbHVlID0gZWFjaENoaWxkV2lkdGggKiAoaW5kZXggKyBnZXRPZmZzZXQoKSk7XG4gICAgICAgIHZhciBkaXN0YW5jZSA9IGNsaWVudFggLSBzdGFydGluZ0NsaWVudFg7XG5cbiAgICAgICAgaWYgKCFwcm9wcy5pbmZpbml0ZSAmJiBpbmRleCA9PT0gY2hpbGRyZW5Db3VudCAtIHNsaWRlc1RvU2Nyb2xsICYmIGRpc3RhbmNlIDwgMCkge1xuICAgICAgICAgIC8vIGlmIGl0IGlzIHRoZSBsYXN0IGFuZCBpbmZpbml0ZSBpcyBmYWxzZSBhbmQgeW91J3JlIHN3aXBpbmcgbGVmdFxuICAgICAgICAgIC8vIHRoZW4gbm90aGluZyBoYXBwZW5zXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFwcm9wcy5pbmZpbml0ZSAmJiBpbmRleCA9PT0gMCAmJiBkaXN0YW5jZSA+IDApIHtcbiAgICAgICAgICAvLyBpZiBpdCBpcyB0aGUgZmlyc3QgYW5kIGluZmluaXRlIGlzIGZhbHNlIGFuZCB5b3UncmUgc3dpcGluZyByaWdodFxuICAgICAgICAgIC8vIHRoZW4gbm90aGluZyBoYXBwZW5zXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZGlzdGFuY2VTd2lwZWQgPSBkaXN0YW5jZTtcbiAgICAgICAgdHJhbnNsYXRlVmFsdWUgLT0gZGlzdGFuY2VTd2lwZWQ7XG4gICAgICAgIGlubmVyV3JhcHBlclJlZi5jdXJyZW50LnN0eWxlLnRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKC1cIiArIHRyYW5zbGF0ZVZhbHVlICsgXCJweClcIjtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIG1vdmVOZXh0ID0gZnVuY3Rpb24gbW92ZU5leHQoKSB7XG4gICAgaWYgKCFwcm9wcy5pbmZpbml0ZSAmJiBpbmRleCA9PT0gY2hpbGRyZW5Db3VudCAtIHNsaWRlc1RvU2Nyb2xsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5leHRJbmRleCA9IGNhbGN1bGF0ZUluZGV4KGluZGV4ICsgc2xpZGVzVG9TY3JvbGwpO1xuICAgIHRyYW5zaXRpb25TbGlkZShuZXh0SW5kZXgpO1xuICB9O1xuXG4gIHZhciBtb3ZlQmFjayA9IGZ1bmN0aW9uIG1vdmVCYWNrKCkge1xuICAgIGlmICghcHJvcHMuaW5maW5pdGUgJiYgaW5kZXggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNJbmRleCA9IGluZGV4IC0gc2xpZGVzVG9TY3JvbGw7XG5cbiAgICBpZiAocHJldmlvdXNJbmRleCAlIHNsaWRlc1RvU2Nyb2xsKSB7XG4gICAgICBwcmV2aW91c0luZGV4ID0gTWF0aC5jZWlsKHByZXZpb3VzSW5kZXggLyBzbGlkZXNUb1Njcm9sbCkgKiBzbGlkZXNUb1Njcm9sbDtcbiAgICB9XG5cbiAgICB0cmFuc2l0aW9uU2xpZGUocHJldmlvdXNJbmRleCk7XG4gIH07XG5cbiAgdmFyIGdvVG9TbGlkZSA9IGZ1bmN0aW9uIGdvVG9TbGlkZShfcmVmKSB7XG4gICAgdmFyIGN1cnJlbnRUYXJnZXQgPSBfcmVmLmN1cnJlbnRUYXJnZXQ7XG5cbiAgICBpZiAoIWN1cnJlbnRUYXJnZXQuZGF0YXNldC5rZXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZGF0YXNldEtleSA9IHBhcnNlSW50KGN1cnJlbnRUYXJnZXQuZGF0YXNldC5rZXkpO1xuICAgIG1vdmVUbyhkYXRhc2V0S2V5ICogc2xpZGVzVG9TY3JvbGwpO1xuICB9O1xuXG4gIHZhciBtb3ZlVG8gPSBmdW5jdGlvbiBtb3ZlVG8oaW5kZXgpIHtcbiAgICB0cmFuc2l0aW9uU2xpZGUoY2FsY3VsYXRlSW5kZXgoaW5kZXgpKTtcbiAgfTtcblxuICB2YXIgY2FsY3VsYXRlSW5kZXggPSBmdW5jdGlvbiBjYWxjdWxhdGVJbmRleChuZXh0SW5kZXgpIHtcbiAgICBpZiAobmV4dEluZGV4IDwgY2hpbGRyZW5Db3VudCAmJiBuZXh0SW5kZXggKyBzbGlkZXNUb1Njcm9sbCA+IGNoaWxkcmVuQ291bnQpIHtcbiAgICAgIGlmICgoY2hpbGRyZW5Db3VudCAtIHNsaWRlc1RvU2Nyb2xsKSAlIHNsaWRlc1RvU2Nyb2xsKSB7XG4gICAgICAgIHJldHVybiBjaGlsZHJlbkNvdW50IC0gc2xpZGVzVG9TY3JvbGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXh0SW5kZXg7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5leHRJbmRleDtcbiAgfTtcblxuICB2YXIgc3RhcnRTbGlkZXMgPSBmdW5jdGlvbiBzdGFydFNsaWRlcygpIHtcbiAgICBpZiAoZHJhZ2dpbmcpIHtcbiAgICAgIGVuZFN3aXBlKCk7XG4gICAgfSBlbHNlIGlmIChwcm9wcy5wYXVzZU9uSG92ZXIgJiYgcHJvcHMuYXV0b3BsYXkpIHtcbiAgICAgIHRpbWVvdXQuY3VycmVudCA9IHNldFRpbWVvdXQobW92ZU5leHQsIHByb3BzLmR1cmF0aW9uKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIG1vdmVTbGlkZXMgPSBmdW5jdGlvbiBtb3ZlU2xpZGVzKF9yZWYyKSB7XG4gICAgdmFyIGRhdGFzZXQgPSBfcmVmMi5jdXJyZW50VGFyZ2V0LmRhdGFzZXQ7XG5cbiAgICBpZiAoZGF0YXNldC50eXBlID09PSAnbmV4dCcpIHtcbiAgICAgIG1vdmVOZXh0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1vdmVCYWNrKCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciByZW5kZXJQcmVjZWVkaW5nU2xpZGVzID0gZnVuY3Rpb24gcmVuZGVyUHJlY2VlZGluZ1NsaWRlcygpIHtcbiAgICByZXR1cm4gUmVhY3QuQ2hpbGRyZW4udG9BcnJheShwcm9wcy5jaGlsZHJlbikuc2xpY2UoLXNsaWRlc1RvU2hvdykubWFwKGZ1bmN0aW9uIChlYWNoLCBpbmRleCkge1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgXCJkYXRhLWluZGV4XCI6IGluZGV4IC0gc2xpZGVzVG9TaG93LFxuICAgICAgICBcImFyaWEtcm9sZWRlc2NyaXB0aW9uXCI6IFwic2xpZGVcIixcbiAgICAgICAgXCJhcmlhLWhpZGRlblwiOiBcInRydWVcIixcbiAgICAgICAga2V5OiBpbmRleCAtIHNsaWRlc1RvU2hvd1xuICAgICAgfSwgZWFjaCk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIHJlbmRlclRyYWlsaW5nU2xpZGVzID0gZnVuY3Rpb24gcmVuZGVyVHJhaWxpbmdTbGlkZXMoKSB7XG4gICAgaWYgKCFwcm9wcy5pbmZpbml0ZSAmJiBzbGlkZXNUb1Nob3cgPT09IHNsaWRlc1RvU2Nyb2xsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmV0dXJuIFJlYWN0LkNoaWxkcmVuLnRvQXJyYXkocHJvcHMuY2hpbGRyZW4pLnNsaWNlKDAsIHNsaWRlc1RvU2hvdykubWFwKGZ1bmN0aW9uIChlYWNoLCBpbmRleCkge1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgXCJkYXRhLWluZGV4XCI6IGNoaWxkcmVuQ291bnQgKyBpbmRleCxcbiAgICAgICAgXCJhcmlhLXJvbGVkZXNjcmlwdGlvblwiOiBcInNsaWRlXCIsXG4gICAgICAgIFwiYXJpYS1oaWRkZW5cIjogXCJ0cnVlXCIsXG4gICAgICAgIGtleTogY2hpbGRyZW5Db3VudCArIGluZGV4XG4gICAgICB9LCBlYWNoKTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgc2V0V2lkdGggPSBmdW5jdGlvbiBzZXRXaWR0aCgpIHtcbiAgICBpZiAod3JhcHBlclJlZi5jdXJyZW50KSB7XG4gICAgICBzZXRXcmFwcGVyV2lkdGgod3JhcHBlclJlZi5jdXJyZW50LmNsaWVudFdpZHRoKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHN0YXJ0U3dpcGUgPSBmdW5jdGlvbiBzdGFydFN3aXBlKGV2ZW50KSB7XG4gICAgaWYgKHByb3BzLmNhblN3aXBlKSB7XG4gICAgICBpZiAod2luZG93LlRvdWNoRXZlbnQgJiYgZXZlbnQubmF0aXZlRXZlbnQgaW5zdGFuY2VvZiBUb3VjaEV2ZW50KSB7XG4gICAgICAgIHN0YXJ0aW5nQ2xpZW50WCA9IGV2ZW50Lm5hdGl2ZUV2ZW50LnRvdWNoZXNbMF0ucGFnZVg7XG4gICAgICB9IGVsc2UgaWYgKGV2ZW50Lm5hdGl2ZUV2ZW50IGluc3RhbmNlb2YgTW91c2VFdmVudCkge1xuICAgICAgICBzdGFydGluZ0NsaWVudFggPSBldmVudC5uYXRpdmVFdmVudC5jbGllbnRYO1xuICAgICAgfVxuXG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dC5jdXJyZW50KTtcbiAgICAgIGRyYWdnaW5nID0gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGVuZFN3aXBlID0gZnVuY3Rpb24gZW5kU3dpcGUoKSB7XG4gICAgaWYgKHByb3BzLmNhblN3aXBlKSB7XG4gICAgICBkcmFnZ2luZyA9IGZhbHNlO1xuXG4gICAgICBpZiAoTWF0aC5hYnMoZGlzdGFuY2VTd2lwZWQpIC8gd3JhcHBlcldpZHRoID4gMC4yKSB7XG4gICAgICAgIGlmIChkaXN0YW5jZVN3aXBlZCA8IDApIHtcbiAgICAgICAgICBtb3ZlTmV4dCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1vdmVCYWNrKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChNYXRoLmFicyhkaXN0YW5jZVN3aXBlZCkgPiAwKSB7XG4gICAgICAgICAgdHJhbnNpdGlvblNsaWRlKGluZGV4LCAzMDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBhbmltYXRlID0gZnVuY3Rpb24gYW5pbWF0ZSgpIHtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XG4gICAgdHdlZW5Hcm91cC5jdXJyZW50LnVwZGF0ZSgpO1xuICB9O1xuXG4gIHZhciB0cmFuc2l0aW9uU2xpZGUgPSBmdW5jdGlvbiB0cmFuc2l0aW9uU2xpZGUodG9JbmRleCwgYW5pbWF0aW9uRHVyYXRpb24pIHtcbiAgICB2YXIgdHJhbnNpdGlvbkR1cmF0aW9uID0gYW5pbWF0aW9uRHVyYXRpb24gfHwgcHJvcHMudHJhbnNpdGlvbkR1cmF0aW9uO1xuICAgIHZhciBjdXJyZW50SW5kZXggPSBpbmRleDtcbiAgICB2YXIgZXhpc3RpbmdUd2VlbnMgPSB0d2Vlbkdyb3VwLmN1cnJlbnQuZ2V0QWxsKCk7XG5cbiAgICBpZiAoIXdyYXBwZXJSZWYuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjaGlsZFdpZHRoID0gd3JhcHBlclJlZi5jdXJyZW50LmNsaWVudFdpZHRoIC8gc2xpZGVzVG9TaG93O1xuXG4gICAgaWYgKCFleGlzdGluZ1R3ZWVucy5sZW5ndGgpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0LmN1cnJlbnQpO1xuICAgICAgdmFyIHZhbHVlID0ge1xuICAgICAgICBtYXJnaW46IC1jaGlsZFdpZHRoICogKGN1cnJlbnRJbmRleCArIGdldE9mZnNldCgpKSArIGRpc3RhbmNlU3dpcGVkXG4gICAgICB9O1xuICAgICAgdmFyIHR3ZWVuID0gbmV3IFR3ZWVuKHZhbHVlLCB0d2Vlbkdyb3VwLmN1cnJlbnQpLnRvKHtcbiAgICAgICAgbWFyZ2luOiAtY2hpbGRXaWR0aCAqICh0b0luZGV4ICsgZ2V0T2Zmc2V0KCkpXG4gICAgICB9LCB0cmFuc2l0aW9uRHVyYXRpb24pLm9uVXBkYXRlKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAoaW5uZXJXcmFwcGVyUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICBpbm5lcldyYXBwZXJSZWYuY3VycmVudC5zdHlsZS50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIHZhbHVlLm1hcmdpbiArIFwicHgpXCI7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdHdlZW4uZWFzaW5nKGdldEVhc2luZyhwcm9wcy5lYXNpbmcpKTtcbiAgICAgIGFuaW1hdGUoKTtcbiAgICAgIHZhciBuZXdJbmRleCA9IHRvSW5kZXg7XG5cbiAgICAgIGlmIChuZXdJbmRleCA8IDApIHtcbiAgICAgICAgbmV3SW5kZXggPSBjaGlsZHJlbkNvdW50IC0gc2xpZGVzVG9TY3JvbGw7XG4gICAgICB9IGVsc2UgaWYgKG5ld0luZGV4ID49IGNoaWxkcmVuQ291bnQpIHtcbiAgICAgICAgbmV3SW5kZXggPSAwO1xuICAgICAgfVxuXG4gICAgICB0d2Vlbi5vblN0YXJ0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9wcy5vblN0YXJ0Q2hhbmdlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcHJvcHMub25TdGFydENoYW5nZShpbmRleCwgbmV3SW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHR3ZWVuLm9uQ29tcGxldGUoZnVuY3Rpb24gKCkge1xuICAgICAgICBkaXN0YW5jZVN3aXBlZCA9IDA7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwcm9wcy5vbkNoYW5nZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHByb3BzLm9uQ2hhbmdlKGluZGV4LCBuZXdJbmRleCk7XG4gICAgICAgIH1cblxuICAgICAgICBzZXRJbmRleChuZXdJbmRleCk7XG4gICAgICB9KTtcbiAgICAgIHR3ZWVuLnN0YXJ0KCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBpc1NsaWRlQWN0aXZlID0gZnVuY3Rpb24gaXNTbGlkZUFjdGl2ZShrZXkpIHtcbiAgICByZXR1cm4ga2V5IDwgaW5kZXggKyBzbGlkZXNUb1Nob3cgJiYga2V5ID49IGluZGV4O1xuICB9O1xuXG4gIHZhciBnZXRPZmZzZXQgPSBmdW5jdGlvbiBnZXRPZmZzZXQoKSB7XG4gICAgaWYgKCFwcm9wcy5pbmZpbml0ZSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNsaWRlc1RvU2hvdztcbiAgfTtcblxuICB2YXIgc3R5bGUgPSB7XG4gICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZSgtXCIgKyAoaW5kZXggKyBnZXRPZmZzZXQoKSkgKiBlYWNoQ2hpbGRXaWR0aCArIFwicHgpXCJcbiAgfTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBkaXI6IFwibHRyXCIsXG4gICAgXCJhcmlhLXJvbGVkZXNjcmlwdGlvblwiOiBcImNhcm91c2VsXCJcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogXCJyZWFjdC1zbGlkZXNob3ctY29udGFpbmVyXCIsXG4gICAgb25Nb3VzZUVudGVyOiBwYXVzZVNsaWRlcyxcbiAgICBvbk1vdXNlT3ZlcjogcGF1c2VTbGlkZXMsXG4gICAgb25Nb3VzZUxlYXZlOiBzdGFydFNsaWRlcyxcbiAgICBvbk1vdXNlRG93bjogc3RhcnRTd2lwZSxcbiAgICBvbk1vdXNlVXA6IGVuZFN3aXBlLFxuICAgIG9uTW91c2VNb3ZlOiBzd2lwZSxcbiAgICBvblRvdWNoU3RhcnQ6IHN0YXJ0U3dpcGUsXG4gICAgb25Ub3VjaEVuZDogZW5kU3dpcGUsXG4gICAgb25Ub3VjaENhbmNlbDogZW5kU3dpcGUsXG4gICAgb25Ub3VjaE1vdmU6IHN3aXBlXG4gIH0sIHByb3BzLmFycm93cyAmJiBzaG93UHJldmlvdXNBcnJvdyhwcm9wcywgaW5kZXgsIG1vdmVTbGlkZXMpLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBcInJlYWN0LXNsaWRlc2hvdy13cmFwcGVyIHNsaWRlIFwiICsgKHByb3BzLmNzc0NsYXNzIHx8ICcnKSxcbiAgICByZWY6IHdyYXBwZXJSZWZcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogXCJpbWFnZXMtd3JhcFwiLFxuICAgIHN0eWxlOiBzdHlsZSxcbiAgICByZWY6IGlubmVyV3JhcHBlclJlZlxuICB9LCBwcm9wcy5pbmZpbml0ZSAmJiByZW5kZXJQcmVjZWVkaW5nU2xpZGVzKCksIChSZWFjdC5DaGlsZHJlbi5tYXAocHJvcHMuY2hpbGRyZW4sIGZ1bmN0aW9uICh0aGlzQXJnKSB7XG4gICAgcmV0dXJuIHRoaXNBcmc7XG4gIH0pIHx8IFtdKS5tYXAoZnVuY3Rpb24gKGVhY2gsIGtleSkge1xuICAgIHZhciBpc1RoaXNTbGlkZUFjdGl2ZSA9IGlzU2xpZGVBY3RpdmUoa2V5KTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgXCJkYXRhLWluZGV4XCI6IGtleSxcbiAgICAgIGtleToga2V5LFxuICAgICAgY2xhc3NOYW1lOiBpc1RoaXNTbGlkZUFjdGl2ZSA/ICdhY3RpdmUnIDogJycsXG4gICAgICBcImFyaWEtcm9sZWRlc2NyaXB0aW9uXCI6IFwic2xpZGVcIixcbiAgICAgIFwiYXJpYS1oaWRkZW5cIjogaXNUaGlzU2xpZGVBY3RpdmUgPyAnZmFsc2UnIDogJ3RydWUnXG4gICAgfSwgZWFjaCk7XG4gIH0pLCByZW5kZXJUcmFpbGluZ1NsaWRlcygpKSksIHByb3BzLmFycm93cyAmJiBzaG93TmV4dEFycm93KHByb3BzLCBpbmRleCwgbW92ZVNsaWRlcykpLCBwcm9wcy5pbmRpY2F0b3JzICYmIHNob3dJbmRpY2F0b3JzKHByb3BzLCBpbmRleCwgZ29Ub1NsaWRlLCByZXNwb25zaXZlU2V0dGluZ3MpKTtcbn0pO1xuU2xpZGUuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuXG5leHBvcnQgeyBGYWRlLCBTbGlkZSwgWm9vbSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVhY3Qtc2xpZGVzaG93LWltYWdlLmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/react-slideshow-image/dist/react-slideshow-image.esm.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/react-webcam/dist/react-webcam.js":
/*!********************************************************!*\
  !*** ./node_modules/react-webcam/dist/react-webcam.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory(__webpack_require__(/*! react */ \"(app-client)/./node_modules/next/dist/compiled/react/index.js\"));\n\telse {}\n})(this, function(__WEBPACK_EXTERNAL_MODULE_react__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_620__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_620__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__nested_webpack_require_620__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__nested_webpack_require_620__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__nested_webpack_require_620__.d = function(exports, name, getter) {\n/******/ \t\tif(!__nested_webpack_require_620__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__nested_webpack_require_620__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__nested_webpack_require_620__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __nested_webpack_require_620__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__nested_webpack_require_620__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __nested_webpack_require_620__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__nested_webpack_require_620__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__nested_webpack_require_620__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__nested_webpack_require_620__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__nested_webpack_require_620__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __nested_webpack_require_620__(__nested_webpack_require_620__.s = \"./src/react-webcam.tsx\");\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ \"./src/react-webcam.tsx\":\n/*!******************************!*\\\n  !*** ./src/react-webcam.tsx ***!\n  \\******************************/\n/*! exports provided: default */\n/***/ (function(module, __nested_webpack_exports__, __nested_webpack_require_4284__) {\n\n\"use strict\";\n__nested_webpack_require_4284__.r(__nested_webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_4284__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_4284__.n(react__WEBPACK_IMPORTED_MODULE_0__);\nvar __extends = ( false) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = ( false) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __rest = ( false) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\n\n// polyfill based on https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia\n(function polyfillGetUserMedia() {\n    if (typeof window === 'undefined') {\n        return;\n    }\n    // Older browsers might not implement mediaDevices at all, so we set an empty object first\n    if (navigator.mediaDevices === undefined) {\n        navigator.mediaDevices = {};\n    }\n    // Some browsers partially implement mediaDevices. We can't just assign an object\n    // with getUserMedia as it would overwrite existing properties.\n    // Here, we will just add the getUserMedia property if it's missing.\n    if (navigator.mediaDevices.getUserMedia === undefined) {\n        navigator.mediaDevices.getUserMedia = function (constraints) {\n            // First get ahold of the legacy getUserMedia, if present\n            var getUserMedia = navigator.getUserMedia ||\n                navigator.webkitGetUserMedia ||\n                navigator.mozGetUserMedia ||\n                navigator.msGetUserMedia;\n            // Some browsers just don't implement it - return a rejected promise with an error\n            // to keep a consistent interface\n            if (!getUserMedia) {\n                return Promise.reject(new Error(\"getUserMedia is not implemented in this browser\"));\n            }\n            // Otherwise, wrap the call to the old navigator.getUserMedia with a Promise\n            return new Promise(function (resolve, reject) {\n                getUserMedia.call(navigator, constraints, resolve, reject);\n            });\n        };\n    }\n})();\nfunction hasGetUserMedia() {\n    return !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);\n}\nvar Webcam = /** @class */ (function (_super) {\n    __extends(Webcam, _super);\n    function Webcam(props) {\n        var _this = _super.call(this, props) || this;\n        _this.canvas = null;\n        _this.ctx = null;\n        _this.requestUserMediaId = 0;\n        _this.unmounted = false;\n        _this.state = {\n            hasUserMedia: false\n        };\n        return _this;\n    }\n    Webcam.prototype.componentDidMount = function () {\n        var _a = this, state = _a.state, props = _a.props;\n        this.unmounted = false;\n        if (!hasGetUserMedia()) {\n            props.onUserMediaError(\"getUserMedia not supported\");\n            return;\n        }\n        if (!state.hasUserMedia) {\n            this.requestUserMedia();\n        }\n        if (props.children && typeof props.children != 'function') {\n            console.warn(\"children must be a function\");\n        }\n    };\n    Webcam.prototype.componentDidUpdate = function (nextProps) {\n        var props = this.props;\n        if (!hasGetUserMedia()) {\n            props.onUserMediaError(\"getUserMedia not supported\");\n            return;\n        }\n        var audioConstraintsChanged = JSON.stringify(nextProps.audioConstraints) !==\n            JSON.stringify(props.audioConstraints);\n        var videoConstraintsChanged = JSON.stringify(nextProps.videoConstraints) !==\n            JSON.stringify(props.videoConstraints);\n        var minScreenshotWidthChanged = nextProps.minScreenshotWidth !== props.minScreenshotWidth;\n        var minScreenshotHeightChanged = nextProps.minScreenshotHeight !== props.minScreenshotHeight;\n        if (videoConstraintsChanged ||\n            minScreenshotWidthChanged ||\n            minScreenshotHeightChanged) {\n            this.canvas = null;\n            this.ctx = null;\n        }\n        if (audioConstraintsChanged || videoConstraintsChanged) {\n            this.stopAndCleanup();\n            this.requestUserMedia();\n        }\n    };\n    Webcam.prototype.componentWillUnmount = function () {\n        this.unmounted = true;\n        this.stopAndCleanup();\n    };\n    Webcam.stopMediaStream = function (stream) {\n        if (stream) {\n            if (stream.getVideoTracks && stream.getAudioTracks) {\n                stream.getVideoTracks().map(function (track) {\n                    stream.removeTrack(track);\n                    track.stop();\n                });\n                stream.getAudioTracks().map(function (track) {\n                    stream.removeTrack(track);\n                    track.stop();\n                });\n            }\n            else {\n                stream.stop();\n            }\n        }\n    };\n    Webcam.prototype.stopAndCleanup = function () {\n        var state = this.state;\n        if (state.hasUserMedia) {\n            Webcam.stopMediaStream(this.stream);\n            if (state.src) {\n                window.URL.revokeObjectURL(state.src);\n            }\n        }\n    };\n    Webcam.prototype.getScreenshot = function (screenshotDimensions) {\n        var _a = this, state = _a.state, props = _a.props;\n        if (!state.hasUserMedia)\n            return null;\n        var canvas = this.getCanvas(screenshotDimensions);\n        return (canvas &&\n            canvas.toDataURL(props.screenshotFormat, props.screenshotQuality));\n    };\n    Webcam.prototype.getCanvas = function (screenshotDimensions) {\n        var _a = this, state = _a.state, props = _a.props;\n        if (!this.video) {\n            return null;\n        }\n        if (!state.hasUserMedia || !this.video.videoHeight)\n            return null;\n        if (!this.ctx) {\n            var canvasWidth = this.video.videoWidth;\n            var canvasHeight = this.video.videoHeight;\n            if (!this.props.forceScreenshotSourceSize) {\n                var aspectRatio = canvasWidth / canvasHeight;\n                canvasWidth = props.minScreenshotWidth || this.video.clientWidth;\n                canvasHeight = canvasWidth / aspectRatio;\n                if (props.minScreenshotHeight &&\n                    canvasHeight < props.minScreenshotHeight) {\n                    canvasHeight = props.minScreenshotHeight;\n                    canvasWidth = canvasHeight * aspectRatio;\n                }\n            }\n            this.canvas = document.createElement(\"canvas\");\n            this.canvas.width = (screenshotDimensions === null || screenshotDimensions === void 0 ? void 0 : screenshotDimensions.width) || canvasWidth;\n            this.canvas.height = (screenshotDimensions === null || screenshotDimensions === void 0 ? void 0 : screenshotDimensions.height) || canvasHeight;\n            this.ctx = this.canvas.getContext(\"2d\");\n        }\n        var _b = this, ctx = _b.ctx, canvas = _b.canvas;\n        if (ctx && canvas) {\n            // adjust the height and width of the canvas to the given dimensions\n            canvas.width = (screenshotDimensions === null || screenshotDimensions === void 0 ? void 0 : screenshotDimensions.width) || canvas.width;\n            canvas.height = (screenshotDimensions === null || screenshotDimensions === void 0 ? void 0 : screenshotDimensions.height) || canvas.height;\n            // mirror the screenshot\n            if (props.mirrored) {\n                ctx.translate(canvas.width, 0);\n                ctx.scale(-1, 1);\n            }\n            ctx.imageSmoothingEnabled = props.imageSmoothing;\n            ctx.drawImage(this.video, 0, 0, (screenshotDimensions === null || screenshotDimensions === void 0 ? void 0 : screenshotDimensions.width) || canvas.width, (screenshotDimensions === null || screenshotDimensions === void 0 ? void 0 : screenshotDimensions.height) || canvas.height);\n            // invert mirroring\n            if (props.mirrored) {\n                ctx.scale(-1, 1);\n                ctx.translate(-canvas.width, 0);\n            }\n        }\n        return canvas;\n    };\n    Webcam.prototype.requestUserMedia = function () {\n        var _this = this;\n        var props = this.props;\n        var sourceSelected = function (audioConstraints, videoConstraints) {\n            var constraints = {\n                video: typeof videoConstraints !== \"undefined\" ? videoConstraints : true\n            };\n            if (props.audio) {\n                constraints.audio =\n                    typeof audioConstraints !== \"undefined\" ? audioConstraints : true;\n            }\n            _this.requestUserMediaId++;\n            var myRequestUserMediaId = _this.requestUserMediaId;\n            navigator.mediaDevices\n                .getUserMedia(constraints)\n                .then(function (stream) {\n                if (_this.unmounted || myRequestUserMediaId !== _this.requestUserMediaId) {\n                    Webcam.stopMediaStream(stream);\n                }\n                else {\n                    _this.handleUserMedia(null, stream);\n                }\n            })\n                .catch(function (e) {\n                _this.handleUserMedia(e);\n            });\n        };\n        if (\"mediaDevices\" in navigator) {\n            sourceSelected(props.audioConstraints, props.videoConstraints);\n        }\n        else {\n            var optionalSource_1 = function (id) { return ({ optional: [{ sourceId: id }] }); };\n            var constraintToSourceId_1 = function (constraint) {\n                var deviceId = constraint.deviceId;\n                if (typeof deviceId === \"string\") {\n                    return deviceId;\n                }\n                if (Array.isArray(deviceId) && deviceId.length > 0) {\n                    return deviceId[0];\n                }\n                if (typeof deviceId === \"object\" && deviceId.ideal) {\n                    return deviceId.ideal;\n                }\n                return null;\n            };\n            // @ts-ignore: deprecated api\n            MediaStreamTrack.getSources(function (sources) {\n                var audioSource = null;\n                var videoSource = null;\n                sources.forEach(function (source) {\n                    if (source.kind === \"audio\") {\n                        audioSource = source.id;\n                    }\n                    else if (source.kind === \"video\") {\n                        videoSource = source.id;\n                    }\n                });\n                var audioSourceId = constraintToSourceId_1(props.audioConstraints);\n                if (audioSourceId) {\n                    audioSource = audioSourceId;\n                }\n                var videoSourceId = constraintToSourceId_1(props.videoConstraints);\n                if (videoSourceId) {\n                    videoSource = videoSourceId;\n                }\n                sourceSelected(optionalSource_1(audioSource), optionalSource_1(videoSource));\n            });\n        }\n    };\n    Webcam.prototype.handleUserMedia = function (err, stream) {\n        var props = this.props;\n        if (err || !stream) {\n            this.setState({ hasUserMedia: false });\n            props.onUserMediaError(err);\n            return;\n        }\n        this.stream = stream;\n        try {\n            if (this.video) {\n                this.video.srcObject = stream;\n            }\n            this.setState({ hasUserMedia: true });\n        }\n        catch (error) {\n            this.setState({\n                hasUserMedia: true,\n                src: window.URL.createObjectURL(stream)\n            });\n        }\n        props.onUserMedia(stream);\n    };\n    Webcam.prototype.render = function () {\n        var _this = this;\n        var _a = this, state = _a.state, props = _a.props;\n        var audio = props.audio, forceScreenshotSourceSize = props.forceScreenshotSourceSize, onUserMedia = props.onUserMedia, onUserMediaError = props.onUserMediaError, screenshotFormat = props.screenshotFormat, screenshotQuality = props.screenshotQuality, minScreenshotWidth = props.minScreenshotWidth, minScreenshotHeight = props.minScreenshotHeight, audioConstraints = props.audioConstraints, videoConstraints = props.videoConstraints, imageSmoothing = props.imageSmoothing, mirrored = props.mirrored, _b = props.style, style = _b === void 0 ? {} : _b, children = props.children, rest = __rest(props, [\"audio\", \"forceScreenshotSourceSize\", \"onUserMedia\", \"onUserMediaError\", \"screenshotFormat\", \"screenshotQuality\", \"minScreenshotWidth\", \"minScreenshotHeight\", \"audioConstraints\", \"videoConstraints\", \"imageSmoothing\", \"mirrored\", \"style\", \"children\"]);\n        var videoStyle = mirrored ? __assign(__assign({}, style), { transform: (style.transform || \"\") + \" scaleX(-1)\" }) : style;\n        var childrenProps = {\n            getScreenshot: this.getScreenshot.bind(this),\n        };\n        return (react__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"](react__WEBPACK_IMPORTED_MODULE_0__[\"Fragment\"], null,\n            react__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"](\"video\", __assign({ autoPlay: true, src: state.src, muted: !audio, playsInline: true, ref: function (ref) {\n                    _this.video = ref;\n                }, style: videoStyle }, rest)),\n            children && children(childrenProps)));\n    };\n    Webcam.defaultProps = {\n        audio: false,\n        forceScreenshotSourceSize: false,\n        imageSmoothing: true,\n        mirrored: false,\n        onUserMedia: function () { return undefined; },\n        onUserMediaError: function () { return undefined; },\n        screenshotFormat: \"image/webp\",\n        screenshotQuality: 0.92,\n    };\n    return Webcam;\n}(react__WEBPACK_IMPORTED_MODULE_0__[\"Component\"]));\n/* harmony default export */ __nested_webpack_exports__[\"default\"] = (Webcam);\n\n\n/***/ }),\n\n/***/ \"react\":\n/*!**************************************************************************************!*\\\n  !*** external {\"root\":\"React\",\"commonjs2\":\"react\",\"commonjs\":\"react\",\"amd\":\"react\"} ***!\n  \\**************************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_react__;\n\n/***/ })\n\n/******/ })[\"default\"];\n});\n//# sourceMappingURL=react-webcam.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXdlYmNhbS9kaXN0L3JlYWN0LXdlYmNhbS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLElBQUksSUFBeUQ7QUFDN0QsMkJBQTJCLG1CQUFPLENBQUMsNEVBQU87QUFDMUMsTUFBTSxFQUtvQztBQUMxQyxDQUFDO0FBQ0QscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDhCQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSw4QkFBbUI7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QjtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0I7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCLGVBQWUsOEJBQW1CO0FBQ2xDLG1EQUFtRCwrQkFBK0I7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QjtBQUNBLGlFQUFpRSxpQkFBaUI7QUFDbEY7QUFDQSwwREFBMEQsYUFBYTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCLGdDQUFnQyw4QkFBbUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyw4QkFBbUI7QUFDOUIsa0RBQWtELGdDQUFnQztBQUNsRiwwRUFBMEUsOEJBQW1CLDRCQUE0QixvQkFBb0I7QUFDN0k7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QjtBQUNBLG9DQUFvQyw0QkFBNEI7QUFDaEUsMENBQTBDO0FBQzFDLFdBQVcsOEJBQW1CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4QkFBbUIsa0NBQWtDO0FBQy9EO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsOEJBQW1CLENBQUMsOEJBQW1CO0FBQ3hELFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMEJBQW1CLEVBQUUsK0JBQW1COztBQUVoRTtBQUNBLCtCQUFtQixHQUFHLDBCQUFtQjtBQUN6Qyw4REFBOEQsK0JBQW1CO0FBQ2pGLG1GQUFtRiwrQkFBbUI7QUFDdEcsaUJBQWlCLE1BQWdDO0FBQ2pEO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNELGdCQUFnQixNQUErQjtBQUMvQztBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE1BQTZCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGNBQWM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsVUFBVSxhQUFhLGNBQWMsR0FBRztBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIscUJBQXFCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsb0JBQW9CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdWlCQUF1aUI7QUFDdmlCLHdEQUF3RCxZQUFZLG9EQUFvRDtBQUN4SDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRjtBQUNwRjtBQUNBLGlCQUFpQixxQkFBcUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsbUJBQW1CO0FBQ3RELHdDQUF3QyxtQkFBbUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsNkJBQTZCLDBCQUFtQjs7O0FBR2hELE9BQU87O0FBRVA7QUFDQTtBQUNBLGlCQUFpQixxRUFBcUU7QUFDdEY7QUFDQTtBQUNBOztBQUVBOztBQUVBLE9BQU87O0FBRVAsVUFBVTtBQUNWLENBQUM7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3Qtd2ViY2FtL2Rpc3QvcmVhY3Qtd2ViY2FtLmpzPzhmMTMiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwicmVhY3RcIikpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW1wicmVhY3RcIl0sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiV2ViY2FtXCJdID0gZmFjdG9yeShyZXF1aXJlKFwicmVhY3RcIikpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIldlYmNhbVwiXSA9IGZhY3Rvcnkocm9vdFtcIlJlYWN0XCJdKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfcmVhY3RfXykge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4vKioqKioqLyBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4vKioqKioqLyBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuLyoqKioqKi8gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuLyoqKioqKi8gXHRcdHJldHVybiBucztcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL3NyYy9yZWFjdC13ZWJjYW0udHN4XCIpO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoe1xuXG4vKioqLyBcIi4vc3JjL3JlYWN0LXdlYmNhbS50c3hcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9yZWFjdC13ZWJjYW0udHN4ICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciByZWFjdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgcmVhY3QgKi8gXCJyZWFjdFwiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciByZWFjdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKHJlYWN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xudmFyIF9fZXh0ZW5kcyA9ICh1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fYXNzaWduID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19yZXN0ID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19yZXN0KSB8fCBmdW5jdGlvbiAocywgZSkge1xuICAgIHZhciB0ID0ge307XG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXG4gICAgICAgIHRbcF0gPSBzW3BdO1xuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xuICAgICAgICB9XG4gICAgcmV0dXJuIHQ7XG59O1xuXG4vLyBwb2x5ZmlsbCBiYXNlZCBvbiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTWVkaWFEZXZpY2VzL2dldFVzZXJNZWRpYVxuKGZ1bmN0aW9uIHBvbHlmaWxsR2V0VXNlck1lZGlhKCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIE9sZGVyIGJyb3dzZXJzIG1pZ2h0IG5vdCBpbXBsZW1lbnQgbWVkaWFEZXZpY2VzIGF0IGFsbCwgc28gd2Ugc2V0IGFuIGVtcHR5IG9iamVjdCBmaXJzdFxuICAgIGlmIChuYXZpZ2F0b3IubWVkaWFEZXZpY2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcyA9IHt9O1xuICAgIH1cbiAgICAvLyBTb21lIGJyb3dzZXJzIHBhcnRpYWxseSBpbXBsZW1lbnQgbWVkaWFEZXZpY2VzLiBXZSBjYW4ndCBqdXN0IGFzc2lnbiBhbiBvYmplY3RcbiAgICAvLyB3aXRoIGdldFVzZXJNZWRpYSBhcyBpdCB3b3VsZCBvdmVyd3JpdGUgZXhpc3RpbmcgcHJvcGVydGllcy5cbiAgICAvLyBIZXJlLCB3ZSB3aWxsIGp1c3QgYWRkIHRoZSBnZXRVc2VyTWVkaWEgcHJvcGVydHkgaWYgaXQncyBtaXNzaW5nLlxuICAgIGlmIChuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhID0gZnVuY3Rpb24gKGNvbnN0cmFpbnRzKSB7XG4gICAgICAgICAgICAvLyBGaXJzdCBnZXQgYWhvbGQgb2YgdGhlIGxlZ2FjeSBnZXRVc2VyTWVkaWEsIGlmIHByZXNlbnRcbiAgICAgICAgICAgIHZhciBnZXRVc2VyTWVkaWEgPSBuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhIHx8XG4gICAgICAgICAgICAgICAgbmF2aWdhdG9yLndlYmtpdEdldFVzZXJNZWRpYSB8fFxuICAgICAgICAgICAgICAgIG5hdmlnYXRvci5tb3pHZXRVc2VyTWVkaWEgfHxcbiAgICAgICAgICAgICAgICBuYXZpZ2F0b3IubXNHZXRVc2VyTWVkaWE7XG4gICAgICAgICAgICAvLyBTb21lIGJyb3dzZXJzIGp1c3QgZG9uJ3QgaW1wbGVtZW50IGl0IC0gcmV0dXJuIGEgcmVqZWN0ZWQgcHJvbWlzZSB3aXRoIGFuIGVycm9yXG4gICAgICAgICAgICAvLyB0byBrZWVwIGEgY29uc2lzdGVudCBpbnRlcmZhY2VcbiAgICAgICAgICAgIGlmICghZ2V0VXNlck1lZGlhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcImdldFVzZXJNZWRpYSBpcyBub3QgaW1wbGVtZW50ZWQgaW4gdGhpcyBicm93c2VyXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgd3JhcCB0aGUgY2FsbCB0byB0aGUgb2xkIG5hdmlnYXRvci5nZXRVc2VyTWVkaWEgd2l0aCBhIFByb21pc2VcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgZ2V0VXNlck1lZGlhLmNhbGwobmF2aWdhdG9yLCBjb25zdHJhaW50cywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH1cbn0pKCk7XG5mdW5jdGlvbiBoYXNHZXRVc2VyTWVkaWEoKSB7XG4gICAgcmV0dXJuICEhKG5hdmlnYXRvci5tZWRpYURldmljZXMgJiYgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEpO1xufVxudmFyIFdlYmNhbSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoV2ViY2FtLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFdlYmNhbShwcm9wcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwcm9wcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY2FudmFzID0gbnVsbDtcbiAgICAgICAgX3RoaXMuY3R4ID0gbnVsbDtcbiAgICAgICAgX3RoaXMucmVxdWVzdFVzZXJNZWRpYUlkID0gMDtcbiAgICAgICAgX3RoaXMudW5tb3VudGVkID0gZmFsc2U7XG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgaGFzVXNlck1lZGlhOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFdlYmNhbS5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHN0YXRlID0gX2Euc3RhdGUsIHByb3BzID0gX2EucHJvcHM7XG4gICAgICAgIHRoaXMudW5tb3VudGVkID0gZmFsc2U7XG4gICAgICAgIGlmICghaGFzR2V0VXNlck1lZGlhKCkpIHtcbiAgICAgICAgICAgIHByb3BzLm9uVXNlck1lZGlhRXJyb3IoXCJnZXRVc2VyTWVkaWEgbm90IHN1cHBvcnRlZFwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN0YXRlLmhhc1VzZXJNZWRpYSkge1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0VXNlck1lZGlhKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BzLmNoaWxkcmVuICYmIHR5cGVvZiBwcm9wcy5jaGlsZHJlbiAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJjaGlsZHJlbiBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFdlYmNhbS5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKG5leHRQcm9wcykge1xuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICBpZiAoIWhhc0dldFVzZXJNZWRpYSgpKSB7XG4gICAgICAgICAgICBwcm9wcy5vblVzZXJNZWRpYUVycm9yKFwiZ2V0VXNlck1lZGlhIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGF1ZGlvQ29uc3RyYWludHNDaGFuZ2VkID0gSlNPTi5zdHJpbmdpZnkobmV4dFByb3BzLmF1ZGlvQ29uc3RyYWludHMpICE9PVxuICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkocHJvcHMuYXVkaW9Db25zdHJhaW50cyk7XG4gICAgICAgIHZhciB2aWRlb0NvbnN0cmFpbnRzQ2hhbmdlZCA9IEpTT04uc3RyaW5naWZ5KG5leHRQcm9wcy52aWRlb0NvbnN0cmFpbnRzKSAhPT1cbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHByb3BzLnZpZGVvQ29uc3RyYWludHMpO1xuICAgICAgICB2YXIgbWluU2NyZWVuc2hvdFdpZHRoQ2hhbmdlZCA9IG5leHRQcm9wcy5taW5TY3JlZW5zaG90V2lkdGggIT09IHByb3BzLm1pblNjcmVlbnNob3RXaWR0aDtcbiAgICAgICAgdmFyIG1pblNjcmVlbnNob3RIZWlnaHRDaGFuZ2VkID0gbmV4dFByb3BzLm1pblNjcmVlbnNob3RIZWlnaHQgIT09IHByb3BzLm1pblNjcmVlbnNob3RIZWlnaHQ7XG4gICAgICAgIGlmICh2aWRlb0NvbnN0cmFpbnRzQ2hhbmdlZCB8fFxuICAgICAgICAgICAgbWluU2NyZWVuc2hvdFdpZHRoQ2hhbmdlZCB8fFxuICAgICAgICAgICAgbWluU2NyZWVuc2hvdEhlaWdodENoYW5nZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuY3R4ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXVkaW9Db25zdHJhaW50c0NoYW5nZWQgfHwgdmlkZW9Db25zdHJhaW50c0NoYW5nZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcEFuZENsZWFudXAoKTtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdFVzZXJNZWRpYSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBXZWJjYW0ucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVubW91bnRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc3RvcEFuZENsZWFudXAoKTtcbiAgICB9O1xuICAgIFdlYmNhbS5zdG9wTWVkaWFTdHJlYW0gPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgIGlmIChzdHJlYW0pIHtcbiAgICAgICAgICAgIGlmIChzdHJlYW0uZ2V0VmlkZW9UcmFja3MgJiYgc3RyZWFtLmdldEF1ZGlvVHJhY2tzKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtLmdldFZpZGVvVHJhY2tzKCkubWFwKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW0ucmVtb3ZlVHJhY2sodHJhY2spO1xuICAgICAgICAgICAgICAgICAgICB0cmFjay5zdG9wKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc3RyZWFtLmdldEF1ZGlvVHJhY2tzKCkubWFwKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW0ucmVtb3ZlVHJhY2sodHJhY2spO1xuICAgICAgICAgICAgICAgICAgICB0cmFjay5zdG9wKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdHJlYW0uc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBXZWJjYW0ucHJvdG90eXBlLnN0b3BBbmRDbGVhbnVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgICBpZiAoc3RhdGUuaGFzVXNlck1lZGlhKSB7XG4gICAgICAgICAgICBXZWJjYW0uc3RvcE1lZGlhU3RyZWFtKHRoaXMuc3RyZWFtKTtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5zcmMpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuVVJMLnJldm9rZU9iamVjdFVSTChzdGF0ZS5zcmMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBXZWJjYW0ucHJvdG90eXBlLmdldFNjcmVlbnNob3QgPSBmdW5jdGlvbiAoc2NyZWVuc2hvdERpbWVuc2lvbnMpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgc3RhdGUgPSBfYS5zdGF0ZSwgcHJvcHMgPSBfYS5wcm9wcztcbiAgICAgICAgaWYgKCFzdGF0ZS5oYXNVc2VyTWVkaWEpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuZ2V0Q2FudmFzKHNjcmVlbnNob3REaW1lbnNpb25zKTtcbiAgICAgICAgcmV0dXJuIChjYW52YXMgJiZcbiAgICAgICAgICAgIGNhbnZhcy50b0RhdGFVUkwocHJvcHMuc2NyZWVuc2hvdEZvcm1hdCwgcHJvcHMuc2NyZWVuc2hvdFF1YWxpdHkpKTtcbiAgICB9O1xuICAgIFdlYmNhbS5wcm90b3R5cGUuZ2V0Q2FudmFzID0gZnVuY3Rpb24gKHNjcmVlbnNob3REaW1lbnNpb25zKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHN0YXRlID0gX2Euc3RhdGUsIHByb3BzID0gX2EucHJvcHM7XG4gICAgICAgIGlmICghdGhpcy52aWRlbykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdGF0ZS5oYXNVc2VyTWVkaWEgfHwgIXRoaXMudmlkZW8udmlkZW9IZWlnaHQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKCF0aGlzLmN0eCkge1xuICAgICAgICAgICAgdmFyIGNhbnZhc1dpZHRoID0gdGhpcy52aWRlby52aWRlb1dpZHRoO1xuICAgICAgICAgICAgdmFyIGNhbnZhc0hlaWdodCA9IHRoaXMudmlkZW8udmlkZW9IZWlnaHQ7XG4gICAgICAgICAgICBpZiAoIXRoaXMucHJvcHMuZm9yY2VTY3JlZW5zaG90U291cmNlU2l6ZSkge1xuICAgICAgICAgICAgICAgIHZhciBhc3BlY3RSYXRpbyA9IGNhbnZhc1dpZHRoIC8gY2FudmFzSGVpZ2h0O1xuICAgICAgICAgICAgICAgIGNhbnZhc1dpZHRoID0gcHJvcHMubWluU2NyZWVuc2hvdFdpZHRoIHx8IHRoaXMudmlkZW8uY2xpZW50V2lkdGg7XG4gICAgICAgICAgICAgICAgY2FudmFzSGVpZ2h0ID0gY2FudmFzV2lkdGggLyBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgICAgICBpZiAocHJvcHMubWluU2NyZWVuc2hvdEhlaWdodCAmJlxuICAgICAgICAgICAgICAgICAgICBjYW52YXNIZWlnaHQgPCBwcm9wcy5taW5TY3JlZW5zaG90SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbnZhc0hlaWdodCA9IHByb3BzLm1pblNjcmVlbnNob3RIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGNhbnZhc1dpZHRoID0gY2FudmFzSGVpZ2h0ICogYXNwZWN0UmF0aW87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgICAgICAgdGhpcy5jYW52YXMud2lkdGggPSAoc2NyZWVuc2hvdERpbWVuc2lvbnMgPT09IG51bGwgfHwgc2NyZWVuc2hvdERpbWVuc2lvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNjcmVlbnNob3REaW1lbnNpb25zLndpZHRoKSB8fCBjYW52YXNXaWR0aDtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IChzY3JlZW5zaG90RGltZW5zaW9ucyA9PT0gbnVsbCB8fCBzY3JlZW5zaG90RGltZW5zaW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2NyZWVuc2hvdERpbWVuc2lvbnMuaGVpZ2h0KSB8fCBjYW52YXNIZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLmN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2IgPSB0aGlzLCBjdHggPSBfYi5jdHgsIGNhbnZhcyA9IF9iLmNhbnZhcztcbiAgICAgICAgaWYgKGN0eCAmJiBjYW52YXMpIHtcbiAgICAgICAgICAgIC8vIGFkanVzdCB0aGUgaGVpZ2h0IGFuZCB3aWR0aCBvZiB0aGUgY2FudmFzIHRvIHRoZSBnaXZlbiBkaW1lbnNpb25zXG4gICAgICAgICAgICBjYW52YXMud2lkdGggPSAoc2NyZWVuc2hvdERpbWVuc2lvbnMgPT09IG51bGwgfHwgc2NyZWVuc2hvdERpbWVuc2lvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNjcmVlbnNob3REaW1lbnNpb25zLndpZHRoKSB8fCBjYW52YXMud2lkdGg7XG4gICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gKHNjcmVlbnNob3REaW1lbnNpb25zID09PSBudWxsIHx8IHNjcmVlbnNob3REaW1lbnNpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY3JlZW5zaG90RGltZW5zaW9ucy5oZWlnaHQpIHx8IGNhbnZhcy5oZWlnaHQ7XG4gICAgICAgICAgICAvLyBtaXJyb3IgdGhlIHNjcmVlbnNob3RcbiAgICAgICAgICAgIGlmIChwcm9wcy5taXJyb3JlZCkge1xuICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoY2FudmFzLndpZHRoLCAwKTtcbiAgICAgICAgICAgICAgICBjdHguc2NhbGUoLTEsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IHByb3BzLmltYWdlU21vb3RoaW5nO1xuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLnZpZGVvLCAwLCAwLCAoc2NyZWVuc2hvdERpbWVuc2lvbnMgPT09IG51bGwgfHwgc2NyZWVuc2hvdERpbWVuc2lvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNjcmVlbnNob3REaW1lbnNpb25zLndpZHRoKSB8fCBjYW52YXMud2lkdGgsIChzY3JlZW5zaG90RGltZW5zaW9ucyA9PT0gbnVsbCB8fCBzY3JlZW5zaG90RGltZW5zaW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2NyZWVuc2hvdERpbWVuc2lvbnMuaGVpZ2h0KSB8fCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICAgIC8vIGludmVydCBtaXJyb3JpbmdcbiAgICAgICAgICAgIGlmIChwcm9wcy5taXJyb3JlZCkge1xuICAgICAgICAgICAgICAgIGN0eC5zY2FsZSgtMSwgMSk7XG4gICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgtY2FudmFzLndpZHRoLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FudmFzO1xuICAgIH07XG4gICAgV2ViY2FtLnByb3RvdHlwZS5yZXF1ZXN0VXNlck1lZGlhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICB2YXIgc291cmNlU2VsZWN0ZWQgPSBmdW5jdGlvbiAoYXVkaW9Db25zdHJhaW50cywgdmlkZW9Db25zdHJhaW50cykge1xuICAgICAgICAgICAgdmFyIGNvbnN0cmFpbnRzID0ge1xuICAgICAgICAgICAgICAgIHZpZGVvOiB0eXBlb2YgdmlkZW9Db25zdHJhaW50cyAhPT0gXCJ1bmRlZmluZWRcIiA/IHZpZGVvQ29uc3RyYWludHMgOiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHByb3BzLmF1ZGlvKSB7XG4gICAgICAgICAgICAgICAgY29uc3RyYWludHMuYXVkaW8gPVxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgYXVkaW9Db25zdHJhaW50cyAhPT0gXCJ1bmRlZmluZWRcIiA/IGF1ZGlvQ29uc3RyYWludHMgOiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMucmVxdWVzdFVzZXJNZWRpYUlkKys7XG4gICAgICAgICAgICB2YXIgbXlSZXF1ZXN0VXNlck1lZGlhSWQgPSBfdGhpcy5yZXF1ZXN0VXNlck1lZGlhSWQ7XG4gICAgICAgICAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzXG4gICAgICAgICAgICAgICAgLmdldFVzZXJNZWRpYShjb25zdHJhaW50cylcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnVubW91bnRlZCB8fCBteVJlcXVlc3RVc2VyTWVkaWFJZCAhPT0gX3RoaXMucmVxdWVzdFVzZXJNZWRpYUlkKSB7XG4gICAgICAgICAgICAgICAgICAgIFdlYmNhbS5zdG9wTWVkaWFTdHJlYW0oc3RyZWFtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmhhbmRsZVVzZXJNZWRpYShudWxsLCBzdHJlYW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuaGFuZGxlVXNlck1lZGlhKGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChcIm1lZGlhRGV2aWNlc1wiIGluIG5hdmlnYXRvcikge1xuICAgICAgICAgICAgc291cmNlU2VsZWN0ZWQocHJvcHMuYXVkaW9Db25zdHJhaW50cywgcHJvcHMudmlkZW9Db25zdHJhaW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9uYWxTb3VyY2VfMSA9IGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gKHsgb3B0aW9uYWw6IFt7IHNvdXJjZUlkOiBpZCB9XSB9KTsgfTtcbiAgICAgICAgICAgIHZhciBjb25zdHJhaW50VG9Tb3VyY2VJZF8xID0gZnVuY3Rpb24gKGNvbnN0cmFpbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGV2aWNlSWQgPSBjb25zdHJhaW50LmRldmljZUlkO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGV2aWNlSWQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRldmljZUlkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkZXZpY2VJZCkgJiYgZGV2aWNlSWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGV2aWNlSWRbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGV2aWNlSWQgPT09IFwib2JqZWN0XCIgJiYgZGV2aWNlSWQuaWRlYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRldmljZUlkLmlkZWFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlOiBkZXByZWNhdGVkIGFwaVxuICAgICAgICAgICAgTWVkaWFTdHJlYW1UcmFjay5nZXRTb3VyY2VzKGZ1bmN0aW9uIChzb3VyY2VzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF1ZGlvU291cmNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgdmlkZW9Tb3VyY2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIHNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2Uua2luZCA9PT0gXCJhdWRpb1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdWRpb1NvdXJjZSA9IHNvdXJjZS5pZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzb3VyY2Uua2luZCA9PT0gXCJ2aWRlb1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aWRlb1NvdXJjZSA9IHNvdXJjZS5pZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhciBhdWRpb1NvdXJjZUlkID0gY29uc3RyYWludFRvU291cmNlSWRfMShwcm9wcy5hdWRpb0NvbnN0cmFpbnRzKTtcbiAgICAgICAgICAgICAgICBpZiAoYXVkaW9Tb3VyY2VJZCkge1xuICAgICAgICAgICAgICAgICAgICBhdWRpb1NvdXJjZSA9IGF1ZGlvU291cmNlSWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB2aWRlb1NvdXJjZUlkID0gY29uc3RyYWludFRvU291cmNlSWRfMShwcm9wcy52aWRlb0NvbnN0cmFpbnRzKTtcbiAgICAgICAgICAgICAgICBpZiAodmlkZW9Tb3VyY2VJZCkge1xuICAgICAgICAgICAgICAgICAgICB2aWRlb1NvdXJjZSA9IHZpZGVvU291cmNlSWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNvdXJjZVNlbGVjdGVkKG9wdGlvbmFsU291cmNlXzEoYXVkaW9Tb3VyY2UpLCBvcHRpb25hbFNvdXJjZV8xKHZpZGVvU291cmNlKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgV2ViY2FtLnByb3RvdHlwZS5oYW5kbGVVc2VyTWVkaWEgPSBmdW5jdGlvbiAoZXJyLCBzdHJlYW0pIHtcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgaWYgKGVyciB8fCAhc3RyZWFtKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgaGFzVXNlck1lZGlhOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIHByb3BzLm9uVXNlck1lZGlhRXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0cmVhbSA9IHN0cmVhbTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnZpZGVvKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aWRlby5zcmNPYmplY3QgPSBzdHJlYW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgaGFzVXNlck1lZGlhOiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgaGFzVXNlck1lZGlhOiB0cnVlLFxuICAgICAgICAgICAgICAgIHNyYzogd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwoc3RyZWFtKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcHJvcHMub25Vc2VyTWVkaWEoc3RyZWFtKTtcbiAgICB9O1xuICAgIFdlYmNhbS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBzdGF0ZSA9IF9hLnN0YXRlLCBwcm9wcyA9IF9hLnByb3BzO1xuICAgICAgICB2YXIgYXVkaW8gPSBwcm9wcy5hdWRpbywgZm9yY2VTY3JlZW5zaG90U291cmNlU2l6ZSA9IHByb3BzLmZvcmNlU2NyZWVuc2hvdFNvdXJjZVNpemUsIG9uVXNlck1lZGlhID0gcHJvcHMub25Vc2VyTWVkaWEsIG9uVXNlck1lZGlhRXJyb3IgPSBwcm9wcy5vblVzZXJNZWRpYUVycm9yLCBzY3JlZW5zaG90Rm9ybWF0ID0gcHJvcHMuc2NyZWVuc2hvdEZvcm1hdCwgc2NyZWVuc2hvdFF1YWxpdHkgPSBwcm9wcy5zY3JlZW5zaG90UXVhbGl0eSwgbWluU2NyZWVuc2hvdFdpZHRoID0gcHJvcHMubWluU2NyZWVuc2hvdFdpZHRoLCBtaW5TY3JlZW5zaG90SGVpZ2h0ID0gcHJvcHMubWluU2NyZWVuc2hvdEhlaWdodCwgYXVkaW9Db25zdHJhaW50cyA9IHByb3BzLmF1ZGlvQ29uc3RyYWludHMsIHZpZGVvQ29uc3RyYWludHMgPSBwcm9wcy52aWRlb0NvbnN0cmFpbnRzLCBpbWFnZVNtb290aGluZyA9IHByb3BzLmltYWdlU21vb3RoaW5nLCBtaXJyb3JlZCA9IHByb3BzLm1pcnJvcmVkLCBfYiA9IHByb3BzLnN0eWxlLCBzdHlsZSA9IF9iID09PSB2b2lkIDAgPyB7fSA6IF9iLCBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLCByZXN0ID0gX19yZXN0KHByb3BzLCBbXCJhdWRpb1wiLCBcImZvcmNlU2NyZWVuc2hvdFNvdXJjZVNpemVcIiwgXCJvblVzZXJNZWRpYVwiLCBcIm9uVXNlck1lZGlhRXJyb3JcIiwgXCJzY3JlZW5zaG90Rm9ybWF0XCIsIFwic2NyZWVuc2hvdFF1YWxpdHlcIiwgXCJtaW5TY3JlZW5zaG90V2lkdGhcIiwgXCJtaW5TY3JlZW5zaG90SGVpZ2h0XCIsIFwiYXVkaW9Db25zdHJhaW50c1wiLCBcInZpZGVvQ29uc3RyYWludHNcIiwgXCJpbWFnZVNtb290aGluZ1wiLCBcIm1pcnJvcmVkXCIsIFwic3R5bGVcIiwgXCJjaGlsZHJlblwiXSk7XG4gICAgICAgIHZhciB2aWRlb1N0eWxlID0gbWlycm9yZWQgPyBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgc3R5bGUpLCB7IHRyYW5zZm9ybTogKHN0eWxlLnRyYW5zZm9ybSB8fCBcIlwiKSArIFwiIHNjYWxlWCgtMSlcIiB9KSA6IHN0eWxlO1xuICAgICAgICB2YXIgY2hpbGRyZW5Qcm9wcyA9IHtcbiAgICAgICAgICAgIGdldFNjcmVlbnNob3Q6IHRoaXMuZ2V0U2NyZWVuc2hvdC5iaW5kKHRoaXMpLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gKHJlYWN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJjcmVhdGVFbGVtZW50XCJdKHJlYWN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJGcmFnbWVudFwiXSwgbnVsbCxcbiAgICAgICAgICAgIHJlYWN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJjcmVhdGVFbGVtZW50XCJdKFwidmlkZW9cIiwgX19hc3NpZ24oeyBhdXRvUGxheTogdHJ1ZSwgc3JjOiBzdGF0ZS5zcmMsIG11dGVkOiAhYXVkaW8sIHBsYXlzSW5saW5lOiB0cnVlLCByZWY6IGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudmlkZW8gPSByZWY7XG4gICAgICAgICAgICAgICAgfSwgc3R5bGU6IHZpZGVvU3R5bGUgfSwgcmVzdCkpLFxuICAgICAgICAgICAgY2hpbGRyZW4gJiYgY2hpbGRyZW4oY2hpbGRyZW5Qcm9wcykpKTtcbiAgICB9O1xuICAgIFdlYmNhbS5kZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIGF1ZGlvOiBmYWxzZSxcbiAgICAgICAgZm9yY2VTY3JlZW5zaG90U291cmNlU2l6ZTogZmFsc2UsXG4gICAgICAgIGltYWdlU21vb3RoaW5nOiB0cnVlLFxuICAgICAgICBtaXJyb3JlZDogZmFsc2UsXG4gICAgICAgIG9uVXNlck1lZGlhOiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmRlZmluZWQ7IH0sXG4gICAgICAgIG9uVXNlck1lZGlhRXJyb3I6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSxcbiAgICAgICAgc2NyZWVuc2hvdEZvcm1hdDogXCJpbWFnZS93ZWJwXCIsXG4gICAgICAgIHNjcmVlbnNob3RRdWFsaXR5OiAwLjkyLFxuICAgIH07XG4gICAgcmV0dXJuIFdlYmNhbTtcbn0ocmVhY3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkNvbXBvbmVudFwiXSkpO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChXZWJjYW0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcInJlYWN0XCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiBleHRlcm5hbCB7XCJyb290XCI6XCJSZWFjdFwiLFwiY29tbW9uanMyXCI6XCJyZWFjdFwiLFwiY29tbW9uanNcIjpcInJlYWN0XCIsXCJhbWRcIjpcInJlYWN0XCJ9ICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfcmVhY3RfXztcblxuLyoqKi8gfSlcblxuLyoqKioqKi8gfSlbXCJkZWZhdWx0XCJdO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWFjdC13ZWJjYW0uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/react-webcam/dist/react-webcam.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js":
/*!*************************************************************************!*\
  !*** ./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/**\r\n * A collection of shims that provide minimal functionality of the ES6 collections.\r\n *\r\n * These implementations are not meant to be used outside of the ResizeObserver\r\n * modules as they cover only a limited range of use cases.\r\n */\r\n/* eslint-disable require-jsdoc, valid-jsdoc */\r\nvar MapShim = (function () {\r\n    if (typeof Map !== 'undefined') {\r\n        return Map;\r\n    }\r\n    /**\r\n     * Returns index in provided array that matches the specified key.\r\n     *\r\n     * @param {Array<Array>} arr\r\n     * @param {*} key\r\n     * @returns {number}\r\n     */\r\n    function getIndex(arr, key) {\r\n        var result = -1;\r\n        arr.some(function (entry, index) {\r\n            if (entry[0] === key) {\r\n                result = index;\r\n                return true;\r\n            }\r\n            return false;\r\n        });\r\n        return result;\r\n    }\r\n    return /** @class */ (function () {\r\n        function class_1() {\r\n            this.__entries__ = [];\r\n        }\r\n        Object.defineProperty(class_1.prototype, \"size\", {\r\n            /**\r\n             * @returns {boolean}\r\n             */\r\n            get: function () {\r\n                return this.__entries__.length;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        /**\r\n         * @param {*} key\r\n         * @returns {*}\r\n         */\r\n        class_1.prototype.get = function (key) {\r\n            var index = getIndex(this.__entries__, key);\r\n            var entry = this.__entries__[index];\r\n            return entry && entry[1];\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @param {*} value\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.set = function (key, value) {\r\n            var index = getIndex(this.__entries__, key);\r\n            if (~index) {\r\n                this.__entries__[index][1] = value;\r\n            }\r\n            else {\r\n                this.__entries__.push([key, value]);\r\n            }\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.delete = function (key) {\r\n            var entries = this.__entries__;\r\n            var index = getIndex(entries, key);\r\n            if (~index) {\r\n                entries.splice(index, 1);\r\n            }\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.has = function (key) {\r\n            return !!~getIndex(this.__entries__, key);\r\n        };\r\n        /**\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.clear = function () {\r\n            this.__entries__.splice(0);\r\n        };\r\n        /**\r\n         * @param {Function} callback\r\n         * @param {*} [ctx=null]\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.forEach = function (callback, ctx) {\r\n            if (ctx === void 0) { ctx = null; }\r\n            for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {\r\n                var entry = _a[_i];\r\n                callback.call(ctx, entry[1], entry[0]);\r\n            }\r\n        };\r\n        return class_1;\r\n    }());\r\n})();\n\n/**\r\n * Detects whether window and document objects are available in current environment.\r\n */\r\nvar isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;\n\n// Returns global object of a current environment.\r\nvar global$1 = (function () {\r\n    if (typeof __webpack_require__.g !== 'undefined' && __webpack_require__.g.Math === Math) {\r\n        return __webpack_require__.g;\r\n    }\r\n    if (typeof self !== 'undefined' && self.Math === Math) {\r\n        return self;\r\n    }\r\n    if (typeof window !== 'undefined' && window.Math === Math) {\r\n        return window;\r\n    }\r\n    // eslint-disable-next-line no-new-func\r\n    return Function('return this')();\r\n})();\n\n/**\r\n * A shim for the requestAnimationFrame which falls back to the setTimeout if\r\n * first one is not supported.\r\n *\r\n * @returns {number} Requests' identifier.\r\n */\r\nvar requestAnimationFrame$1 = (function () {\r\n    if (typeof requestAnimationFrame === 'function') {\r\n        // It's required to use a bounded function because IE sometimes throws\r\n        // an \"Invalid calling object\" error if rAF is invoked without the global\r\n        // object on the left hand side.\r\n        return requestAnimationFrame.bind(global$1);\r\n    }\r\n    return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };\r\n})();\n\n// Defines minimum timeout before adding a trailing call.\r\nvar trailingTimeout = 2;\r\n/**\r\n * Creates a wrapper function which ensures that provided callback will be\r\n * invoked only once during the specified delay period.\r\n *\r\n * @param {Function} callback - Function to be invoked after the delay period.\r\n * @param {number} delay - Delay after which to invoke callback.\r\n * @returns {Function}\r\n */\r\nfunction throttle (callback, delay) {\r\n    var leadingCall = false, trailingCall = false, lastCallTime = 0;\r\n    /**\r\n     * Invokes the original callback function and schedules new invocation if\r\n     * the \"proxy\" was called during current request.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function resolvePending() {\r\n        if (leadingCall) {\r\n            leadingCall = false;\r\n            callback();\r\n        }\r\n        if (trailingCall) {\r\n            proxy();\r\n        }\r\n    }\r\n    /**\r\n     * Callback invoked after the specified delay. It will further postpone\r\n     * invocation of the original function delegating it to the\r\n     * requestAnimationFrame.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function timeoutCallback() {\r\n        requestAnimationFrame$1(resolvePending);\r\n    }\r\n    /**\r\n     * Schedules invocation of the original function.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function proxy() {\r\n        var timeStamp = Date.now();\r\n        if (leadingCall) {\r\n            // Reject immediately following calls.\r\n            if (timeStamp - lastCallTime < trailingTimeout) {\r\n                return;\r\n            }\r\n            // Schedule new call to be in invoked when the pending one is resolved.\r\n            // This is important for \"transitions\" which never actually start\r\n            // immediately so there is a chance that we might miss one if change\r\n            // happens amids the pending invocation.\r\n            trailingCall = true;\r\n        }\r\n        else {\r\n            leadingCall = true;\r\n            trailingCall = false;\r\n            setTimeout(timeoutCallback, delay);\r\n        }\r\n        lastCallTime = timeStamp;\r\n    }\r\n    return proxy;\r\n}\n\n// Minimum delay before invoking the update of observers.\r\nvar REFRESH_DELAY = 20;\r\n// A list of substrings of CSS properties used to find transition events that\r\n// might affect dimensions of observed elements.\r\nvar transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];\r\n// Check if MutationObserver is available.\r\nvar mutationObserverSupported = typeof MutationObserver !== 'undefined';\r\n/**\r\n * Singleton controller class which handles updates of ResizeObserver instances.\r\n */\r\nvar ResizeObserverController = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserverController.\r\n     *\r\n     * @private\r\n     */\r\n    function ResizeObserverController() {\r\n        /**\r\n         * Indicates whether DOM listeners have been added.\r\n         *\r\n         * @private {boolean}\r\n         */\r\n        this.connected_ = false;\r\n        /**\r\n         * Tells that controller has subscribed for Mutation Events.\r\n         *\r\n         * @private {boolean}\r\n         */\r\n        this.mutationEventsAdded_ = false;\r\n        /**\r\n         * Keeps reference to the instance of MutationObserver.\r\n         *\r\n         * @private {MutationObserver}\r\n         */\r\n        this.mutationsObserver_ = null;\r\n        /**\r\n         * A list of connected observers.\r\n         *\r\n         * @private {Array<ResizeObserverSPI>}\r\n         */\r\n        this.observers_ = [];\r\n        this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);\r\n        this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);\r\n    }\r\n    /**\r\n     * Adds observer to observers list.\r\n     *\r\n     * @param {ResizeObserverSPI} observer - Observer to be added.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.addObserver = function (observer) {\r\n        if (!~this.observers_.indexOf(observer)) {\r\n            this.observers_.push(observer);\r\n        }\r\n        // Add listeners if they haven't been added yet.\r\n        if (!this.connected_) {\r\n            this.connect_();\r\n        }\r\n    };\r\n    /**\r\n     * Removes observer from observers list.\r\n     *\r\n     * @param {ResizeObserverSPI} observer - Observer to be removed.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.removeObserver = function (observer) {\r\n        var observers = this.observers_;\r\n        var index = observers.indexOf(observer);\r\n        // Remove observer if it's present in registry.\r\n        if (~index) {\r\n            observers.splice(index, 1);\r\n        }\r\n        // Remove listeners if controller has no connected observers.\r\n        if (!observers.length && this.connected_) {\r\n            this.disconnect_();\r\n        }\r\n    };\r\n    /**\r\n     * Invokes the update of observers. It will continue running updates insofar\r\n     * it detects changes.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.refresh = function () {\r\n        var changesDetected = this.updateObservers_();\r\n        // Continue running updates if changes have been detected as there might\r\n        // be future ones caused by CSS transitions.\r\n        if (changesDetected) {\r\n            this.refresh();\r\n        }\r\n    };\r\n    /**\r\n     * Updates every observer from observers list and notifies them of queued\r\n     * entries.\r\n     *\r\n     * @private\r\n     * @returns {boolean} Returns \"true\" if any observer has detected changes in\r\n     *      dimensions of it's elements.\r\n     */\r\n    ResizeObserverController.prototype.updateObservers_ = function () {\r\n        // Collect observers that have active observations.\r\n        var activeObservers = this.observers_.filter(function (observer) {\r\n            return observer.gatherActive(), observer.hasActive();\r\n        });\r\n        // Deliver notifications in a separate cycle in order to avoid any\r\n        // collisions between observers, e.g. when multiple instances of\r\n        // ResizeObserver are tracking the same element and the callback of one\r\n        // of them changes content dimensions of the observed target. Sometimes\r\n        // this may result in notifications being blocked for the rest of observers.\r\n        activeObservers.forEach(function (observer) { return observer.broadcastActive(); });\r\n        return activeObservers.length > 0;\r\n    };\r\n    /**\r\n     * Initializes DOM listeners.\r\n     *\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.connect_ = function () {\r\n        // Do nothing if running in a non-browser environment or if listeners\r\n        // have been already added.\r\n        if (!isBrowser || this.connected_) {\r\n            return;\r\n        }\r\n        // Subscription to the \"Transitionend\" event is used as a workaround for\r\n        // delayed transitions. This way it's possible to capture at least the\r\n        // final state of an element.\r\n        document.addEventListener('transitionend', this.onTransitionEnd_);\r\n        window.addEventListener('resize', this.refresh);\r\n        if (mutationObserverSupported) {\r\n            this.mutationsObserver_ = new MutationObserver(this.refresh);\r\n            this.mutationsObserver_.observe(document, {\r\n                attributes: true,\r\n                childList: true,\r\n                characterData: true,\r\n                subtree: true\r\n            });\r\n        }\r\n        else {\r\n            document.addEventListener('DOMSubtreeModified', this.refresh);\r\n            this.mutationEventsAdded_ = true;\r\n        }\r\n        this.connected_ = true;\r\n    };\r\n    /**\r\n     * Removes DOM listeners.\r\n     *\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.disconnect_ = function () {\r\n        // Do nothing if running in a non-browser environment or if listeners\r\n        // have been already removed.\r\n        if (!isBrowser || !this.connected_) {\r\n            return;\r\n        }\r\n        document.removeEventListener('transitionend', this.onTransitionEnd_);\r\n        window.removeEventListener('resize', this.refresh);\r\n        if (this.mutationsObserver_) {\r\n            this.mutationsObserver_.disconnect();\r\n        }\r\n        if (this.mutationEventsAdded_) {\r\n            document.removeEventListener('DOMSubtreeModified', this.refresh);\r\n        }\r\n        this.mutationsObserver_ = null;\r\n        this.mutationEventsAdded_ = false;\r\n        this.connected_ = false;\r\n    };\r\n    /**\r\n     * \"Transitionend\" event handler.\r\n     *\r\n     * @private\r\n     * @param {TransitionEvent} event\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {\r\n        var _b = _a.propertyName, propertyName = _b === void 0 ? '' : _b;\r\n        // Detect whether transition may affect dimensions of an element.\r\n        var isReflowProperty = transitionKeys.some(function (key) {\r\n            return !!~propertyName.indexOf(key);\r\n        });\r\n        if (isReflowProperty) {\r\n            this.refresh();\r\n        }\r\n    };\r\n    /**\r\n     * Returns instance of the ResizeObserverController.\r\n     *\r\n     * @returns {ResizeObserverController}\r\n     */\r\n    ResizeObserverController.getInstance = function () {\r\n        if (!this.instance_) {\r\n            this.instance_ = new ResizeObserverController();\r\n        }\r\n        return this.instance_;\r\n    };\r\n    /**\r\n     * Holds reference to the controller's instance.\r\n     *\r\n     * @private {ResizeObserverController}\r\n     */\r\n    ResizeObserverController.instance_ = null;\r\n    return ResizeObserverController;\r\n}());\n\n/**\r\n * Defines non-writable/enumerable properties of the provided target object.\r\n *\r\n * @param {Object} target - Object for which to define properties.\r\n * @param {Object} props - Properties to be defined.\r\n * @returns {Object} Target object.\r\n */\r\nvar defineConfigurable = (function (target, props) {\r\n    for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {\r\n        var key = _a[_i];\r\n        Object.defineProperty(target, key, {\r\n            value: props[key],\r\n            enumerable: false,\r\n            writable: false,\r\n            configurable: true\r\n        });\r\n    }\r\n    return target;\r\n});\n\n/**\r\n * Returns the global object associated with provided element.\r\n *\r\n * @param {Object} target\r\n * @returns {Object}\r\n */\r\nvar getWindowOf = (function (target) {\r\n    // Assume that the element is an instance of Node, which means that it\r\n    // has the \"ownerDocument\" property from which we can retrieve a\r\n    // corresponding global object.\r\n    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;\r\n    // Return the local global object if it's not possible extract one from\r\n    // provided element.\r\n    return ownerGlobal || global$1;\r\n});\n\n// Placeholder of an empty content rectangle.\r\nvar emptyRect = createRectInit(0, 0, 0, 0);\r\n/**\r\n * Converts provided string to a number.\r\n *\r\n * @param {number|string} value\r\n * @returns {number}\r\n */\r\nfunction toFloat(value) {\r\n    return parseFloat(value) || 0;\r\n}\r\n/**\r\n * Extracts borders size from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @param {...string} positions - Borders positions (top, right, ...)\r\n * @returns {number}\r\n */\r\nfunction getBordersSize(styles) {\r\n    var positions = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        positions[_i - 1] = arguments[_i];\r\n    }\r\n    return positions.reduce(function (size, position) {\r\n        var value = styles['border-' + position + '-width'];\r\n        return size + toFloat(value);\r\n    }, 0);\r\n}\r\n/**\r\n * Extracts paddings sizes from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @returns {Object} Paddings box.\r\n */\r\nfunction getPaddings(styles) {\r\n    var positions = ['top', 'right', 'bottom', 'left'];\r\n    var paddings = {};\r\n    for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {\r\n        var position = positions_1[_i];\r\n        var value = styles['padding-' + position];\r\n        paddings[position] = toFloat(value);\r\n    }\r\n    return paddings;\r\n}\r\n/**\r\n * Calculates content rectangle of provided SVG element.\r\n *\r\n * @param {SVGGraphicsElement} target - Element content rectangle of which needs\r\n *      to be calculated.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getSVGContentRect(target) {\r\n    var bbox = target.getBBox();\r\n    return createRectInit(0, 0, bbox.width, bbox.height);\r\n}\r\n/**\r\n * Calculates content rectangle of provided HTMLElement.\r\n *\r\n * @param {HTMLElement} target - Element for which to calculate the content rectangle.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getHTMLElementContentRect(target) {\r\n    // Client width & height properties can't be\r\n    // used exclusively as they provide rounded values.\r\n    var clientWidth = target.clientWidth, clientHeight = target.clientHeight;\r\n    // By this condition we can catch all non-replaced inline, hidden and\r\n    // detached elements. Though elements with width & height properties less\r\n    // than 0.5 will be discarded as well.\r\n    //\r\n    // Without it we would need to implement separate methods for each of\r\n    // those cases and it's not possible to perform a precise and performance\r\n    // effective test for hidden elements. E.g. even jQuery's ':visible' filter\r\n    // gives wrong results for elements with width & height less than 0.5.\r\n    if (!clientWidth && !clientHeight) {\r\n        return emptyRect;\r\n    }\r\n    var styles = getWindowOf(target).getComputedStyle(target);\r\n    var paddings = getPaddings(styles);\r\n    var horizPad = paddings.left + paddings.right;\r\n    var vertPad = paddings.top + paddings.bottom;\r\n    // Computed styles of width & height are being used because they are the\r\n    // only dimensions available to JS that contain non-rounded values. It could\r\n    // be possible to utilize the getBoundingClientRect if only it's data wasn't\r\n    // affected by CSS transformations let alone paddings, borders and scroll bars.\r\n    var width = toFloat(styles.width), height = toFloat(styles.height);\r\n    // Width & height include paddings and borders when the 'border-box' box\r\n    // model is applied (except for IE).\r\n    if (styles.boxSizing === 'border-box') {\r\n        // Following conditions are required to handle Internet Explorer which\r\n        // doesn't include paddings and borders to computed CSS dimensions.\r\n        //\r\n        // We can say that if CSS dimensions + paddings are equal to the \"client\"\r\n        // properties then it's either IE, and thus we don't need to subtract\r\n        // anything, or an element merely doesn't have paddings/borders styles.\r\n        if (Math.round(width + horizPad) !== clientWidth) {\r\n            width -= getBordersSize(styles, 'left', 'right') + horizPad;\r\n        }\r\n        if (Math.round(height + vertPad) !== clientHeight) {\r\n            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;\r\n        }\r\n    }\r\n    // Following steps can't be applied to the document's root element as its\r\n    // client[Width/Height] properties represent viewport area of the window.\r\n    // Besides, it's as well not necessary as the <html> itself neither has\r\n    // rendered scroll bars nor it can be clipped.\r\n    if (!isDocumentElement(target)) {\r\n        // In some browsers (only in Firefox, actually) CSS width & height\r\n        // include scroll bars size which can be removed at this step as scroll\r\n        // bars are the only difference between rounded dimensions + paddings\r\n        // and \"client\" properties, though that is not always true in Chrome.\r\n        var vertScrollbar = Math.round(width + horizPad) - clientWidth;\r\n        var horizScrollbar = Math.round(height + vertPad) - clientHeight;\r\n        // Chrome has a rather weird rounding of \"client\" properties.\r\n        // E.g. for an element with content width of 314.2px it sometimes gives\r\n        // the client width of 315px and for the width of 314.7px it may give\r\n        // 314px. And it doesn't happen all the time. So just ignore this delta\r\n        // as a non-relevant.\r\n        if (Math.abs(vertScrollbar) !== 1) {\r\n            width -= vertScrollbar;\r\n        }\r\n        if (Math.abs(horizScrollbar) !== 1) {\r\n            height -= horizScrollbar;\r\n        }\r\n    }\r\n    return createRectInit(paddings.left, paddings.top, width, height);\r\n}\r\n/**\r\n * Checks whether provided element is an instance of the SVGGraphicsElement.\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\r\nvar isSVGGraphicsElement = (function () {\r\n    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement\r\n    // interface.\r\n    if (typeof SVGGraphicsElement !== 'undefined') {\r\n        return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };\r\n    }\r\n    // If it's so, then check that element is at least an instance of the\r\n    // SVGElement and that it has the \"getBBox\" method.\r\n    // eslint-disable-next-line no-extra-parens\r\n    return function (target) { return (target instanceof getWindowOf(target).SVGElement &&\r\n        typeof target.getBBox === 'function'); };\r\n})();\r\n/**\r\n * Checks whether provided element is a document element (<html>).\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\r\nfunction isDocumentElement(target) {\r\n    return target === getWindowOf(target).document.documentElement;\r\n}\r\n/**\r\n * Calculates an appropriate content rectangle for provided html or svg element.\r\n *\r\n * @param {Element} target - Element content rectangle of which needs to be calculated.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getContentRect(target) {\r\n    if (!isBrowser) {\r\n        return emptyRect;\r\n    }\r\n    if (isSVGGraphicsElement(target)) {\r\n        return getSVGContentRect(target);\r\n    }\r\n    return getHTMLElementContentRect(target);\r\n}\r\n/**\r\n * Creates rectangle with an interface of the DOMRectReadOnly.\r\n * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly\r\n *\r\n * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.\r\n * @returns {DOMRectReadOnly}\r\n */\r\nfunction createReadOnlyRect(_a) {\r\n    var x = _a.x, y = _a.y, width = _a.width, height = _a.height;\r\n    // If DOMRectReadOnly is available use it as a prototype for the rectangle.\r\n    var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;\r\n    var rect = Object.create(Constr.prototype);\r\n    // Rectangle's properties are not writable and non-enumerable.\r\n    defineConfigurable(rect, {\r\n        x: x, y: y, width: width, height: height,\r\n        top: y,\r\n        right: x + width,\r\n        bottom: height + y,\r\n        left: x\r\n    });\r\n    return rect;\r\n}\r\n/**\r\n * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.\r\n * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit\r\n *\r\n * @param {number} x - X coordinate.\r\n * @param {number} y - Y coordinate.\r\n * @param {number} width - Rectangle's width.\r\n * @param {number} height - Rectangle's height.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction createRectInit(x, y, width, height) {\r\n    return { x: x, y: y, width: width, height: height };\r\n}\n\n/**\r\n * Class that is responsible for computations of the content rectangle of\r\n * provided DOM element and for keeping track of it's changes.\r\n */\r\nvar ResizeObservation = /** @class */ (function () {\r\n    /**\r\n     * Creates an instance of ResizeObservation.\r\n     *\r\n     * @param {Element} target - Element to be observed.\r\n     */\r\n    function ResizeObservation(target) {\r\n        /**\r\n         * Broadcasted width of content rectangle.\r\n         *\r\n         * @type {number}\r\n         */\r\n        this.broadcastWidth = 0;\r\n        /**\r\n         * Broadcasted height of content rectangle.\r\n         *\r\n         * @type {number}\r\n         */\r\n        this.broadcastHeight = 0;\r\n        /**\r\n         * Reference to the last observed content rectangle.\r\n         *\r\n         * @private {DOMRectInit}\r\n         */\r\n        this.contentRect_ = createRectInit(0, 0, 0, 0);\r\n        this.target = target;\r\n    }\r\n    /**\r\n     * Updates content rectangle and tells whether it's width or height properties\r\n     * have changed since the last broadcast.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    ResizeObservation.prototype.isActive = function () {\r\n        var rect = getContentRect(this.target);\r\n        this.contentRect_ = rect;\r\n        return (rect.width !== this.broadcastWidth ||\r\n            rect.height !== this.broadcastHeight);\r\n    };\r\n    /**\r\n     * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data\r\n     * from the corresponding properties of the last observed content rectangle.\r\n     *\r\n     * @returns {DOMRectInit} Last observed content rectangle.\r\n     */\r\n    ResizeObservation.prototype.broadcastRect = function () {\r\n        var rect = this.contentRect_;\r\n        this.broadcastWidth = rect.width;\r\n        this.broadcastHeight = rect.height;\r\n        return rect;\r\n    };\r\n    return ResizeObservation;\r\n}());\n\nvar ResizeObserverEntry = /** @class */ (function () {\r\n    /**\r\n     * Creates an instance of ResizeObserverEntry.\r\n     *\r\n     * @param {Element} target - Element that is being observed.\r\n     * @param {DOMRectInit} rectInit - Data of the element's content rectangle.\r\n     */\r\n    function ResizeObserverEntry(target, rectInit) {\r\n        var contentRect = createReadOnlyRect(rectInit);\r\n        // According to the specification following properties are not writable\r\n        // and are also not enumerable in the native implementation.\r\n        //\r\n        // Property accessors are not being used as they'd require to define a\r\n        // private WeakMap storage which may cause memory leaks in browsers that\r\n        // don't support this type of collections.\r\n        defineConfigurable(this, { target: target, contentRect: contentRect });\r\n    }\r\n    return ResizeObserverEntry;\r\n}());\n\nvar ResizeObserverSPI = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserver.\r\n     *\r\n     * @param {ResizeObserverCallback} callback - Callback function that is invoked\r\n     *      when one of the observed elements changes it's content dimensions.\r\n     * @param {ResizeObserverController} controller - Controller instance which\r\n     *      is responsible for the updates of observer.\r\n     * @param {ResizeObserver} callbackCtx - Reference to the public\r\n     *      ResizeObserver instance which will be passed to callback function.\r\n     */\r\n    function ResizeObserverSPI(callback, controller, callbackCtx) {\r\n        /**\r\n         * Collection of resize observations that have detected changes in dimensions\r\n         * of elements.\r\n         *\r\n         * @private {Array<ResizeObservation>}\r\n         */\r\n        this.activeObservations_ = [];\r\n        /**\r\n         * Registry of the ResizeObservation instances.\r\n         *\r\n         * @private {Map<Element, ResizeObservation>}\r\n         */\r\n        this.observations_ = new MapShim();\r\n        if (typeof callback !== 'function') {\r\n            throw new TypeError('The callback provided as parameter 1 is not a function.');\r\n        }\r\n        this.callback_ = callback;\r\n        this.controller_ = controller;\r\n        this.callbackCtx_ = callbackCtx;\r\n    }\r\n    /**\r\n     * Starts observing provided element.\r\n     *\r\n     * @param {Element} target - Element to be observed.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.observe = function (target) {\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n        // Do nothing if current environment doesn't have the Element interface.\r\n        if (typeof Element === 'undefined' || !(Element instanceof Object)) {\r\n            return;\r\n        }\r\n        if (!(target instanceof getWindowOf(target).Element)) {\r\n            throw new TypeError('parameter 1 is not of type \"Element\".');\r\n        }\r\n        var observations = this.observations_;\r\n        // Do nothing if element is already being observed.\r\n        if (observations.has(target)) {\r\n            return;\r\n        }\r\n        observations.set(target, new ResizeObservation(target));\r\n        this.controller_.addObserver(this);\r\n        // Force the update of observations.\r\n        this.controller_.refresh();\r\n    };\r\n    /**\r\n     * Stops observing provided element.\r\n     *\r\n     * @param {Element} target - Element to stop observing.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.unobserve = function (target) {\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n        // Do nothing if current environment doesn't have the Element interface.\r\n        if (typeof Element === 'undefined' || !(Element instanceof Object)) {\r\n            return;\r\n        }\r\n        if (!(target instanceof getWindowOf(target).Element)) {\r\n            throw new TypeError('parameter 1 is not of type \"Element\".');\r\n        }\r\n        var observations = this.observations_;\r\n        // Do nothing if element is not being observed.\r\n        if (!observations.has(target)) {\r\n            return;\r\n        }\r\n        observations.delete(target);\r\n        if (!observations.size) {\r\n            this.controller_.removeObserver(this);\r\n        }\r\n    };\r\n    /**\r\n     * Stops observing all elements.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.disconnect = function () {\r\n        this.clearActive();\r\n        this.observations_.clear();\r\n        this.controller_.removeObserver(this);\r\n    };\r\n    /**\r\n     * Collects observation instances the associated element of which has changed\r\n     * it's content rectangle.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.gatherActive = function () {\r\n        var _this = this;\r\n        this.clearActive();\r\n        this.observations_.forEach(function (observation) {\r\n            if (observation.isActive()) {\r\n                _this.activeObservations_.push(observation);\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Invokes initial callback function with a list of ResizeObserverEntry\r\n     * instances collected from active resize observations.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.broadcastActive = function () {\r\n        // Do nothing if observer doesn't have active observations.\r\n        if (!this.hasActive()) {\r\n            return;\r\n        }\r\n        var ctx = this.callbackCtx_;\r\n        // Create ResizeObserverEntry instance for every active observation.\r\n        var entries = this.activeObservations_.map(function (observation) {\r\n            return new ResizeObserverEntry(observation.target, observation.broadcastRect());\r\n        });\r\n        this.callback_.call(ctx, entries, ctx);\r\n        this.clearActive();\r\n    };\r\n    /**\r\n     * Clears the collection of active observations.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.clearActive = function () {\r\n        this.activeObservations_.splice(0);\r\n    };\r\n    /**\r\n     * Tells whether observer has active observations.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    ResizeObserverSPI.prototype.hasActive = function () {\r\n        return this.activeObservations_.length > 0;\r\n    };\r\n    return ResizeObserverSPI;\r\n}());\n\n// Registry of internal observers. If WeakMap is not available use current shim\r\n// for the Map collection as it has all required methods and because WeakMap\r\n// can't be fully polyfilled anyway.\r\nvar observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();\r\n/**\r\n * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation\r\n * exposing only those methods and properties that are defined in the spec.\r\n */\r\nvar ResizeObserver = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserver.\r\n     *\r\n     * @param {ResizeObserverCallback} callback - Callback that is invoked when\r\n     *      dimensions of the observed elements change.\r\n     */\r\n    function ResizeObserver(callback) {\r\n        if (!(this instanceof ResizeObserver)) {\r\n            throw new TypeError('Cannot call a class as a function.');\r\n        }\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n        var controller = ResizeObserverController.getInstance();\r\n        var observer = new ResizeObserverSPI(callback, controller, this);\r\n        observers.set(this, observer);\r\n    }\r\n    return ResizeObserver;\r\n}());\r\n// Expose public methods of ResizeObserver.\r\n[\r\n    'observe',\r\n    'unobserve',\r\n    'disconnect'\r\n].forEach(function (method) {\r\n    ResizeObserver.prototype[method] = function () {\r\n        var _a;\r\n        return (_a = observers.get(this))[method].apply(_a, arguments);\r\n    };\r\n});\n\nvar index = (function () {\r\n    // Export existing implementation if available.\r\n    if (typeof global$1.ResizeObserver !== 'undefined') {\r\n        return global$1.ResizeObserver;\r\n    }\r\n    return ResizeObserver;\r\n})();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (index);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL3Jlc2l6ZS1vYnNlcnZlci1wb2x5ZmlsbC9kaXN0L1Jlc2l6ZU9ic2VydmVyLmVzLmpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGVBQWUsR0FBRztBQUNsQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxtQkFBbUIsR0FBRztBQUN0QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsR0FBRztBQUN0QixtQkFBbUIsR0FBRztBQUN0QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixHQUFHO0FBQ3RCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsR0FBRztBQUN0QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFVBQVU7QUFDN0IsbUJBQW1CLEdBQUc7QUFDdEIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEMsb0RBQW9ELGdCQUFnQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUscUJBQU0sb0JBQW9CLHFCQUFNO0FBQy9DLGVBQWUscUJBQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGdDQUFnQyw4QkFBOEI7QUFDL0YsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Qsb0NBQW9DO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLDhDQUE4QyxnQkFBZ0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDLFdBQVcsV0FBVztBQUN0QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEMsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHlCQUF5QjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGFBQWE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywwQ0FBMEM7QUFDN0U7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHdCQUF3QjtBQUN2QztBQUNBLGVBQWUsMEJBQTBCO0FBQ3pDO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsd0JBQXdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsK0RBQWUsS0FBSyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZXNpemUtb2JzZXJ2ZXItcG9seWZpbGwvZGlzdC9SZXNpemVPYnNlcnZlci5lcy5qcz83YzNjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBBIGNvbGxlY3Rpb24gb2Ygc2hpbXMgdGhhdCBwcm92aWRlIG1pbmltYWwgZnVuY3Rpb25hbGl0eSBvZiB0aGUgRVM2IGNvbGxlY3Rpb25zLlxyXG4gKlxyXG4gKiBUaGVzZSBpbXBsZW1lbnRhdGlvbnMgYXJlIG5vdCBtZWFudCB0byBiZSB1c2VkIG91dHNpZGUgb2YgdGhlIFJlc2l6ZU9ic2VydmVyXHJcbiAqIG1vZHVsZXMgYXMgdGhleSBjb3ZlciBvbmx5IGEgbGltaXRlZCByYW5nZSBvZiB1c2UgY2FzZXMuXHJcbiAqL1xyXG4vKiBlc2xpbnQtZGlzYWJsZSByZXF1aXJlLWpzZG9jLCB2YWxpZC1qc2RvYyAqL1xyXG52YXIgTWFwU2hpbSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodHlwZW9mIE1hcCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICByZXR1cm4gTWFwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGluZGV4IGluIHByb3ZpZGVkIGFycmF5IHRoYXQgbWF0Y2hlcyB0aGUgc3BlY2lmaWVkIGtleS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5PEFycmF5Pn0gYXJyXHJcbiAgICAgKiBAcGFyYW0geyp9IGtleVxyXG4gICAgICogQHJldHVybnMge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0SW5kZXgoYXJyLCBrZXkpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gLTE7XHJcbiAgICAgICAgYXJyLnNvbWUoZnVuY3Rpb24gKGVudHJ5LCBpbmRleCkge1xyXG4gICAgICAgICAgICBpZiAoZW50cnlbMF0gPT09IGtleSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIHJldHVybiAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gY2xhc3NfMSgpIHtcclxuICAgICAgICAgICAgdGhpcy5fX2VudHJpZXNfXyA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2xhc3NfMS5wcm90b3R5cGUsIFwic2l6ZVwiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19lbnRyaWVzX18ubGVuZ3RoO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0geyp9IGtleVxyXG4gICAgICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXgodGhpcy5fX2VudHJpZXNfXywga2V5KTtcclxuICAgICAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5fX2VudHJpZXNfX1tpbmRleF07XHJcbiAgICAgICAgICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeVsxXTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0ga2V5XHJcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGdldEluZGV4KHRoaXMuX19lbnRyaWVzX18sIGtleSk7XHJcbiAgICAgICAgICAgIGlmICh+aW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19lbnRyaWVzX19baW5kZXhdWzFdID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fZW50cmllc19fLnB1c2goW2tleSwgdmFsdWVdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHsqfSBrZXlcclxuICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIHZhciBlbnRyaWVzID0gdGhpcy5fX2VudHJpZXNfXztcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXgoZW50cmllcywga2V5KTtcclxuICAgICAgICAgICAgaWYgKH5pbmRleCkge1xyXG4gICAgICAgICAgICAgICAgZW50cmllcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0geyp9IGtleVxyXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuICEhfmdldEluZGV4KHRoaXMuX19lbnRyaWVzX18sIGtleSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fX2VudHJpZXNfXy5zcGxpY2UoMCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW2N0eD1udWxsXVxyXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGN0eCkge1xyXG4gICAgICAgICAgICBpZiAoY3R4ID09PSB2b2lkIDApIHsgY3R4ID0gbnVsbDsgfVxyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5fX2VudHJpZXNfXzsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IF9hW19pXTtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoY3R4LCBlbnRyeVsxXSwgZW50cnlbMF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gY2xhc3NfMTtcclxuICAgIH0oKSk7XHJcbn0pKCk7XG5cbi8qKlxyXG4gKiBEZXRlY3RzIHdoZXRoZXIgd2luZG93IGFuZCBkb2N1bWVudCBvYmplY3RzIGFyZSBhdmFpbGFibGUgaW4gY3VycmVudCBlbnZpcm9ubWVudC5cclxuICovXHJcbnZhciBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5kb2N1bWVudCA9PT0gZG9jdW1lbnQ7XG5cbi8vIFJldHVybnMgZ2xvYmFsIG9iamVjdCBvZiBhIGN1cnJlbnQgZW52aXJvbm1lbnQuXHJcbnZhciBnbG9iYWwkMSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsLk1hdGggPT09IE1hdGgpIHtcclxuICAgICAgICByZXR1cm4gZ2xvYmFsO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT09IE1hdGgpIHtcclxuICAgICAgICByZXR1cm4gc2VsZjtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PT0gTWF0aCkge1xyXG4gICAgICAgIHJldHVybiB3aW5kb3c7XHJcbiAgICB9XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcclxuICAgIHJldHVybiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xyXG59KSgpO1xuXG4vKipcclxuICogQSBzaGltIGZvciB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHdoaWNoIGZhbGxzIGJhY2sgdG8gdGhlIHNldFRpbWVvdXQgaWZcclxuICogZmlyc3Qgb25lIGlzIG5vdCBzdXBwb3J0ZWQuXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJlcXVlc3RzJyBpZGVudGlmaWVyLlxyXG4gKi9cclxudmFyIHJlcXVlc3RBbmltYXRpb25GcmFtZSQxID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICh0eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgLy8gSXQncyByZXF1aXJlZCB0byB1c2UgYSBib3VuZGVkIGZ1bmN0aW9uIGJlY2F1c2UgSUUgc29tZXRpbWVzIHRocm93c1xyXG4gICAgICAgIC8vIGFuIFwiSW52YWxpZCBjYWxsaW5nIG9iamVjdFwiIGVycm9yIGlmIHJBRiBpcyBpbnZva2VkIHdpdGhvdXQgdGhlIGdsb2JhbFxyXG4gICAgICAgIC8vIG9iamVjdCBvbiB0aGUgbGVmdCBoYW5kIHNpZGUuXHJcbiAgICAgICAgcmV0dXJuIHJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKGdsb2JhbCQxKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmdW5jdGlvbiAoY2FsbGJhY2spIHsgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FsbGJhY2soRGF0ZS5ub3coKSk7IH0sIDEwMDAgLyA2MCk7IH07XHJcbn0pKCk7XG5cbi8vIERlZmluZXMgbWluaW11bSB0aW1lb3V0IGJlZm9yZSBhZGRpbmcgYSB0cmFpbGluZyBjYWxsLlxyXG52YXIgdHJhaWxpbmdUaW1lb3V0ID0gMjtcclxuLyoqXHJcbiAqIENyZWF0ZXMgYSB3cmFwcGVyIGZ1bmN0aW9uIHdoaWNoIGVuc3VyZXMgdGhhdCBwcm92aWRlZCBjYWxsYmFjayB3aWxsIGJlXHJcbiAqIGludm9rZWQgb25seSBvbmNlIGR1cmluZyB0aGUgc3BlY2lmaWVkIGRlbGF5IHBlcmlvZC5cclxuICpcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBGdW5jdGlvbiB0byBiZSBpbnZva2VkIGFmdGVyIHRoZSBkZWxheSBwZXJpb2QuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWxheSAtIERlbGF5IGFmdGVyIHdoaWNoIHRvIGludm9rZSBjYWxsYmFjay5cclxuICogQHJldHVybnMge0Z1bmN0aW9ufVxyXG4gKi9cclxuZnVuY3Rpb24gdGhyb3R0bGUgKGNhbGxiYWNrLCBkZWxheSkge1xyXG4gICAgdmFyIGxlYWRpbmdDYWxsID0gZmFsc2UsIHRyYWlsaW5nQ2FsbCA9IGZhbHNlLCBsYXN0Q2FsbFRpbWUgPSAwO1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbnZva2VzIHRoZSBvcmlnaW5hbCBjYWxsYmFjayBmdW5jdGlvbiBhbmQgc2NoZWR1bGVzIG5ldyBpbnZvY2F0aW9uIGlmXHJcbiAgICAgKiB0aGUgXCJwcm94eVwiIHdhcyBjYWxsZWQgZHVyaW5nIGN1cnJlbnQgcmVxdWVzdC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gcmVzb2x2ZVBlbmRpbmcoKSB7XHJcbiAgICAgICAgaWYgKGxlYWRpbmdDYWxsKSB7XHJcbiAgICAgICAgICAgIGxlYWRpbmdDYWxsID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0cmFpbGluZ0NhbGwpIHtcclxuICAgICAgICAgICAgcHJveHkoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENhbGxiYWNrIGludm9rZWQgYWZ0ZXIgdGhlIHNwZWNpZmllZCBkZWxheS4gSXQgd2lsbCBmdXJ0aGVyIHBvc3Rwb25lXHJcbiAgICAgKiBpbnZvY2F0aW9uIG9mIHRoZSBvcmlnaW5hbCBmdW5jdGlvbiBkZWxlZ2F0aW5nIGl0IHRvIHRoZVxyXG4gICAgICogcmVxdWVzdEFuaW1hdGlvbkZyYW1lLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB0aW1lb3V0Q2FsbGJhY2soKSB7XHJcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lJDEocmVzb2x2ZVBlbmRpbmcpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTY2hlZHVsZXMgaW52b2NhdGlvbiBvZiB0aGUgb3JpZ2luYWwgZnVuY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHByb3h5KCkge1xyXG4gICAgICAgIHZhciB0aW1lU3RhbXAgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgIGlmIChsZWFkaW5nQ2FsbCkge1xyXG4gICAgICAgICAgICAvLyBSZWplY3QgaW1tZWRpYXRlbHkgZm9sbG93aW5nIGNhbGxzLlxyXG4gICAgICAgICAgICBpZiAodGltZVN0YW1wIC0gbGFzdENhbGxUaW1lIDwgdHJhaWxpbmdUaW1lb3V0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gU2NoZWR1bGUgbmV3IGNhbGwgdG8gYmUgaW4gaW52b2tlZCB3aGVuIHRoZSBwZW5kaW5nIG9uZSBpcyByZXNvbHZlZC5cclxuICAgICAgICAgICAgLy8gVGhpcyBpcyBpbXBvcnRhbnQgZm9yIFwidHJhbnNpdGlvbnNcIiB3aGljaCBuZXZlciBhY3R1YWxseSBzdGFydFxyXG4gICAgICAgICAgICAvLyBpbW1lZGlhdGVseSBzbyB0aGVyZSBpcyBhIGNoYW5jZSB0aGF0IHdlIG1pZ2h0IG1pc3Mgb25lIGlmIGNoYW5nZVxyXG4gICAgICAgICAgICAvLyBoYXBwZW5zIGFtaWRzIHRoZSBwZW5kaW5nIGludm9jYXRpb24uXHJcbiAgICAgICAgICAgIHRyYWlsaW5nQ2FsbCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsZWFkaW5nQ2FsbCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRyYWlsaW5nQ2FsbCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHRpbWVvdXRDYWxsYmFjaywgZGVsYXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsYXN0Q2FsbFRpbWUgPSB0aW1lU3RhbXA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJveHk7XHJcbn1cblxuLy8gTWluaW11bSBkZWxheSBiZWZvcmUgaW52b2tpbmcgdGhlIHVwZGF0ZSBvZiBvYnNlcnZlcnMuXHJcbnZhciBSRUZSRVNIX0RFTEFZID0gMjA7XHJcbi8vIEEgbGlzdCBvZiBzdWJzdHJpbmdzIG9mIENTUyBwcm9wZXJ0aWVzIHVzZWQgdG8gZmluZCB0cmFuc2l0aW9uIGV2ZW50cyB0aGF0XHJcbi8vIG1pZ2h0IGFmZmVjdCBkaW1lbnNpb25zIG9mIG9ic2VydmVkIGVsZW1lbnRzLlxyXG52YXIgdHJhbnNpdGlvbktleXMgPSBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCcsICd3aWR0aCcsICdoZWlnaHQnLCAnc2l6ZScsICd3ZWlnaHQnXTtcclxuLy8gQ2hlY2sgaWYgTXV0YXRpb25PYnNlcnZlciBpcyBhdmFpbGFibGUuXHJcbnZhciBtdXRhdGlvbk9ic2VydmVyU3VwcG9ydGVkID0gdHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnO1xyXG4vKipcclxuICogU2luZ2xldG9uIGNvbnRyb2xsZXIgY2xhc3Mgd2hpY2ggaGFuZGxlcyB1cGRhdGVzIG9mIFJlc2l6ZU9ic2VydmVyIGluc3RhbmNlcy5cclxuICovXHJcbnZhciBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlcigpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciBET00gbGlzdGVuZXJzIGhhdmUgYmVlbiBhZGRlZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlIHtib29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGVkXyA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRlbGxzIHRoYXQgY29udHJvbGxlciBoYXMgc3Vic2NyaWJlZCBmb3IgTXV0YXRpb24gRXZlbnRzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGUge2Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5tdXRhdGlvbkV2ZW50c0FkZGVkXyA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEtlZXBzIHJlZmVyZW5jZSB0byB0aGUgaW5zdGFuY2Ugb2YgTXV0YXRpb25PYnNlcnZlci5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlIHtNdXRhdGlvbk9ic2VydmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIGxpc3Qgb2YgY29ubmVjdGVkIG9ic2VydmVycy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlIHtBcnJheTxSZXNpemVPYnNlcnZlclNQST59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5vYnNlcnZlcnNfID0gW107XHJcbiAgICAgICAgdGhpcy5vblRyYW5zaXRpb25FbmRfID0gdGhpcy5vblRyYW5zaXRpb25FbmRfLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5yZWZyZXNoID0gdGhyb3R0bGUodGhpcy5yZWZyZXNoLmJpbmQodGhpcyksIFJFRlJFU0hfREVMQVkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIG9ic2VydmVyIHRvIG9ic2VydmVycyBsaXN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UmVzaXplT2JzZXJ2ZXJTUEl9IG9ic2VydmVyIC0gT2JzZXJ2ZXIgdG8gYmUgYWRkZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS5hZGRPYnNlcnZlciA9IGZ1bmN0aW9uIChvYnNlcnZlcikge1xyXG4gICAgICAgIGlmICghfnRoaXMub2JzZXJ2ZXJzXy5pbmRleE9mKG9ic2VydmVyKSkge1xyXG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyc18ucHVzaChvYnNlcnZlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEFkZCBsaXN0ZW5lcnMgaWYgdGhleSBoYXZlbid0IGJlZW4gYWRkZWQgeWV0LlxyXG4gICAgICAgIGlmICghdGhpcy5jb25uZWN0ZWRfKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdF8oKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIG9ic2VydmVyIGZyb20gb2JzZXJ2ZXJzIGxpc3QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtSZXNpemVPYnNlcnZlclNQSX0gb2JzZXJ2ZXIgLSBPYnNlcnZlciB0byBiZSByZW1vdmVkLlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5wcm90b3R5cGUucmVtb3ZlT2JzZXJ2ZXIgPSBmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcclxuICAgICAgICB2YXIgb2JzZXJ2ZXJzID0gdGhpcy5vYnNlcnZlcnNfO1xyXG4gICAgICAgIHZhciBpbmRleCA9IG9ic2VydmVycy5pbmRleE9mKG9ic2VydmVyKTtcclxuICAgICAgICAvLyBSZW1vdmUgb2JzZXJ2ZXIgaWYgaXQncyBwcmVzZW50IGluIHJlZ2lzdHJ5LlxyXG4gICAgICAgIGlmICh+aW5kZXgpIHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXJzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJlbW92ZSBsaXN0ZW5lcnMgaWYgY29udHJvbGxlciBoYXMgbm8gY29ubmVjdGVkIG9ic2VydmVycy5cclxuICAgICAgICBpZiAoIW9ic2VydmVycy5sZW5ndGggJiYgdGhpcy5jb25uZWN0ZWRfKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdF8oKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbnZva2VzIHRoZSB1cGRhdGUgb2Ygb2JzZXJ2ZXJzLiBJdCB3aWxsIGNvbnRpbnVlIHJ1bm5pbmcgdXBkYXRlcyBpbnNvZmFyXHJcbiAgICAgKiBpdCBkZXRlY3RzIGNoYW5nZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY2hhbmdlc0RldGVjdGVkID0gdGhpcy51cGRhdGVPYnNlcnZlcnNfKCk7XHJcbiAgICAgICAgLy8gQ29udGludWUgcnVubmluZyB1cGRhdGVzIGlmIGNoYW5nZXMgaGF2ZSBiZWVuIGRldGVjdGVkIGFzIHRoZXJlIG1pZ2h0XHJcbiAgICAgICAgLy8gYmUgZnV0dXJlIG9uZXMgY2F1c2VkIGJ5IENTUyB0cmFuc2l0aW9ucy5cclxuICAgICAgICBpZiAoY2hhbmdlc0RldGVjdGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgZXZlcnkgb2JzZXJ2ZXIgZnJvbSBvYnNlcnZlcnMgbGlzdCBhbmQgbm90aWZpZXMgdGhlbSBvZiBxdWV1ZWRcclxuICAgICAqIGVudHJpZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIFwidHJ1ZVwiIGlmIGFueSBvYnNlcnZlciBoYXMgZGV0ZWN0ZWQgY2hhbmdlcyBpblxyXG4gICAgICogICAgICBkaW1lbnNpb25zIG9mIGl0J3MgZWxlbWVudHMuXHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5wcm90b3R5cGUudXBkYXRlT2JzZXJ2ZXJzXyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBDb2xsZWN0IG9ic2VydmVycyB0aGF0IGhhdmUgYWN0aXZlIG9ic2VydmF0aW9ucy5cclxuICAgICAgICB2YXIgYWN0aXZlT2JzZXJ2ZXJzID0gdGhpcy5vYnNlcnZlcnNfLmZpbHRlcihmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9ic2VydmVyLmdhdGhlckFjdGl2ZSgpLCBvYnNlcnZlci5oYXNBY3RpdmUoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBEZWxpdmVyIG5vdGlmaWNhdGlvbnMgaW4gYSBzZXBhcmF0ZSBjeWNsZSBpbiBvcmRlciB0byBhdm9pZCBhbnlcclxuICAgICAgICAvLyBjb2xsaXNpb25zIGJldHdlZW4gb2JzZXJ2ZXJzLCBlLmcuIHdoZW4gbXVsdGlwbGUgaW5zdGFuY2VzIG9mXHJcbiAgICAgICAgLy8gUmVzaXplT2JzZXJ2ZXIgYXJlIHRyYWNraW5nIHRoZSBzYW1lIGVsZW1lbnQgYW5kIHRoZSBjYWxsYmFjayBvZiBvbmVcclxuICAgICAgICAvLyBvZiB0aGVtIGNoYW5nZXMgY29udGVudCBkaW1lbnNpb25zIG9mIHRoZSBvYnNlcnZlZCB0YXJnZXQuIFNvbWV0aW1lc1xyXG4gICAgICAgIC8vIHRoaXMgbWF5IHJlc3VsdCBpbiBub3RpZmljYXRpb25zIGJlaW5nIGJsb2NrZWQgZm9yIHRoZSByZXN0IG9mIG9ic2VydmVycy5cclxuICAgICAgICBhY3RpdmVPYnNlcnZlcnMuZm9yRWFjaChmdW5jdGlvbiAob2JzZXJ2ZXIpIHsgcmV0dXJuIG9ic2VydmVyLmJyb2FkY2FzdEFjdGl2ZSgpOyB9KTtcclxuICAgICAgICByZXR1cm4gYWN0aXZlT2JzZXJ2ZXJzLmxlbmd0aCA+IDA7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXplcyBET00gbGlzdGVuZXJzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS5jb25uZWN0XyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIHJ1bm5pbmcgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudCBvciBpZiBsaXN0ZW5lcnNcclxuICAgICAgICAvLyBoYXZlIGJlZW4gYWxyZWFkeSBhZGRlZC5cclxuICAgICAgICBpZiAoIWlzQnJvd3NlciB8fCB0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTdWJzY3JpcHRpb24gdG8gdGhlIFwiVHJhbnNpdGlvbmVuZFwiIGV2ZW50IGlzIHVzZWQgYXMgYSB3b3JrYXJvdW5kIGZvclxyXG4gICAgICAgIC8vIGRlbGF5ZWQgdHJhbnNpdGlvbnMuIFRoaXMgd2F5IGl0J3MgcG9zc2libGUgdG8gY2FwdHVyZSBhdCBsZWFzdCB0aGVcclxuICAgICAgICAvLyBmaW5hbCBzdGF0ZSBvZiBhbiBlbGVtZW50LlxyXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCB0aGlzLm9uVHJhbnNpdGlvbkVuZF8pO1xyXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLnJlZnJlc2gpO1xyXG4gICAgICAgIGlmIChtdXRhdGlvbk9ic2VydmVyU3VwcG9ydGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIodGhpcy5yZWZyZXNoKTtcclxuICAgICAgICAgICAgdGhpcy5tdXRhdGlvbnNPYnNlcnZlcl8ub2JzZXJ2ZShkb2N1bWVudCwge1xyXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGNoYXJhY3RlckRhdGE6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBzdWJ0cmVlOiB0cnVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NU3VidHJlZU1vZGlmaWVkJywgdGhpcy5yZWZyZXNoKTtcclxuICAgICAgICAgICAgdGhpcy5tdXRhdGlvbkV2ZW50c0FkZGVkXyA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY29ubmVjdGVkXyA9IHRydWU7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIERPTSBsaXN0ZW5lcnMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLmRpc2Nvbm5lY3RfID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgcnVubmluZyBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50IG9yIGlmIGxpc3RlbmVyc1xyXG4gICAgICAgIC8vIGhhdmUgYmVlbiBhbHJlYWR5IHJlbW92ZWQuXHJcbiAgICAgICAgaWYgKCFpc0Jyb3dzZXIgfHwgIXRoaXMuY29ubmVjdGVkXykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCB0aGlzLm9uVHJhbnNpdGlvbkVuZF8pO1xyXG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLnJlZnJlc2gpO1xyXG4gICAgICAgIGlmICh0aGlzLm11dGF0aW9uc09ic2VydmVyXykge1xyXG4gICAgICAgICAgICB0aGlzLm11dGF0aW9uc09ic2VydmVyXy5kaXNjb25uZWN0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm11dGF0aW9uRXZlbnRzQWRkZWRfKSB7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ0RPTVN1YnRyZWVNb2RpZmllZCcsIHRoaXMucmVmcmVzaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfID0gbnVsbDtcclxuICAgICAgICB0aGlzLm11dGF0aW9uRXZlbnRzQWRkZWRfID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0ZWRfID0gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBcIlRyYW5zaXRpb25lbmRcIiBldmVudCBoYW5kbGVyLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge1RyYW5zaXRpb25FdmVudH0gZXZlbnRcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLm9uVHJhbnNpdGlvbkVuZF8gPSBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICB2YXIgX2IgPSBfYS5wcm9wZXJ0eU5hbWUsIHByb3BlcnR5TmFtZSA9IF9iID09PSB2b2lkIDAgPyAnJyA6IF9iO1xyXG4gICAgICAgIC8vIERldGVjdCB3aGV0aGVyIHRyYW5zaXRpb24gbWF5IGFmZmVjdCBkaW1lbnNpb25zIG9mIGFuIGVsZW1lbnQuXHJcbiAgICAgICAgdmFyIGlzUmVmbG93UHJvcGVydHkgPSB0cmFuc2l0aW9uS2V5cy5zb21lKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuICEhfnByb3BlcnR5TmFtZS5pbmRleE9mKGtleSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGlzUmVmbG93UHJvcGVydHkpIHtcclxuICAgICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBpbnN0YW5jZSBvZiB0aGUgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtSZXNpemVPYnNlcnZlckNvbnRyb2xsZXJ9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5nZXRJbnN0YW5jZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaW5zdGFuY2VfKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2VfID0gbmV3IFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW5jZV87XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBIb2xkcyByZWZlcmVuY2UgdG8gdGhlIGNvbnRyb2xsZXIncyBpbnN0YW5jZS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZSB7UmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIuaW5zdGFuY2VfID0gbnVsbDtcclxuICAgIHJldHVybiBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXI7XHJcbn0oKSk7XG5cbi8qKlxyXG4gKiBEZWZpbmVzIG5vbi13cml0YWJsZS9lbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgdGhlIHByb3ZpZGVkIHRhcmdldCBvYmplY3QuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgLSBPYmplY3QgZm9yIHdoaWNoIHRvIGRlZmluZSBwcm9wZXJ0aWVzLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgLSBQcm9wZXJ0aWVzIHRvIGJlIGRlZmluZWQuXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRhcmdldCBvYmplY3QuXHJcbiAqL1xyXG52YXIgZGVmaW5lQ29uZmlndXJhYmxlID0gKGZ1bmN0aW9uICh0YXJnZXQsIHByb3BzKSB7XHJcbiAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gT2JqZWN0LmtleXMocHJvcHMpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIHZhciBrZXkgPSBfYVtfaV07XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCB7XHJcbiAgICAgICAgICAgIHZhbHVlOiBwcm9wc1trZXldLFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbn0pO1xuXG4vKipcclxuICogUmV0dXJucyB0aGUgZ2xvYmFsIG9iamVjdCBhc3NvY2lhdGVkIHdpdGggcHJvdmlkZWQgZWxlbWVudC5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxyXG4gKi9cclxudmFyIGdldFdpbmRvd09mID0gKGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuICAgIC8vIEFzc3VtZSB0aGF0IHRoZSBlbGVtZW50IGlzIGFuIGluc3RhbmNlIG9mIE5vZGUsIHdoaWNoIG1lYW5zIHRoYXQgaXRcclxuICAgIC8vIGhhcyB0aGUgXCJvd25lckRvY3VtZW50XCIgcHJvcGVydHkgZnJvbSB3aGljaCB3ZSBjYW4gcmV0cmlldmUgYVxyXG4gICAgLy8gY29ycmVzcG9uZGluZyBnbG9iYWwgb2JqZWN0LlxyXG4gICAgdmFyIG93bmVyR2xvYmFsID0gdGFyZ2V0ICYmIHRhcmdldC5vd25lckRvY3VtZW50ICYmIHRhcmdldC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xyXG4gICAgLy8gUmV0dXJuIHRoZSBsb2NhbCBnbG9iYWwgb2JqZWN0IGlmIGl0J3Mgbm90IHBvc3NpYmxlIGV4dHJhY3Qgb25lIGZyb21cclxuICAgIC8vIHByb3ZpZGVkIGVsZW1lbnQuXHJcbiAgICByZXR1cm4gb3duZXJHbG9iYWwgfHwgZ2xvYmFsJDE7XHJcbn0pO1xuXG4vLyBQbGFjZWhvbGRlciBvZiBhbiBlbXB0eSBjb250ZW50IHJlY3RhbmdsZS5cclxudmFyIGVtcHR5UmVjdCA9IGNyZWF0ZVJlY3RJbml0KDAsIDAsIDAsIDApO1xyXG4vKipcclxuICogQ29udmVydHMgcHJvdmlkZWQgc3RyaW5nIHRvIGEgbnVtYmVyLlxyXG4gKlxyXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IHZhbHVlXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAqL1xyXG5mdW5jdGlvbiB0b0Zsb2F0KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSkgfHwgMDtcclxufVxyXG4vKipcclxuICogRXh0cmFjdHMgYm9yZGVycyBzaXplIGZyb20gcHJvdmlkZWQgc3R5bGVzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0NTU1N0eWxlRGVjbGFyYXRpb259IHN0eWxlc1xyXG4gKiBAcGFyYW0gey4uLnN0cmluZ30gcG9zaXRpb25zIC0gQm9yZGVycyBwb3NpdGlvbnMgKHRvcCwgcmlnaHQsIC4uLilcclxuICogQHJldHVybnMge251bWJlcn1cclxuICovXHJcbmZ1bmN0aW9uIGdldEJvcmRlcnNTaXplKHN0eWxlcykge1xyXG4gICAgdmFyIHBvc2l0aW9ucyA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICBwb3NpdGlvbnNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcG9zaXRpb25zLnJlZHVjZShmdW5jdGlvbiAoc2l6ZSwgcG9zaXRpb24pIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSBzdHlsZXNbJ2JvcmRlci0nICsgcG9zaXRpb24gKyAnLXdpZHRoJ107XHJcbiAgICAgICAgcmV0dXJuIHNpemUgKyB0b0Zsb2F0KHZhbHVlKTtcclxuICAgIH0sIDApO1xyXG59XHJcbi8qKlxyXG4gKiBFeHRyYWN0cyBwYWRkaW5ncyBzaXplcyBmcm9tIHByb3ZpZGVkIHN0eWxlcy5cclxuICpcclxuICogQHBhcmFtIHtDU1NTdHlsZURlY2xhcmF0aW9ufSBzdHlsZXNcclxuICogQHJldHVybnMge09iamVjdH0gUGFkZGluZ3MgYm94LlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0UGFkZGluZ3Moc3R5bGVzKSB7XHJcbiAgICB2YXIgcG9zaXRpb25zID0gWyd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXTtcclxuICAgIHZhciBwYWRkaW5ncyA9IHt9O1xyXG4gICAgZm9yICh2YXIgX2kgPSAwLCBwb3NpdGlvbnNfMSA9IHBvc2l0aW9uczsgX2kgPCBwb3NpdGlvbnNfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICB2YXIgcG9zaXRpb24gPSBwb3NpdGlvbnNfMVtfaV07XHJcbiAgICAgICAgdmFyIHZhbHVlID0gc3R5bGVzWydwYWRkaW5nLScgKyBwb3NpdGlvbl07XHJcbiAgICAgICAgcGFkZGluZ3NbcG9zaXRpb25dID0gdG9GbG9hdCh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGFkZGluZ3M7XHJcbn1cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgY29udGVudCByZWN0YW5nbGUgb2YgcHJvdmlkZWQgU1ZHIGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U1ZHR3JhcGhpY3NFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IGNvbnRlbnQgcmVjdGFuZ2xlIG9mIHdoaWNoIG5lZWRzXHJcbiAqICAgICAgdG8gYmUgY2FsY3VsYXRlZC5cclxuICogQHJldHVybnMge0RPTVJlY3RJbml0fVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0U1ZHQ29udGVudFJlY3QodGFyZ2V0KSB7XHJcbiAgICB2YXIgYmJveCA9IHRhcmdldC5nZXRCQm94KCk7XHJcbiAgICByZXR1cm4gY3JlYXRlUmVjdEluaXQoMCwgMCwgYmJveC53aWR0aCwgYmJveC5oZWlnaHQpO1xyXG59XHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIGNvbnRlbnQgcmVjdGFuZ2xlIG9mIHByb3ZpZGVkIEhUTUxFbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IGZvciB3aGljaCB0byBjYWxjdWxhdGUgdGhlIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gKiBAcmV0dXJucyB7RE9NUmVjdEluaXR9XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRIVE1MRWxlbWVudENvbnRlbnRSZWN0KHRhcmdldCkge1xyXG4gICAgLy8gQ2xpZW50IHdpZHRoICYgaGVpZ2h0IHByb3BlcnRpZXMgY2FuJ3QgYmVcclxuICAgIC8vIHVzZWQgZXhjbHVzaXZlbHkgYXMgdGhleSBwcm92aWRlIHJvdW5kZWQgdmFsdWVzLlxyXG4gICAgdmFyIGNsaWVudFdpZHRoID0gdGFyZ2V0LmNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQgPSB0YXJnZXQuY2xpZW50SGVpZ2h0O1xyXG4gICAgLy8gQnkgdGhpcyBjb25kaXRpb24gd2UgY2FuIGNhdGNoIGFsbCBub24tcmVwbGFjZWQgaW5saW5lLCBoaWRkZW4gYW5kXHJcbiAgICAvLyBkZXRhY2hlZCBlbGVtZW50cy4gVGhvdWdoIGVsZW1lbnRzIHdpdGggd2lkdGggJiBoZWlnaHQgcHJvcGVydGllcyBsZXNzXHJcbiAgICAvLyB0aGFuIDAuNSB3aWxsIGJlIGRpc2NhcmRlZCBhcyB3ZWxsLlxyXG4gICAgLy9cclxuICAgIC8vIFdpdGhvdXQgaXQgd2Ugd291bGQgbmVlZCB0byBpbXBsZW1lbnQgc2VwYXJhdGUgbWV0aG9kcyBmb3IgZWFjaCBvZlxyXG4gICAgLy8gdGhvc2UgY2FzZXMgYW5kIGl0J3Mgbm90IHBvc3NpYmxlIHRvIHBlcmZvcm0gYSBwcmVjaXNlIGFuZCBwZXJmb3JtYW5jZVxyXG4gICAgLy8gZWZmZWN0aXZlIHRlc3QgZm9yIGhpZGRlbiBlbGVtZW50cy4gRS5nLiBldmVuIGpRdWVyeSdzICc6dmlzaWJsZScgZmlsdGVyXHJcbiAgICAvLyBnaXZlcyB3cm9uZyByZXN1bHRzIGZvciBlbGVtZW50cyB3aXRoIHdpZHRoICYgaGVpZ2h0IGxlc3MgdGhhbiAwLjUuXHJcbiAgICBpZiAoIWNsaWVudFdpZHRoICYmICFjbGllbnRIZWlnaHQpIHtcclxuICAgICAgICByZXR1cm4gZW1wdHlSZWN0O1xyXG4gICAgfVxyXG4gICAgdmFyIHN0eWxlcyA9IGdldFdpbmRvd09mKHRhcmdldCkuZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpO1xyXG4gICAgdmFyIHBhZGRpbmdzID0gZ2V0UGFkZGluZ3Moc3R5bGVzKTtcclxuICAgIHZhciBob3JpelBhZCA9IHBhZGRpbmdzLmxlZnQgKyBwYWRkaW5ncy5yaWdodDtcclxuICAgIHZhciB2ZXJ0UGFkID0gcGFkZGluZ3MudG9wICsgcGFkZGluZ3MuYm90dG9tO1xyXG4gICAgLy8gQ29tcHV0ZWQgc3R5bGVzIG9mIHdpZHRoICYgaGVpZ2h0IGFyZSBiZWluZyB1c2VkIGJlY2F1c2UgdGhleSBhcmUgdGhlXHJcbiAgICAvLyBvbmx5IGRpbWVuc2lvbnMgYXZhaWxhYmxlIHRvIEpTIHRoYXQgY29udGFpbiBub24tcm91bmRlZCB2YWx1ZXMuIEl0IGNvdWxkXHJcbiAgICAvLyBiZSBwb3NzaWJsZSB0byB1dGlsaXplIHRoZSBnZXRCb3VuZGluZ0NsaWVudFJlY3QgaWYgb25seSBpdCdzIGRhdGEgd2Fzbid0XHJcbiAgICAvLyBhZmZlY3RlZCBieSBDU1MgdHJhbnNmb3JtYXRpb25zIGxldCBhbG9uZSBwYWRkaW5ncywgYm9yZGVycyBhbmQgc2Nyb2xsIGJhcnMuXHJcbiAgICB2YXIgd2lkdGggPSB0b0Zsb2F0KHN0eWxlcy53aWR0aCksIGhlaWdodCA9IHRvRmxvYXQoc3R5bGVzLmhlaWdodCk7XHJcbiAgICAvLyBXaWR0aCAmIGhlaWdodCBpbmNsdWRlIHBhZGRpbmdzIGFuZCBib3JkZXJzIHdoZW4gdGhlICdib3JkZXItYm94JyBib3hcclxuICAgIC8vIG1vZGVsIGlzIGFwcGxpZWQgKGV4Y2VwdCBmb3IgSUUpLlxyXG4gICAgaWYgKHN0eWxlcy5ib3hTaXppbmcgPT09ICdib3JkZXItYm94Jykge1xyXG4gICAgICAgIC8vIEZvbGxvd2luZyBjb25kaXRpb25zIGFyZSByZXF1aXJlZCB0byBoYW5kbGUgSW50ZXJuZXQgRXhwbG9yZXIgd2hpY2hcclxuICAgICAgICAvLyBkb2Vzbid0IGluY2x1ZGUgcGFkZGluZ3MgYW5kIGJvcmRlcnMgdG8gY29tcHV0ZWQgQ1NTIGRpbWVuc2lvbnMuXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBXZSBjYW4gc2F5IHRoYXQgaWYgQ1NTIGRpbWVuc2lvbnMgKyBwYWRkaW5ncyBhcmUgZXF1YWwgdG8gdGhlIFwiY2xpZW50XCJcclxuICAgICAgICAvLyBwcm9wZXJ0aWVzIHRoZW4gaXQncyBlaXRoZXIgSUUsIGFuZCB0aHVzIHdlIGRvbid0IG5lZWQgdG8gc3VidHJhY3RcclxuICAgICAgICAvLyBhbnl0aGluZywgb3IgYW4gZWxlbWVudCBtZXJlbHkgZG9lc24ndCBoYXZlIHBhZGRpbmdzL2JvcmRlcnMgc3R5bGVzLlxyXG4gICAgICAgIGlmIChNYXRoLnJvdW5kKHdpZHRoICsgaG9yaXpQYWQpICE9PSBjbGllbnRXaWR0aCkge1xyXG4gICAgICAgICAgICB3aWR0aCAtPSBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsICdsZWZ0JywgJ3JpZ2h0JykgKyBob3JpelBhZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKE1hdGgucm91bmQoaGVpZ2h0ICsgdmVydFBhZCkgIT09IGNsaWVudEhlaWdodCkge1xyXG4gICAgICAgICAgICBoZWlnaHQgLT0gZ2V0Qm9yZGVyc1NpemUoc3R5bGVzLCAndG9wJywgJ2JvdHRvbScpICsgdmVydFBhZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBGb2xsb3dpbmcgc3RlcHMgY2FuJ3QgYmUgYXBwbGllZCB0byB0aGUgZG9jdW1lbnQncyByb290IGVsZW1lbnQgYXMgaXRzXHJcbiAgICAvLyBjbGllbnRbV2lkdGgvSGVpZ2h0XSBwcm9wZXJ0aWVzIHJlcHJlc2VudCB2aWV3cG9ydCBhcmVhIG9mIHRoZSB3aW5kb3cuXHJcbiAgICAvLyBCZXNpZGVzLCBpdCdzIGFzIHdlbGwgbm90IG5lY2Vzc2FyeSBhcyB0aGUgPGh0bWw+IGl0c2VsZiBuZWl0aGVyIGhhc1xyXG4gICAgLy8gcmVuZGVyZWQgc2Nyb2xsIGJhcnMgbm9yIGl0IGNhbiBiZSBjbGlwcGVkLlxyXG4gICAgaWYgKCFpc0RvY3VtZW50RWxlbWVudCh0YXJnZXQpKSB7XHJcbiAgICAgICAgLy8gSW4gc29tZSBicm93c2VycyAob25seSBpbiBGaXJlZm94LCBhY3R1YWxseSkgQ1NTIHdpZHRoICYgaGVpZ2h0XHJcbiAgICAgICAgLy8gaW5jbHVkZSBzY3JvbGwgYmFycyBzaXplIHdoaWNoIGNhbiBiZSByZW1vdmVkIGF0IHRoaXMgc3RlcCBhcyBzY3JvbGxcclxuICAgICAgICAvLyBiYXJzIGFyZSB0aGUgb25seSBkaWZmZXJlbmNlIGJldHdlZW4gcm91bmRlZCBkaW1lbnNpb25zICsgcGFkZGluZ3NcclxuICAgICAgICAvLyBhbmQgXCJjbGllbnRcIiBwcm9wZXJ0aWVzLCB0aG91Z2ggdGhhdCBpcyBub3QgYWx3YXlzIHRydWUgaW4gQ2hyb21lLlxyXG4gICAgICAgIHZhciB2ZXJ0U2Nyb2xsYmFyID0gTWF0aC5yb3VuZCh3aWR0aCArIGhvcml6UGFkKSAtIGNsaWVudFdpZHRoO1xyXG4gICAgICAgIHZhciBob3JpelNjcm9sbGJhciA9IE1hdGgucm91bmQoaGVpZ2h0ICsgdmVydFBhZCkgLSBjbGllbnRIZWlnaHQ7XHJcbiAgICAgICAgLy8gQ2hyb21lIGhhcyBhIHJhdGhlciB3ZWlyZCByb3VuZGluZyBvZiBcImNsaWVudFwiIHByb3BlcnRpZXMuXHJcbiAgICAgICAgLy8gRS5nLiBmb3IgYW4gZWxlbWVudCB3aXRoIGNvbnRlbnQgd2lkdGggb2YgMzE0LjJweCBpdCBzb21ldGltZXMgZ2l2ZXNcclxuICAgICAgICAvLyB0aGUgY2xpZW50IHdpZHRoIG9mIDMxNXB4IGFuZCBmb3IgdGhlIHdpZHRoIG9mIDMxNC43cHggaXQgbWF5IGdpdmVcclxuICAgICAgICAvLyAzMTRweC4gQW5kIGl0IGRvZXNuJ3QgaGFwcGVuIGFsbCB0aGUgdGltZS4gU28ganVzdCBpZ25vcmUgdGhpcyBkZWx0YVxyXG4gICAgICAgIC8vIGFzIGEgbm9uLXJlbGV2YW50LlxyXG4gICAgICAgIGlmIChNYXRoLmFicyh2ZXJ0U2Nyb2xsYmFyKSAhPT0gMSkge1xyXG4gICAgICAgICAgICB3aWR0aCAtPSB2ZXJ0U2Nyb2xsYmFyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoTWF0aC5hYnMoaG9yaXpTY3JvbGxiYXIpICE9PSAxKSB7XHJcbiAgICAgICAgICAgIGhlaWdodCAtPSBob3JpelNjcm9sbGJhcjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY3JlYXRlUmVjdEluaXQocGFkZGluZ3MubGVmdCwgcGFkZGluZ3MudG9wLCB3aWR0aCwgaGVpZ2h0KTtcclxufVxyXG4vKipcclxuICogQ2hlY2tzIHdoZXRoZXIgcHJvdmlkZWQgZWxlbWVudCBpcyBhbiBpbnN0YW5jZSBvZiB0aGUgU1ZHR3JhcGhpY3NFbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdG8gYmUgY2hlY2tlZC5cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG52YXIgaXNTVkdHcmFwaGljc0VsZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgLy8gU29tZSBicm93c2VycywgbmFtZWx5IElFIGFuZCBFZGdlLCBkb24ndCBoYXZlIHRoZSBTVkdHcmFwaGljc0VsZW1lbnRcclxuICAgIC8vIGludGVyZmFjZS5cclxuICAgIGlmICh0eXBlb2YgU1ZHR3JhcGhpY3NFbGVtZW50ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0KSB7IHJldHVybiB0YXJnZXQgaW5zdGFuY2VvZiBnZXRXaW5kb3dPZih0YXJnZXQpLlNWR0dyYXBoaWNzRWxlbWVudDsgfTtcclxuICAgIH1cclxuICAgIC8vIElmIGl0J3Mgc28sIHRoZW4gY2hlY2sgdGhhdCBlbGVtZW50IGlzIGF0IGxlYXN0IGFuIGluc3RhbmNlIG9mIHRoZVxyXG4gICAgLy8gU1ZHRWxlbWVudCBhbmQgdGhhdCBpdCBoYXMgdGhlIFwiZ2V0QkJveFwiIG1ldGhvZC5cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1leHRyYS1wYXJlbnNcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0KSB7IHJldHVybiAodGFyZ2V0IGluc3RhbmNlb2YgZ2V0V2luZG93T2YodGFyZ2V0KS5TVkdFbGVtZW50ICYmXHJcbiAgICAgICAgdHlwZW9mIHRhcmdldC5nZXRCQm94ID09PSAnZnVuY3Rpb24nKTsgfTtcclxufSkoKTtcclxuLyoqXHJcbiAqIENoZWNrcyB3aGV0aGVyIHByb3ZpZGVkIGVsZW1lbnQgaXMgYSBkb2N1bWVudCBlbGVtZW50ICg8aHRtbD4pLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdG8gYmUgY2hlY2tlZC5cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5mdW5jdGlvbiBpc0RvY3VtZW50RWxlbWVudCh0YXJnZXQpIHtcclxuICAgIHJldHVybiB0YXJnZXQgPT09IGdldFdpbmRvd09mKHRhcmdldCkuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xyXG59XHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIGFuIGFwcHJvcHJpYXRlIGNvbnRlbnQgcmVjdGFuZ2xlIGZvciBwcm92aWRlZCBodG1sIG9yIHN2ZyBlbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgY29udGVudCByZWN0YW5nbGUgb2Ygd2hpY2ggbmVlZHMgdG8gYmUgY2FsY3VsYXRlZC5cclxuICogQHJldHVybnMge0RPTVJlY3RJbml0fVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0Q29udGVudFJlY3QodGFyZ2V0KSB7XHJcbiAgICBpZiAoIWlzQnJvd3Nlcikge1xyXG4gICAgICAgIHJldHVybiBlbXB0eVJlY3Q7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNTVkdHcmFwaGljc0VsZW1lbnQodGFyZ2V0KSkge1xyXG4gICAgICAgIHJldHVybiBnZXRTVkdDb250ZW50UmVjdCh0YXJnZXQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGdldEhUTUxFbGVtZW50Q29udGVudFJlY3QodGFyZ2V0KTtcclxufVxyXG4vKipcclxuICogQ3JlYXRlcyByZWN0YW5nbGUgd2l0aCBhbiBpbnRlcmZhY2Ugb2YgdGhlIERPTVJlY3RSZWFkT25seS5cclxuICogU3BlYzogaHR0cHM6Ly9kcmFmdHMuZnh0Zi5vcmcvZ2VvbWV0cnkvI2RvbXJlY3RyZWFkb25seVxyXG4gKlxyXG4gKiBAcGFyYW0ge0RPTVJlY3RJbml0fSByZWN0SW5pdCAtIE9iamVjdCB3aXRoIHJlY3RhbmdsZSdzIHgveSBjb29yZGluYXRlcyBhbmQgZGltZW5zaW9ucy5cclxuICogQHJldHVybnMge0RPTVJlY3RSZWFkT25seX1cclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVJlYWRPbmx5UmVjdChfYSkge1xyXG4gICAgdmFyIHggPSBfYS54LCB5ID0gX2EueSwgd2lkdGggPSBfYS53aWR0aCwgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xyXG4gICAgLy8gSWYgRE9NUmVjdFJlYWRPbmx5IGlzIGF2YWlsYWJsZSB1c2UgaXQgYXMgYSBwcm90b3R5cGUgZm9yIHRoZSByZWN0YW5nbGUuXHJcbiAgICB2YXIgQ29uc3RyID0gdHlwZW9mIERPTVJlY3RSZWFkT25seSAhPT0gJ3VuZGVmaW5lZCcgPyBET01SZWN0UmVhZE9ubHkgOiBPYmplY3Q7XHJcbiAgICB2YXIgcmVjdCA9IE9iamVjdC5jcmVhdGUoQ29uc3RyLnByb3RvdHlwZSk7XHJcbiAgICAvLyBSZWN0YW5nbGUncyBwcm9wZXJ0aWVzIGFyZSBub3Qgd3JpdGFibGUgYW5kIG5vbi1lbnVtZXJhYmxlLlxyXG4gICAgZGVmaW5lQ29uZmlndXJhYmxlKHJlY3QsIHtcclxuICAgICAgICB4OiB4LCB5OiB5LCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0LFxyXG4gICAgICAgIHRvcDogeSxcclxuICAgICAgICByaWdodDogeCArIHdpZHRoLFxyXG4gICAgICAgIGJvdHRvbTogaGVpZ2h0ICsgeSxcclxuICAgICAgICBsZWZ0OiB4XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZWN0O1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIERPTVJlY3RJbml0IG9iamVjdCBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgZGltZW5zaW9ucyBhbmQgdGhlIHgveSBjb29yZGluYXRlcy5cclxuICogU3BlYzogaHR0cHM6Ly9kcmFmdHMuZnh0Zi5vcmcvZ2VvbWV0cnkvI2RpY3RkZWYtZG9tcmVjdGluaXRcclxuICpcclxuICogQHBhcmFtIHtudW1iZXJ9IHggLSBYIGNvb3JkaW5hdGUuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gWSBjb29yZGluYXRlLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBSZWN0YW5nbGUncyB3aWR0aC5cclxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIFJlY3RhbmdsZSdzIGhlaWdodC5cclxuICogQHJldHVybnMge0RPTVJlY3RJbml0fVxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlUmVjdEluaXQoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgcmV0dXJuIHsgeDogeCwgeTogeSwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9O1xyXG59XG5cbi8qKlxyXG4gKiBDbGFzcyB0aGF0IGlzIHJlc3BvbnNpYmxlIGZvciBjb21wdXRhdGlvbnMgb2YgdGhlIGNvbnRlbnQgcmVjdGFuZ2xlIG9mXHJcbiAqIHByb3ZpZGVkIERPTSBlbGVtZW50IGFuZCBmb3Iga2VlcGluZyB0cmFjayBvZiBpdCdzIGNoYW5nZXMuXHJcbiAqL1xyXG52YXIgUmVzaXplT2JzZXJ2YXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgUmVzaXplT2JzZXJ2YXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IHRvIGJlIG9ic2VydmVkLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBSZXNpemVPYnNlcnZhdGlvbih0YXJnZXQpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBCcm9hZGNhc3RlZCB3aWR0aCBvZiBjb250ZW50IHJlY3RhbmdsZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5icm9hZGNhc3RXaWR0aCA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQnJvYWRjYXN0ZWQgaGVpZ2h0IG9mIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmJyb2FkY2FzdEhlaWdodCA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVmZXJlbmNlIHRvIHRoZSBsYXN0IG9ic2VydmVkIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGUge0RPTVJlY3RJbml0fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY29udGVudFJlY3RfID0gY3JlYXRlUmVjdEluaXQoMCwgMCwgMCwgMCk7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgY29udGVudCByZWN0YW5nbGUgYW5kIHRlbGxzIHdoZXRoZXIgaXQncyB3aWR0aCBvciBoZWlnaHQgcHJvcGVydGllc1xyXG4gICAgICogaGF2ZSBjaGFuZ2VkIHNpbmNlIHRoZSBsYXN0IGJyb2FkY2FzdC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2YXRpb24ucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByZWN0ID0gZ2V0Q29udGVudFJlY3QodGhpcy50YXJnZXQpO1xyXG4gICAgICAgIHRoaXMuY29udGVudFJlY3RfID0gcmVjdDtcclxuICAgICAgICByZXR1cm4gKHJlY3Qud2lkdGggIT09IHRoaXMuYnJvYWRjYXN0V2lkdGggfHxcclxuICAgICAgICAgICAgcmVjdC5oZWlnaHQgIT09IHRoaXMuYnJvYWRjYXN0SGVpZ2h0KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgJ2Jyb2FkY2FzdFdpZHRoJyBhbmQgJ2Jyb2FkY2FzdEhlaWdodCcgcHJvcGVydGllcyB3aXRoIGEgZGF0YVxyXG4gICAgICogZnJvbSB0aGUgY29ycmVzcG9uZGluZyBwcm9wZXJ0aWVzIG9mIHRoZSBsYXN0IG9ic2VydmVkIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtET01SZWN0SW5pdH0gTGFzdCBvYnNlcnZlZCBjb250ZW50IHJlY3RhbmdsZS5cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2YXRpb24ucHJvdG90eXBlLmJyb2FkY2FzdFJlY3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHJlY3QgPSB0aGlzLmNvbnRlbnRSZWN0XztcclxuICAgICAgICB0aGlzLmJyb2FkY2FzdFdpZHRoID0gcmVjdC53aWR0aDtcclxuICAgICAgICB0aGlzLmJyb2FkY2FzdEhlaWdodCA9IHJlY3QuaGVpZ2h0O1xyXG4gICAgICAgIHJldHVybiByZWN0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBSZXNpemVPYnNlcnZhdGlvbjtcclxufSgpKTtcblxudmFyIFJlc2l6ZU9ic2VydmVyRW50cnkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgUmVzaXplT2JzZXJ2ZXJFbnRyeS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdGhhdCBpcyBiZWluZyBvYnNlcnZlZC5cclxuICAgICAqIEBwYXJhbSB7RE9NUmVjdEluaXR9IHJlY3RJbml0IC0gRGF0YSBvZiB0aGUgZWxlbWVudCdzIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBSZXNpemVPYnNlcnZlckVudHJ5KHRhcmdldCwgcmVjdEluaXQpIHtcclxuICAgICAgICB2YXIgY29udGVudFJlY3QgPSBjcmVhdGVSZWFkT25seVJlY3QocmVjdEluaXQpO1xyXG4gICAgICAgIC8vIEFjY29yZGluZyB0byB0aGUgc3BlY2lmaWNhdGlvbiBmb2xsb3dpbmcgcHJvcGVydGllcyBhcmUgbm90IHdyaXRhYmxlXHJcbiAgICAgICAgLy8gYW5kIGFyZSBhbHNvIG5vdCBlbnVtZXJhYmxlIGluIHRoZSBuYXRpdmUgaW1wbGVtZW50YXRpb24uXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBQcm9wZXJ0eSBhY2Nlc3NvcnMgYXJlIG5vdCBiZWluZyB1c2VkIGFzIHRoZXknZCByZXF1aXJlIHRvIGRlZmluZSBhXHJcbiAgICAgICAgLy8gcHJpdmF0ZSBXZWFrTWFwIHN0b3JhZ2Ugd2hpY2ggbWF5IGNhdXNlIG1lbW9yeSBsZWFrcyBpbiBicm93c2VycyB0aGF0XHJcbiAgICAgICAgLy8gZG9uJ3Qgc3VwcG9ydCB0aGlzIHR5cGUgb2YgY29sbGVjdGlvbnMuXHJcbiAgICAgICAgZGVmaW5lQ29uZmlndXJhYmxlKHRoaXMsIHsgdGFyZ2V0OiB0YXJnZXQsIGNvbnRlbnRSZWN0OiBjb250ZW50UmVjdCB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBSZXNpemVPYnNlcnZlckVudHJ5O1xyXG59KCkpO1xuXG52YXIgUmVzaXplT2JzZXJ2ZXJTUEkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgUmVzaXplT2JzZXJ2ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtSZXNpemVPYnNlcnZlckNhbGxiYWNrfSBjYWxsYmFjayAtIENhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgaW52b2tlZFxyXG4gICAgICogICAgICB3aGVuIG9uZSBvZiB0aGUgb2JzZXJ2ZWQgZWxlbWVudHMgY2hhbmdlcyBpdCdzIGNvbnRlbnQgZGltZW5zaW9ucy5cclxuICAgICAqIEBwYXJhbSB7UmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyfSBjb250cm9sbGVyIC0gQ29udHJvbGxlciBpbnN0YW5jZSB3aGljaFxyXG4gICAgICogICAgICBpcyByZXNwb25zaWJsZSBmb3IgdGhlIHVwZGF0ZXMgb2Ygb2JzZXJ2ZXIuXHJcbiAgICAgKiBAcGFyYW0ge1Jlc2l6ZU9ic2VydmVyfSBjYWxsYmFja0N0eCAtIFJlZmVyZW5jZSB0byB0aGUgcHVibGljXHJcbiAgICAgKiAgICAgIFJlc2l6ZU9ic2VydmVyIGluc3RhbmNlIHdoaWNoIHdpbGwgYmUgcGFzc2VkIHRvIGNhbGxiYWNrIGZ1bmN0aW9uLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBSZXNpemVPYnNlcnZlclNQSShjYWxsYmFjaywgY29udHJvbGxlciwgY2FsbGJhY2tDdHgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb2xsZWN0aW9uIG9mIHJlc2l6ZSBvYnNlcnZhdGlvbnMgdGhhdCBoYXZlIGRldGVjdGVkIGNoYW5nZXMgaW4gZGltZW5zaW9uc1xyXG4gICAgICAgICAqIG9mIGVsZW1lbnRzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGUge0FycmF5PFJlc2l6ZU9ic2VydmF0aW9uPn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmFjdGl2ZU9ic2VydmF0aW9uc18gPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWdpc3RyeSBvZiB0aGUgUmVzaXplT2JzZXJ2YXRpb24gaW5zdGFuY2VzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGUge01hcDxFbGVtZW50LCBSZXNpemVPYnNlcnZhdGlvbj59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5vYnNlcnZhdGlvbnNfID0gbmV3IE1hcFNoaW0oKTtcclxuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBjYWxsYmFjayBwcm92aWRlZCBhcyBwYXJhbWV0ZXIgMSBpcyBub3QgYSBmdW5jdGlvbi4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jYWxsYmFja18gPSBjYWxsYmFjaztcclxuICAgICAgICB0aGlzLmNvbnRyb2xsZXJfID0gY29udHJvbGxlcjtcclxuICAgICAgICB0aGlzLmNhbGxiYWNrQ3R4XyA9IGNhbGxiYWNrQ3R4O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTdGFydHMgb2JzZXJ2aW5nIHByb3ZpZGVkIGVsZW1lbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IHRvIGJlIG9ic2VydmVkLlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyU1BJLnByb3RvdHlwZS5vYnNlcnZlID0gZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcxIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgb25seSAwIHByZXNlbnQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgY3VycmVudCBlbnZpcm9ubWVudCBkb2Vzbid0IGhhdmUgdGhlIEVsZW1lbnQgaW50ZXJmYWNlLlxyXG4gICAgICAgIGlmICh0eXBlb2YgRWxlbWVudCA9PT0gJ3VuZGVmaW5lZCcgfHwgIShFbGVtZW50IGluc3RhbmNlb2YgT2JqZWN0KSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghKHRhcmdldCBpbnN0YW5jZW9mIGdldFdpbmRvd09mKHRhcmdldCkuRWxlbWVudCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGFyYW1ldGVyIDEgaXMgbm90IG9mIHR5cGUgXCJFbGVtZW50XCIuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvYnNlcnZhdGlvbnMgPSB0aGlzLm9ic2VydmF0aW9uc187XHJcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiBlbGVtZW50IGlzIGFscmVhZHkgYmVpbmcgb2JzZXJ2ZWQuXHJcbiAgICAgICAgaWYgKG9ic2VydmF0aW9ucy5oYXModGFyZ2V0KSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9ic2VydmF0aW9ucy5zZXQodGFyZ2V0LCBuZXcgUmVzaXplT2JzZXJ2YXRpb24odGFyZ2V0KSk7XHJcbiAgICAgICAgdGhpcy5jb250cm9sbGVyXy5hZGRPYnNlcnZlcih0aGlzKTtcclxuICAgICAgICAvLyBGb3JjZSB0aGUgdXBkYXRlIG9mIG9ic2VydmF0aW9ucy5cclxuICAgICAgICB0aGlzLmNvbnRyb2xsZXJfLnJlZnJlc2goKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFN0b3BzIG9ic2VydmluZyBwcm92aWRlZCBlbGVtZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCB0byBzdG9wIG9ic2VydmluZy5cclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlclNQSS5wcm90b3R5cGUudW5vYnNlcnZlID0gZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcxIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgb25seSAwIHByZXNlbnQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgY3VycmVudCBlbnZpcm9ubWVudCBkb2Vzbid0IGhhdmUgdGhlIEVsZW1lbnQgaW50ZXJmYWNlLlxyXG4gICAgICAgIGlmICh0eXBlb2YgRWxlbWVudCA9PT0gJ3VuZGVmaW5lZCcgfHwgIShFbGVtZW50IGluc3RhbmNlb2YgT2JqZWN0KSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghKHRhcmdldCBpbnN0YW5jZW9mIGdldFdpbmRvd09mKHRhcmdldCkuRWxlbWVudCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGFyYW1ldGVyIDEgaXMgbm90IG9mIHR5cGUgXCJFbGVtZW50XCIuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvYnNlcnZhdGlvbnMgPSB0aGlzLm9ic2VydmF0aW9uc187XHJcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiBlbGVtZW50IGlzIG5vdCBiZWluZyBvYnNlcnZlZC5cclxuICAgICAgICBpZiAoIW9ic2VydmF0aW9ucy5oYXModGFyZ2V0KSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9ic2VydmF0aW9ucy5kZWxldGUodGFyZ2V0KTtcclxuICAgICAgICBpZiAoIW9ic2VydmF0aW9ucy5zaXplKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29udHJvbGxlcl8ucmVtb3ZlT2JzZXJ2ZXIodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU3RvcHMgb2JzZXJ2aW5nIGFsbCBlbGVtZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jbGVhckFjdGl2ZSgpO1xyXG4gICAgICAgIHRoaXMub2JzZXJ2YXRpb25zXy5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMuY29udHJvbGxlcl8ucmVtb3ZlT2JzZXJ2ZXIodGhpcyk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb2xsZWN0cyBvYnNlcnZhdGlvbiBpbnN0YW5jZXMgdGhlIGFzc29jaWF0ZWQgZWxlbWVudCBvZiB3aGljaCBoYXMgY2hhbmdlZFxyXG4gICAgICogaXQncyBjb250ZW50IHJlY3RhbmdsZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLmdhdGhlckFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuY2xlYXJBY3RpdmUoKTtcclxuICAgICAgICB0aGlzLm9ic2VydmF0aW9uc18uZm9yRWFjaChmdW5jdGlvbiAob2JzZXJ2YXRpb24pIHtcclxuICAgICAgICAgICAgaWYgKG9ic2VydmF0aW9uLmlzQWN0aXZlKCkpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmFjdGl2ZU9ic2VydmF0aW9uc18ucHVzaChvYnNlcnZhdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEludm9rZXMgaW5pdGlhbCBjYWxsYmFjayBmdW5jdGlvbiB3aXRoIGEgbGlzdCBvZiBSZXNpemVPYnNlcnZlckVudHJ5XHJcbiAgICAgKiBpbnN0YW5jZXMgY29sbGVjdGVkIGZyb20gYWN0aXZlIHJlc2l6ZSBvYnNlcnZhdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyU1BJLnByb3RvdHlwZS5icm9hZGNhc3RBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiBvYnNlcnZlciBkb2Vzbid0IGhhdmUgYWN0aXZlIG9ic2VydmF0aW9ucy5cclxuICAgICAgICBpZiAoIXRoaXMuaGFzQWN0aXZlKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY3R4ID0gdGhpcy5jYWxsYmFja0N0eF87XHJcbiAgICAgICAgLy8gQ3JlYXRlIFJlc2l6ZU9ic2VydmVyRW50cnkgaW5zdGFuY2UgZm9yIGV2ZXJ5IGFjdGl2ZSBvYnNlcnZhdGlvbi5cclxuICAgICAgICB2YXIgZW50cmllcyA9IHRoaXMuYWN0aXZlT2JzZXJ2YXRpb25zXy5tYXAoZnVuY3Rpb24gKG9ic2VydmF0aW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVzaXplT2JzZXJ2ZXJFbnRyeShvYnNlcnZhdGlvbi50YXJnZXQsIG9ic2VydmF0aW9uLmJyb2FkY2FzdFJlY3QoKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5jYWxsYmFja18uY2FsbChjdHgsIGVudHJpZXMsIGN0eCk7XHJcbiAgICAgICAgdGhpcy5jbGVhckFjdGl2ZSgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ2xlYXJzIHRoZSBjb2xsZWN0aW9uIG9mIGFjdGl2ZSBvYnNlcnZhdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyU1BJLnByb3RvdHlwZS5jbGVhckFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmFjdGl2ZU9ic2VydmF0aW9uc18uc3BsaWNlKDApO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVGVsbHMgd2hldGhlciBvYnNlcnZlciBoYXMgYWN0aXZlIG9ic2VydmF0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLmhhc0FjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmVPYnNlcnZhdGlvbnNfLmxlbmd0aCA+IDA7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyU1BJO1xyXG59KCkpO1xuXG4vLyBSZWdpc3RyeSBvZiBpbnRlcm5hbCBvYnNlcnZlcnMuIElmIFdlYWtNYXAgaXMgbm90IGF2YWlsYWJsZSB1c2UgY3VycmVudCBzaGltXHJcbi8vIGZvciB0aGUgTWFwIGNvbGxlY3Rpb24gYXMgaXQgaGFzIGFsbCByZXF1aXJlZCBtZXRob2RzIGFuZCBiZWNhdXNlIFdlYWtNYXBcclxuLy8gY2FuJ3QgYmUgZnVsbHkgcG9seWZpbGxlZCBhbnl3YXkuXHJcbnZhciBvYnNlcnZlcnMgPSB0eXBlb2YgV2Vha01hcCAhPT0gJ3VuZGVmaW5lZCcgPyBuZXcgV2Vha01hcCgpIDogbmV3IE1hcFNoaW0oKTtcclxuLyoqXHJcbiAqIFJlc2l6ZU9ic2VydmVyIEFQSS4gRW5jYXBzdWxhdGVzIHRoZSBSZXNpemVPYnNlcnZlciBTUEkgaW1wbGVtZW50YXRpb25cclxuICogZXhwb3Npbmcgb25seSB0aG9zZSBtZXRob2RzIGFuZCBwcm9wZXJ0aWVzIHRoYXQgYXJlIGRlZmluZWQgaW4gdGhlIHNwZWMuXHJcbiAqL1xyXG52YXIgUmVzaXplT2JzZXJ2ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgUmVzaXplT2JzZXJ2ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtSZXNpemVPYnNlcnZlckNhbGxiYWNrfSBjYWxsYmFjayAtIENhbGxiYWNrIHRoYXQgaXMgaW52b2tlZCB3aGVuXHJcbiAgICAgKiAgICAgIGRpbWVuc2lvbnMgb2YgdGhlIG9ic2VydmVkIGVsZW1lbnRzIGNoYW5nZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gUmVzaXplT2JzZXJ2ZXIoY2FsbGJhY2spIHtcclxuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVzaXplT2JzZXJ2ZXIpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbi4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5IDAgcHJlc2VudC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNvbnRyb2xsZXIgPSBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIuZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXJTUEkoY2FsbGJhY2ssIGNvbnRyb2xsZXIsIHRoaXMpO1xyXG4gICAgICAgIG9ic2VydmVycy5zZXQodGhpcywgb2JzZXJ2ZXIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyO1xyXG59KCkpO1xyXG4vLyBFeHBvc2UgcHVibGljIG1ldGhvZHMgb2YgUmVzaXplT2JzZXJ2ZXIuXHJcbltcclxuICAgICdvYnNlcnZlJyxcclxuICAgICd1bm9ic2VydmUnLFxyXG4gICAgJ2Rpc2Nvbm5lY3QnXHJcbl0uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XHJcbiAgICBSZXNpemVPYnNlcnZlci5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgcmV0dXJuIChfYSA9IG9ic2VydmVycy5nZXQodGhpcykpW21ldGhvZF0uYXBwbHkoX2EsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG59KTtcblxudmFyIGluZGV4ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8vIEV4cG9ydCBleGlzdGluZyBpbXBsZW1lbnRhdGlvbiBpZiBhdmFpbGFibGUuXHJcbiAgICBpZiAodHlwZW9mIGdsb2JhbCQxLlJlc2l6ZU9ic2VydmVyICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybiBnbG9iYWwkMS5SZXNpemVPYnNlcnZlcjtcclxuICAgIH1cclxuICAgIHJldHVybiBSZXNpemVPYnNlcnZlcjtcclxufSkoKTtcblxuZXhwb3J0IGRlZmF1bHQgaW5kZXg7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("(app-client)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=G%3A%5Cobject_hunt%5Capp%5Cg%5Cpage.tsx&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);